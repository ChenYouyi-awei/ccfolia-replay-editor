<!DOCTYPE html>
<html lang="ja">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=600, initial-scale=1.0" />
		<title>CCFOLIA Replay Editor</title>
		<style>
			/* === CSS Reset & Base === */
			*,
			*::before,
			*::after {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}

			html {
				min-width: 600px;
			}

			/* === Custom Scrollbar === */
			::-webkit-scrollbar {
				width: 8px;
				height: 8px;
			}

			::-webkit-scrollbar-track {
				background: var(--bg-dark);
				border-radius: 4px;
			}

			::-webkit-scrollbar-thumb {
				background: var(--border-light);
				border-radius: 4px;
				transition: background 0.2s;
			}

			::-webkit-scrollbar-thumb:hover {
				background: var(--text-secondary);
			}

			::-webkit-scrollbar-corner {
				background: var(--bg-dark);
			}

			/* Firefox scrollbar */
			* {
				scrollbar-width: thin;
				scrollbar-color: var(--border-light) var(--bg-dark);
			}

			:root {
				/* CCFOLIA 风格配色 */
				--primary-color: #5e81ac;
				--primary-hover: #6d91c0;
				--bg-dark: #1e2228;
				--bg-panel: #15181d;
				--bg-card: #24282f;
				--bg-secondary: #333842;
				--bg-secondary-hover: #3a3f4a;
				--text-primary: #eceff4;
				--text-default: #d8dee9;
				--text-secondary: #9da5b0;
				--border-color: #2d3239;
				--border-light: #3d4551;
				--bg-input: #24282f;

				/* 状态颜色 */
				--success-color: #a3be8c;
				--warning-color: #ebcb8b;
				--error-color: #bf616a;
				--critical-color: #d08770;
				--fumble-color: #bf616a;
				--danger-color: #e74c3c;

				/* 尺寸 */
				--editor-width: 400px;
				--header-height: 56px;
				--transition-speed: 0.3s;
				--radius-sm: 3px;
				--radius-md: 6px;
			}

			body {
				font-family: "Segoe UI", "Hiragino Sans", "Meiryo", sans-serif;
				background-color: var(--bg-dark);
				color: var(--text-primary);
				min-height: 100vh;
				min-width: 600px;
				overflow-x: auto;
				overflow-y: hidden;
			}

			/* === Layout === */
			.app-container {
				display: flex;
				flex-direction: column;
				height: 100vh;
				min-width: 600px;
			}

			/* === Header === */
			.app-header {
				height: var(--header-height);
				background: var(--bg-panel);
				border-bottom: 1px solid var(--border-color);
				display: flex;
				align-items: center;
				justify-content: space-between;
				padding: 0 16px;
				flex-shrink: 0;
			}

			.app-title {
				font-size: 1.25rem;
				font-weight: 600;
				color: var(--text-primary);
			}

			.header-actions {
				display: flex;
				gap: 8px;
			}

			/* === Main Content === */
			.main-content {
				display: flex;
				flex: 1;
				overflow: hidden;
				position: relative;
			}

			/* === Preview Area (Player) === */
			.preview-area {
				flex: 1;
				display: flex;
				flex-direction: column;
				background: var(--bg-dark);
				position: relative;
				overflow: hidden;
			}

			/* View Mode Switcher */
			.view-switcher {
				position: absolute;
				top: 12px;
				left: 12px;
				z-index: 20;
				display: flex;
				gap: 4px;
				background: var(--bg-panel);
				padding: 4px;
				border-radius: var(--radius-md);
				border: 1px solid var(--border-color);
			}

			.view-btn {
				padding: 6px 12px;
				border: none;
				border-radius: var(--radius-sm);
				background: transparent;
				color: var(--text-secondary);
				font-size: 0.8rem;
				cursor: pointer;
				transition: all 0.2s;
			}

			.view-btn:hover {
				color: var(--text-primary);
			}

			.view-btn.active {
				background: var(--primary-color);
				color: var(--text-primary);
			}

			/* View Containers */
			.view-container {
				flex: 1;
				display: none;
				flex-direction: column;
				overflow: hidden;
			}

			.view-container.active {
				display: flex;
			}

			/* Message List View */
			.message-list-view {
				flex: 1;
				display: flex;
				flex-direction: column;
				overflow: hidden;
			}

			.message-list-header {
				padding: 19px 16px;
				background: var(--bg-panel);
				border-bottom: 1px solid var(--border-color);
				display: flex;
				align-items: center;
				justify-content: flex-end;
				gap: 12px;
			}

			.message-list-actions {
				display: flex;
				gap: 8px;
				align-items: center;
			}

			.icon-btn {
				width: 32px;
				height: 32px;
				padding: 0;
				border: 1px solid var(--border-color);
				border-radius: var(--radius-sm);
				background: var(--bg-input);
				color: var(--text-primary);
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 0.9rem;
				transition: all 0.2s ease;
			}

			.icon-btn:hover {
				background: var(--bg-card);
				border-color: var(--primary-color);
			}

			.icon-btn.active {
				background: var(--primary-color);
				border-color: var(--primary-color);
			}

			.message-search-toolbar {
				display: none;
				background: var(--bg-panel);
				border-bottom: 1px solid var(--border-color);
				padding: 8px 16px;
				align-items: center;
				gap: 8px;
			}

			.message-search-toolbar.visible {
				display: flex;
			}

			.message-search-select {
				padding: 6px 8px;
				background: var(--bg-input);
				border: 1px solid var(--border-color);
				border-radius: var(--radius-sm);
				color: var(--text-primary);
				font-size: 0.85rem;
				min-width: 100px;
			}

			.message-search-input {
				flex: 1;
				padding: 6px 10px;
				background: var(--bg-input);
				border: 1px solid var(--border-color);
				border-radius: var(--radius-sm);
				color: var(--text-primary);
				font-size: 0.85rem;
				min-width: 120px;
			}

			.message-search-input:focus {
				outline: none;
				border-color: var(--primary-color);
			}

			.message-search-nav {
				display: flex;
				align-items: center;
				gap: 4px;
			}

			.message-search-count {
				font-size: 0.8rem;
				color: var(--text-secondary);
				min-width: 40px;
				text-align: center;
			}

			.message-item.search-highlight {
				background: rgba(94, 129, 172, 0.2) !important;
				border-left: 3px solid var(--primary-color);
			}

			.page-size-select {
				padding: 4px 8px;
				background: var(--bg-input);
				border: 1px solid var(--border-color);
				border-radius: var(--radius-sm);
				color: var(--text-primary);
				font-size: 0.8rem;
			}

			.page-size-label {
				font-size: 0.8rem;
				color: var(--text-secondary);
			}

			.message-list-container {
				flex: 1;
				overflow-y: auto;
			}

			.message-list-full {
				list-style: none;
			}

			.message-list-full .message-item {
				padding: 12px 16px;
				border-bottom: 1px solid var(--border-color);
				cursor: pointer;
				transition: background 0.2s ease;
				display: flex;
				flex-wrap: wrap;
			}

			.message-list-full .message-item:hover {
				background: var(--bg-card);
			}

			.message-list-full .message-item.active {
				background: var(--bg-card);
				border-left: 3px solid var(--primary-color);
			}

			.message-item-icon {
				width: 48px;
				height: 48px;
				border-radius: var(--radius-md);
				object-fit: cover;
				flex-shrink: 0;
			}

			.message-item-content {
				flex: 1;
				min-width: 0;
			}

			.message-item-header {
				display: flex;
				align-items: center;
				gap: 8px;
				margin-bottom: 4px;
			}

			.message-item-name {
				font-weight: 600;
				color: var(--primary-color);
			}

			.message-item-channel {
				font-size: 0.75rem;
				color: var(--text-secondary);
				background: var(--bg-secondary);
				padding: 2px 6px;
				border-radius: var(--radius-sm);
			}

			.message-item-badge {
				font-size: 0.7rem;
				padding: 2px 6px;
				border-radius: var(--radius-sm);
			}

			.message-item-badge.inserted {
				background: var(--success-color);
				color: #000;
			}

			.message-item-badge.edited {
				background: var(--warning-color);
				color: #000;
			}

			.message-item-badge.stage-enter {
				background: #81c784;
				color: #000;
			}

			.message-item-badge.stage-exit {
				background: #e57373;
				color: #fff;
			}

			.message-item-text {
				color: var(--text-default);
				line-height: 1.5;
				word-break: break-word;
			}

			/* Stage markers in message */
			.stage-markers {
				display: flex;
				flex-wrap: wrap;
				gap: 4px;
				margin-top: 4px;
			}

			.stage-marker {
				font-size: 0.7rem;
				padding: 2px 6px;
				border-radius: var(--radius-sm);
				display: inline-flex;
				align-items: center;
				gap: 4px;
			}

			.stage-marker.enter {
				background: rgba(129, 199, 132, 0.3);
				color: #81c784;
				border: 1px solid #81c784;
			}

			.stage-marker.exit {
				background: rgba(229, 115, 115, 0.3);
				color: #e57373;
				border: 1px solid #e57373;
			}

			.stage-marker .remove-marker {
				cursor: pointer;
				opacity: 0.7;
				font-size: 0.8rem;
			}

			.stage-marker .remove-marker:hover {
				opacity: 1;
			}

			/* Background marker in message list */
			.message-item-badge.background {
				background: var(--primary-color);
				color: #fff;
			}

			.background-marker {
				font-size: 0.7rem;
				padding: 2px 6px;
				border-radius: var(--radius-sm);
				display: inline-flex;
				align-items: center;
				gap: 4px;
				background: rgba(94, 129, 172, 0.3);
				color: var(--primary-color);
				border: 1px solid var(--primary-color);
			}

			.background-marker .remove-marker {
				cursor: pointer;
				opacity: 0.7;
				font-size: 0.8rem;
			}

			.background-marker .remove-marker:hover {
				opacity: 1;
			}

			/* BGM marker in message list */
			.message-item-badge.bgm {
				background: #9b59b6;
				color: #fff;
			}

			.bgm-marker {
				font-size: 0.7rem;
				padding: 2px 6px;
				border-radius: var(--radius-sm);
				display: inline-flex;
				align-items: center;
				gap: 4px;
				background: rgba(155, 89, 182, 0.3);
				color: #9b59b6;
				border: 1px solid #9b59b6;
			}

			.bgm-marker .remove-marker {
				cursor: pointer;
				opacity: 0.7;
				font-size: 0.8rem;
			}

			.bgm-marker .remove-marker:hover {
				opacity: 1;
			}

			.bgm-marker.stop-bgm {
				background: rgba(231, 76, 60, 0.2);
				color: var(--error-color);
				border-color: var(--error-color);
			}

			/* Background switch list item */
			.background-switch-item {
				display: flex;
				align-items: center;
				gap: 8px;
				padding: 8px;
				border-bottom: 1px solid var(--border-color);
				cursor: pointer;
				transition: background 0.2s;
			}

			.background-switch-item:last-child {
				border-bottom: none;
			}

			.background-switch-item:hover {
				background: var(--bg-secondary);
			}

			.background-switch-item .bg-thumbnail {
				width: 48px;
				height: 32px;
				border-radius: 4px;
				background-size: cover;
				background-position: center;
				border: 1px solid var(--border-color);
				flex-shrink: 0;
			}

			.background-switch-item .bg-info {
				flex: 1;
				min-width: 0;
			}

			.background-switch-item .bg-message {
				font-size: 0.8rem;
				color: var(--text-primary);
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}

			.background-switch-item .bg-index {
				font-size: 0.7rem;
				color: var(--text-secondary);
			}

			.background-switch-item .bg-remove {
				padding: 4px 8px;
				border: none;
				border-radius: var(--radius-sm);
				background: transparent;
				color: var(--text-secondary);
				cursor: pointer;
				transition: all 0.2s;
			}

			.background-switch-item .bg-remove:hover {
				background: var(--error-color);
				color: white;
			}

			/* BGM switch list item */
			.bgm-switch-item {
				display: flex;
				align-items: center;
				gap: 8px;
				padding: 8px;
				border-bottom: 1px solid var(--border-color);
				cursor: pointer;
				transition: background 0.2s;
			}

			.bgm-switch-item:last-child {
				border-bottom: none;
			}

			.bgm-switch-item:hover {
				background: var(--bg-secondary);
			}

			.bgm-switch-item .bgm-remove:hover {
				background: var(--error-color);
				color: white;
			}

			.message-item-actions {
				width: 100%;
				display: flex;
				align-items: center;
				gap: 6px;
				padding: 0;
				padding-left: 73.2px;
				margin: 0;
				max-height: 0;
				overflow: hidden;
				opacity: 0;
				transition: max-height 0.25s ease, opacity 0.25s ease, padding-top 0.25s ease, margin-top 0.25s ease;
			}

			/* 编辑模式：操作栏始终显示 */
			.message-list-full.edit-mode .message-item-actions {
				max-height: 50px;
				padding-top: 10px;
				margin-top: 8px;
				opacity: 1;
			}

			.message-action-btn {
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 4px;
				height: 28px;
				padding: 0 10px;
				border: none;
				border-radius: var(--radius-sm);
				background: var(--bg-secondary);
				color: var(--text-secondary);
				font-size: 0.8rem;
				line-height: 1;
				cursor: pointer;
				transition: all 0.15s ease;
				white-space: nowrap;
			}

			.message-action-btn:hover {
				background: var(--primary-color);
				color: white;
			}

			.message-action-btn.delete {
				background: var(--bg-secondary);
			}

			.message-action-btn.delete:hover {
				background: var(--error-color);
				color: white;
			}

			/* Message batch selection */
			.message-batch-mode .message-item {
				padding-left: 48px;
				position: relative;
			}

			/* Hide drag handle and action buttons in batch mode */
			.message-batch-mode .drag-handle {
				display: none;
			}

			.message-batch-mode .message-item-actions {
				display: none !important;
			}

			/* Disable draggable in batch mode */
			.message-batch-mode .message-item {
				cursor: default;
			}

			.message-batch-checkbox {
				position: absolute;
				left: 16px;
				top: 50%;
				transform: translateY(-50%);
				width: 18px;
				height: 18px;
				cursor: pointer;
			}

			.message-batch-toolbar {
				display: none;
				background: var(--bg-panel);
				border-bottom: 1px solid var(--border-color);
				padding: 12px 16px;
				align-items: center;
				justify-content: space-between;
				gap: 12px;
			}

			.message-batch-toolbar.visible {
				display: flex;
			}

			.message-batch-count {
				font-size: 0.9rem;
				color: var(--text-primary);
				font-weight: 500;
			}

			.message-batch-actions {
				display: flex;
				gap: 8px;
				align-items: center;
			}

			.message-batch-delete-btn {
				border-color: var(--error-color) !important;
				color: var(--error-color) !important;
			}

			.message-batch-delete-btn:hover {
				background: var(--error-color) !important;
				color: white !important;
			}

			/* Drag handle */
			.drag-handle {
				cursor: grab;
				padding: 12px 12px;
				margin: -12px -4px -12px -12px;
				color: var(--text-secondary);
				font-size: 1rem;
				user-select: none;
				display: flex;
				align-items: center;
			}

			.drag-handle:hover {
				color: var(--text-primary);
			}

			.drag-handle:active {
				cursor: grabbing;
			}

			.message-item.dragging {
				opacity: 0.5;
				background: var(--bg-card);
			}

			.message-item.drag-over-top {
				border-top: 2px solid var(--primary-color);
			}

			.message-item.drag-over-bottom {
				border-bottom: 2px solid var(--primary-color);
			}

			.message-action-btn {
				padding: 4px 8px;
				border: none;
				border-radius: var(--radius-sm);
				background: var(--bg-secondary);
				color: var(--text-secondary);
				font-size: 0.75rem;
				cursor: pointer;
				transition: all 0.2s;
			}

			.message-action-btn:hover {
				background: var(--bg-secondary-hover);
				color: var(--text-primary);
			}

			.message-action-btn.delete:hover {
				background: var(--error-color);
				color: white;
			}

			/* Pagination */
			.pagination {
				padding: 12px 16px;
				background: var(--bg-panel);
				border-top: 1px solid var(--border-color);
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 8px;
			}

			.pagination-btn {
				padding: 6px 12px;
				border: 1px solid var(--border-color);
				border-radius: var(--radius-sm);
				background: var(--bg-secondary);
				color: var(--text-primary);
				font-size: 0.8rem;
				cursor: pointer;
				transition: all 0.2s;
			}

			.pagination-btn:hover:not(:disabled) {
				background: var(--bg-secondary-hover);
			}

			.pagination-btn:disabled {
				opacity: 0.5;
				cursor: not-allowed;
			}

			.pagination-info {
				font-size: 0.85rem;
				color: var(--text-secondary);
			}

			.pagination-label {
				font-size: 0.85rem;
				color: var(--text-secondary);
			}

			.pagination-input {
				width: 50px;
				padding: 4px 8px;
				border: 1px solid var(--border-color);
				border-radius: var(--radius-sm);
				background: var(--bg-input);
				color: var(--text-primary);
				font-size: 0.85rem;
				text-align: center;
			}

			.pagination-input:focus {
				outline: none;
				border-color: var(--primary-color);
			}

			/* Hide number input spinners */
			.pagination-input::-webkit-outer-spin-button,
			.pagination-input::-webkit-inner-spin-button {
				-webkit-appearance: none;
				appearance: none;
				margin: 0;
			}
			.pagination-input[type="number"] {
				-moz-appearance: textfield;
				appearance: textfield;
			}

			.player-container {
				flex: 1;
				display: flex;
				flex-direction: column;
				position: relative;
				overflow: hidden;
			}

			/* Portrait Area - 覆盖整个播放器区域 */
			.portrait-area {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				display: flex;
				align-items: flex-end;
				justify-content: center;
				padding: 20px;
				padding-bottom: 180px; /* 为对话框留出空间 */
				overflow: hidden;
				background-size: cover;
				background-position: center;
				background-repeat: no-repeat;
			}

			/* Background transition overlay for smooth crossfade */
			.portrait-area::before {
				content: "";
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background-image: var(--new-bg, none);
				background-size: cover;
				background-position: center;
				background-repeat: no-repeat;
				opacity: 0;
				transition: opacity 0.5s ease-in-out;
				pointer-events: none;
				z-index: 0;
			}

			.portrait-area.bg-transitioning::before {
				opacity: 1;
			}

			/* Canvas mode - 固定画布容器，像视频播放器 */
			.portrait-area.canvas-mode {
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 0;
				padding-bottom: 0; /* 画布模式下对话框在画布内 */
				overflow: hidden;
				cursor: grab;
			}

			/* Canvas mode outer background - blurred enlarged effect */
			.portrait-area.canvas-mode::after {
				content: "";
				position: absolute;
				top: -20px;
				left: -20px;
				right: -20px;
				bottom: -20px;
				background-image: inherit;
				background-size: cover;
				background-position: center;
				filter: blur(20px) brightness(0.4);
				z-index: -1;
			}

			.portrait-area.canvas-mode.dragging-canvas {
				cursor: grabbing;
			}

			.portrait-area.canvas-mode .portrait-canvas-inner {
				position: absolute;
				top: 0;
				left: 0;
				background: var(--bg-dark);
				border: 1px solid var(--border-color);
				overflow: hidden;
				transform-origin: top left;
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
				will-change: transform;
				transition: transform var(--transition-speed) ease;
			}

			/* Disable transition during drag or zoom */
			.portrait-area.canvas-mode.dragging-canvas .portrait-canvas-inner,
			.portrait-area.canvas-mode.zooming .portrait-canvas-inner {
				transition: none;
			}

			/* 画布模式下的对话框 - 在画布内部 */
			.portrait-area.canvas-mode ~ .dialogue-area {
				display: none; /* 隐藏外部对话框 */
			}

			/* Canvas dialogue box - 直接可拖拽调整的对话框 */
			.portrait-canvas-inner .canvas-dialogue-box {
				position: absolute;
				bottom: 20px;
				left: 50%;
				transform: translateX(-50%);
				background: rgba(0, 0, 0, 0.75);
				border: 2px solid var(--border-color);
				border-radius: 8px;
				padding: 16px 20px;
				width: 80%;
				min-width: 300px;
				min-height: 80px;
				z-index: 10;
				cursor: move;
				pointer-events: auto;
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
			}

			.portrait-canvas-inner .canvas-dialogue-box.custom-position {
				transform: none;
				left: auto;
				bottom: auto;
			}

			.portrait-canvas-inner .canvas-dialogue-box.dragging {
				opacity: 0.9;
				border-color: var(--primary-color);
			}

			.portrait-canvas-inner .canvas-dialogue-box .drag-hint {
				position: absolute;
				top: -18px;
				left: 50%;
				transform: translateX(-50%);
				font-size: 0.65rem;
				color: var(--text-secondary);
				opacity: 0;
				transition: opacity 0.2s;
				pointer-events: none;
				white-space: nowrap;
			}

			.portrait-canvas-inner .canvas-dialogue-box:hover .drag-hint {
				opacity: 0.8;
			}

			/* Dialogue resize handles */
			.portrait-canvas-inner .canvas-dialogue-box .dialogue-resize-handle {
				position: absolute;
				width: 12px;
				height: 12px;
				background: var(--primary-color);
				border: 2px solid white;
				border-radius: 50%;
				opacity: 0;
				transition: opacity 0.2s;
				z-index: 20;
				pointer-events: auto;
			}

			.portrait-canvas-inner .canvas-dialogue-box:hover .dialogue-resize-handle {
				opacity: 1;
			}

			.dialogue-resize-handle.top-left {
				top: -6px;
				left: -6px;
				cursor: nwse-resize;
			}

			.dialogue-resize-handle.top-right {
				top: -6px;
				right: -6px;
				cursor: nesw-resize;
			}

			.dialogue-resize-handle.bottom-left {
				bottom: -6px;
				left: -6px;
				cursor: nesw-resize;
			}

			.dialogue-resize-handle.bottom-right {
				bottom: -6px;
				right: -6px;
				cursor: nwse-resize;
			}

			.dialogue-resize-handle.middle-right {
				top: 50%;
				right: -6px;
				transform: translateY(-50%);
				cursor: ew-resize;
			}

			.dialogue-resize-handle.middle-left {
				top: 50%;
				left: -6px;
				transform: translateY(-50%);
				cursor: ew-resize;
			}

			.dialogue-resize-handle.middle-top {
				top: -6px;
				left: 50%;
				transform: translateX(-50%);
				cursor: ns-resize;
			}

			.dialogue-resize-handle.middle-bottom {
				bottom: -6px;
				left: 50%;
				transform: translateX(-50%);
				cursor: ns-resize;
			}

			.portrait-canvas-inner .canvas-dialogue-name {
				font-size: 1rem;
				font-weight: 600;
				color: var(--primary-color);
				margin-bottom: 8px;
			}

			.portrait-canvas-inner .canvas-dialogue-text {
				font-size: 1.1rem;
				line-height: 1.7;
				color: var(--text-primary);
			}

			/* Single portrait (default) */
			.portrait-image {
				max-height: 90%;
				max-width: 70%;
				object-fit: contain;
				transition: opacity 0.3s ease;
				position: absolute;
				bottom: 160px; /* 在对话框上方 */
				user-select: none;
				z-index: 1;
			}

			.portrait-image.fade-in {
				animation: portraitFadeIn 0.3s ease;
			}

			.portrait-image.fade-out {
				animation: portraitFadeOut 0.3s ease;
			}

			@keyframes portraitFadeIn {
				from {
					opacity: 0;
					transform: translateY(10px);
				}
				to {
					opacity: 1;
					transform: translateY(0);
				}
			}

			@keyframes portraitFadeOut {
				from {
					opacity: 1;
					transform: translateY(0);
				}
				to {
					opacity: 0;
					transform: translateY(10px);
				}
			}

			/* Multi-portrait mode */
			.portrait-area.multi-mode {
				justify-content: space-around;
				align-items: flex-end;
			}

			.portrait-wrapper {
				position: absolute;
				cursor: move;
				user-select: none;
				transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s ease;
				z-index: 1;
			}

			.portrait-wrapper.dragging {
				opacity: 0.8;
				z-index: 100;
				transition: none;
			}

			/* 不在场的角色 - 完全不显示 */
			.portrait-wrapper.offstage {
				display: none;
			}

			/* 在场但不是当前发言者 - 半透明 */
			.portrait-wrapper.inactive {
				opacity: 0.5;
				filter: brightness(0.7);
			}

			/* 当前发言者 - 完全显示 */
			.portrait-wrapper.speaking {
				opacity: 1;
				filter: none;
			}

			.portrait-wrapper .portrait-image {
				position: relative;
				max-height: none;
				max-width: none;
				width: 100%;
				height: 100%;
				bottom: auto;
			}

			/* Resize handles */
			.portrait-wrapper .resize-handle {
				position: absolute;
				width: 12px;
				height: 12px;
				background: var(--primary-color);
				border: 2px solid white;
				border-radius: 50%;
				opacity: 0;
				transition: opacity 0.2s;
				z-index: 10;
			}

			.portrait-wrapper:hover .resize-handle,
			.portrait-wrapper.dragging .resize-handle {
				opacity: 1;
			}

			.resize-handle.top-left {
				top: -6px;
				left: -6px;
				cursor: nwse-resize;
			}

			.resize-handle.top-right {
				top: -6px;
				right: -6px;
				cursor: nesw-resize;
			}

			.resize-handle.bottom-left {
				bottom: -6px;
				left: -6px;
				cursor: nesw-resize;
			}

			.resize-handle.bottom-right {
				bottom: -6px;
				right: -6px;
				cursor: nwse-resize;
			}

			/* Portrait name label */
			.portrait-wrapper .portrait-label {
				position: absolute;
				bottom: -24px;
				left: 50%;
				transform: translateX(-50%);
				background: rgba(0, 0, 0, 0.7);
				color: var(--text-primary);
				padding: 2px 8px;
				border-radius: 4px;
				font-size: 0.75rem;
				white-space: nowrap;
				opacity: 0;
				transition: opacity 0.2s;
			}

			.portrait-wrapper:hover .portrait-label {
				opacity: 1;
			}

			/* Dialogue Box - 悬浮在底部 */
			.dialogue-area {
				position: absolute;
				bottom: 0;
				left: 0;
				right: 0;
				background: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.8));
				padding: 20px;
				min-height: 160px;
				cursor: pointer;
				z-index: 10;
			}

			.dialogue-box {
				background: rgba(0, 0, 0, 0.7);
				border: 2px solid var(--border-color);
				border-radius: 8px;
				padding: 16px 20px;
				max-width: 800px;
				margin: 0 auto;
				position: relative;
			}

			.dialogue-name {
				font-size: 1rem;
				font-weight: 600;
				color: var(--primary-color);
				margin-bottom: 8px;
			}

			.dialogue-text {
				font-size: 1.1rem;
				line-height: 1.8;
				color: var(--text-primary);
				min-height: 3em;
			}

			/* Typing cursor */
			.dialogue-text.typing::after {
				content: "▌";
				animation: blink 0.7s infinite;
				color: var(--primary-color);
			}

			@keyframes blink {
				0%,
				50% {
					opacity: 1;
				}
				51%,
				100% {
					opacity: 0;
				}
			}

			/* Click indicator */
			.click-indicator {
				position: absolute;
				bottom: 8px;
				right: 12px;
				font-size: 0.75rem;
				color: var(--text-secondary);
				opacity: 0;
				transition: opacity 0.3s;
			}

			.dialogue-box:not(.typing) .click-indicator {
				opacity: 1;
				animation: bounce 1s infinite;
			}

			@keyframes bounce {
				0%,
				100% {
					transform: translateY(0);
				}
				50% {
					transform: translateY(-3px);
				}
			}

			/* Player Controls */
			.player-controls {
				background: var(--bg-panel);
				border-top: 1px solid var(--border-color);
				padding: 12px 16px;
				display: flex;
				align-items: center;
				gap: 12px;
			}

			.progress-bar {
				flex: 1;
				height: 6px;
				background: var(--border-color);
				border-radius: 3px;
				cursor: pointer;
				position: relative;
			}

			.progress-bar:hover {
				height: 8px;
			}

			.progress-fill {
				height: 100%;
				background: var(--primary-color);
				border-radius: 3px;
				width: 0%;
				transition: width 0.1s ease;
				pointer-events: none;
			}

			.progress-bar:hover .progress-fill {
				background: var(--primary-hover);
			}

			.progress-text {
				font-size: 0.875rem;
				color: var(--text-secondary);
				min-width: 80px;
				text-align: right;
			}

			/* === Editor Panel (Drawer) === */
			.editor-panel {
				width: var(--editor-width);
				background: var(--bg-panel);
				border-left: 1px solid var(--border-color);
				display: flex;
				flex-direction: column;
				transition: transform var(--transition-speed) ease, width var(--transition-speed) ease;
				position: relative;
				flex-shrink: 0;
			}

			/* When in character view, drawer floats above content */
			.editor-panel.floating-mode {
				position: fixed;
				top: 0;
				right: 0;
				bottom: 0;
				z-index: 100;
			}

			.editor-panel.collapsed {
				width: 48px;
			}

			.editor-panel.collapsed .editor-content {
				opacity: 0;
				pointer-events: none;
			}

			.editor-panel.hidden-in-character {
				width: 0;
				border: none;
				overflow: hidden;
			}

			.editor-toggle {
				position: absolute;
				left: -24px;
				top: 50%;
				transform: translateY(-50%);
				width: 24px;
				height: 48px;
				background: var(--bg-panel);
				border: 1px solid var(--border-color);
				border-right: none;
				border-radius: 4px 0 0 4px;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				color: var(--text-secondary);
				z-index: 10;
			}

			.editor-toggle:hover {
				background: var(--bg-card);
				color: var(--text-primary);
			}

			.editor-header {
				padding: 16px;
				border-bottom: 1px solid var(--border-color);
				display: flex;
				align-items: center;
				justify-content: space-between;
			}

			.editor-title {
				font-size: 1rem;
				font-weight: 600;
			}

			.editor-content {
				flex: 1;
				overflow-y: auto;
				transition: opacity var(--transition-speed) ease;
			}

			/* Editor Sections */
			.editor-section {
				padding: 16px;
				border-bottom: 1px solid var(--border-color);
			}

			.section-title {
				font-size: 0.875rem;
				font-weight: 600;
				color: var(--text-secondary);
				margin-bottom: 12px;
				text-transform: uppercase;
				letter-spacing: 0.05em;
			}

			/* === Buttons === */
			.btn {
				padding: 8px 16px;
				border: none;
				border-radius: var(--radius-md);
				font-size: 0.875rem;
				font-weight: 500;
				cursor: pointer;
				transition: background-color 0.2s, box-shadow 0.2s;
				display: inline-flex;
				align-items: center;
				gap: 6px;
			}

			.btn-primary {
				background: var(--primary-color);
				color: var(--text-primary);
			}

			.btn-primary:hover {
				background: var(--primary-hover);
			}

			.btn-secondary {
				background: var(--bg-secondary);
				color: var(--text-default);
				border: 1px solid var(--border-color);
			}

			.btn-secondary:hover {
				background: var(--bg-secondary-hover);
			}

			.btn-icon {
				padding: 8px;
				min-width: 36px;
				height: 36px;
				justify-content: center;
			}

			.btn-icon.active {
				background: var(--primary-color);
				color: var(--text-primary);
				box-shadow: 0 0 8px rgba(94, 129, 172, 0.5);
			}

			/* === Form Elements === */
			.form-group {
				margin-bottom: 12px;
			}

			.form-label {
				display: block;
				font-size: 0.875rem;
				color: var(--text-secondary);
				margin-bottom: 4px;
			}

			.form-input {
				width: 100%;
				padding: 8px 12px;
				background: var(--bg-input);
				border: 1px solid var(--border-color);
				border-radius: var(--radius-md);
				color: var(--text-primary);
				font-size: 0.875rem;
				transition: border-color 0.2s, box-shadow 0.2s;
			}

			.form-input:hover {
				border-color: var(--border-light);
			}

			.form-input:focus {
				outline: none;
				border-color: var(--primary-color);
				box-shadow: 0 0 0 3px rgba(94, 129, 172, 0.3);
			}

			/* === Prefix Tags === */
			.prefix-tags-container {
				display: flex;
				flex-direction: column;
				gap: 8px;
			}

			.prefix-tags {
				display: flex;
				flex-wrap: wrap;
				gap: 6px;
				min-height: 32px;
				padding: 8px;
				background: var(--bg-input);
				border: 1px solid var(--border-color);
				border-radius: var(--radius-md);
			}

			.prefix-tag {
				display: inline-flex;
				align-items: center;
				gap: 6px;
				padding: 4px 8px;
				background: var(--primary-color);
				color: white;
				border-radius: var(--radius-sm);
				font-size: 0.8rem;
				user-select: none;
			}

			.prefix-tag-remove {
				cursor: pointer;
				opacity: 0.7;
				font-size: 0.9rem;
				font-weight: bold;
				transition: opacity 0.2s;
			}

			.prefix-tag-remove:hover {
				opacity: 1;
			}

			.prefix-input-container {
				display: flex;
				gap: 8px;
				align-items: center;
			}

			.prefix-input {
				flex: 1;
			}

			.btn-sm {
				padding: 6px 12px;
				font-size: 0.8rem;
			}

			/* === Custom Select Dropdown === */
			.custom-select {
				position: relative;
				width: 100%;
			}

			.custom-select-trigger {
				width: 100%;
				padding: 8px 32px 8px 12px;
				background: var(--bg-input);
				border: 1px solid var(--border-color);
				border-radius: var(--radius-md);
				color: var(--text-primary);
				font-size: 0.875rem;
				cursor: pointer;
				text-align: left;
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
				transition: border-color 0.2s, box-shadow 0.2s;
			}

			.custom-select-trigger:hover {
				border-color: var(--border-light);
			}

			.custom-select-trigger:focus {
				outline: none;
				border-color: var(--primary-color);
				box-shadow: 0 0 0 3px rgba(94, 129, 172, 0.3);
			}

			.custom-select-trigger::after {
				content: "▼";
				position: absolute;
				right: 12px;
				top: 50%;
				transform: translateY(-50%);
				font-size: 0.6rem;
				color: var(--text-secondary);
				pointer-events: none;
			}

			.custom-select.open .custom-select-trigger::after {
				content: "▲";
			}

			.custom-select-trigger.placeholder {
				color: var(--text-secondary);
			}

			.custom-select-dropdown {
				position: absolute;
				top: 100%;
				left: 0;
				right: 0;
				margin-top: 4px;
				background: var(--bg-panel);
				border: 1px solid var(--border-color);
				border-radius: var(--radius-md);
				max-height: 200px;
				overflow-y: auto;
				z-index: 1000;
				display: none;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
			}

			.custom-select.open .custom-select-dropdown {
				display: block;
			}

			.custom-select-option {
				padding: 8px 12px;
				cursor: pointer;
				font-size: 0.85rem;
				color: var(--text-primary);
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
				transition: background 0.15s;
			}

			.custom-select-option:hover {
				background: var(--bg-secondary);
			}

			.custom-select-option.selected {
				background: var(--primary-color);
				color: #fff;
			}

			.custom-select-option.empty {
				color: var(--text-secondary);
				font-style: italic;
			}

			/* === Message List === */
			.message-list {
				list-style: none;
			}

			.message-item {
				padding: 12px 16px;
				border-bottom: 1px solid var(--border-color);
				cursor: pointer;
				transition: background 0.2s ease;
			}

			.message-item:hover {
				background: var(--bg-card);
			}

			.message-item.active {
				background: var(--bg-card);
				border-left: 3px solid var(--primary-color);
			}

			.message-name {
				font-size: 0.875rem;
				font-weight: 600;
				color: var(--primary-color);
				margin-bottom: 4px;
			}

			.message-preview {
				font-size: 0.8rem;
				color: var(--text-secondary);
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}

			.message-icon {
				width: 32px;
				height: 32px;
				border-radius: 4px;
				object-fit: cover;
				margin-right: 8px;
			}

			/* === Dice Result Styles === */
			.dice-result {
				padding: 4px 8px;
				border-radius: 4px;
				font-weight: 600;
				font-size: 0.875rem;
			}

			/* Dice styles for dialogue box */
			.dialogue-box.dice-critical {
				border-color: var(--critical-color);
				box-shadow: 0 0 20px rgba(208, 135, 112, 0.4);
			}

			.dialogue-box.dice-critical .dialogue-name {
				color: var(--critical-color);
			}

			.dialogue-box.dice-fumble {
				border-color: var(--fumble-color);
				box-shadow: 0 0 20px rgba(191, 97, 106, 0.4);
			}

			.dialogue-box.dice-fumble .dialogue-name {
				color: var(--fumble-color);
			}

			.dialogue-box.dice-success {
				border-color: var(--success-color);
				box-shadow: 0 0 15px rgba(163, 190, 140, 0.3);
			}

			.dialogue-box.dice-success .dialogue-name {
				color: var(--success-color);
			}

			.dialogue-box.dice-failure {
				border-color: var(--text-secondary);
				opacity: 0.9;
			}

			.dice-critical {
				background: var(--critical-color);
				color: #000;
			}

			.dice-fumble {
				background: var(--fumble-color);
				color: #fff;
			}

			.dice-success {
				background: var(--success-color);
				color: #000;
			}

			.dice-failure {
				background: var(--text-secondary);
				color: #000;
			}

			/* === Narration Style === */
			.narration-text {
				text-align: center;
				font-style: italic;
				padding: 40px 20px;
				font-size: 1.2rem;
				line-height: 2;
			}

			/* === System Message Style === */
			.system-message {
				background: var(--bg-card);
				border-left: 3px solid var(--warning-color);
				padding: 12px 16px;
				margin: 8px 0;
				font-size: 0.9rem;
			}

			/* === History Panel === */
			.history-panel {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(0, 0, 0, 0.95);
				overflow-y: auto;
				padding: 20px;
				display: none;
				z-index: 30;
			}

			.history-panel.visible {
				display: block;
			}

			.history-header {
				display: flex;
				align-items: center;
				justify-content: space-between;
				margin-bottom: 16px;
				padding-bottom: 12px;
				border-bottom: 1px solid var(--border-color);
			}

			.history-title {
				font-size: 1.1rem;
				font-weight: 600;
			}

			.history-close {
				background: none;
				border: none;
				color: var(--text-secondary);
				font-size: 1.5rem;
				cursor: pointer;
				padding: 4px 8px;
			}

			.history-close:hover {
				color: var(--text-primary);
			}

			.history-item {
				padding: 12px;
				border-bottom: 1px solid var(--border-color);
				cursor: pointer;
				display: flex;
				gap: 12px;
				transition: background 0.2s;
			}

			.history-item:hover {
				background: var(--bg-card);
			}

			.history-item.current {
				background: var(--bg-card);
				border-left: 3px solid var(--primary-color);
			}

			.history-item-icon {
				width: 40px;
				height: 40px;
				border-radius: 4px;
				object-fit: cover;
				flex-shrink: 0;
			}

			.history-item-content {
				flex: 1;
				min-width: 0;
			}

			.history-item-name {
				font-weight: 600;
				color: var(--primary-color);
				margin-bottom: 4px;
				font-size: 0.9rem;
			}

			.history-item-text {
				color: var(--text-secondary);
				font-size: 0.85rem;
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}

			.history-item-index {
				color: var(--text-secondary);
				font-size: 0.75rem;
				flex-shrink: 0;
			}

			/* === Character View === */
			.character-view {
				flex: 1;
				display: flex;
				flex-direction: column;
				padding: 60px 20px 20px;
				overflow: auto;
				min-width: 560px;
			}

			/* Character view header - single row layout */
			.character-view-header {
				position: relative;
				display: flex;
				justify-content: space-between;
				align-items: center;
				gap: 16px;
				padding: 12px;
				background: var(--bg-card);
				border-radius: 8px;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
				min-width: 560px;
				flex-wrap: wrap;
			}

			/* Left section: filter tabs */
			.header-section-left {
				display: flex;
				align-items: center;
				gap: 8px;
				flex: 1;
				min-width: 0;
			}

			.character-filter-tabs {
				display: flex;
				gap: 6px;
				overflow-x: auto;
				scrollbar-width: none;
				mask-image: linear-gradient(to right, black 90%, transparent 100%);
				flex: 1;
				min-width: 0;
			}
			.character-filter-tabs::-webkit-scrollbar {
				display: none;
			}

			.filter-tab {
				padding: 5px 12px;
				background: transparent;
				border: 1px solid transparent;
				border-radius: 100px;
				color: var(--text-secondary);
				cursor: pointer;
				font-size: 0.85rem;
				font-weight: 500;
				white-space: nowrap;
				transition: all 0.2s ease;
				flex-shrink: 0;
			}

			.filter-tab:hover {
				background: var(--bg-secondary);
				color: var(--text-primary);
			}

			.filter-tab.active {
				background: var(--primary-color);
				color: #fff;
				box-shadow: 0 2px 4px rgba(94, 129, 172, 0.3);
			}

			/* Custom category tab with delete button */
			.filter-tab.custom-category {
				position: relative;
				padding-right: 24px;
				display: inline-flex;
				align-items: center;
			}

			.filter-tab.custom-category .category-tab-delete {
				position: absolute;
				right: 4px;
				top: 50%;
				transform: translateY(-50%);
				width: 16px;
				height: 16px;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 0.9rem;
				opacity: 0;
				transition: opacity 0.2s;
				color: inherit;
			}

			.filter-tab.custom-category:hover .category-tab-delete {
				opacity: 0.7;
			}

			.filter-tab.custom-category .category-tab-delete:hover {
				opacity: 1;
			}

			/* Icon button style for more/add */
			.icon-btn {
				display: flex;
				align-items: center;
				justify-content: center;
				width: 28px;
				height: 28px;
				border: 1px solid var(--border-color);
				background: var(--bg-secondary);
				color: var(--text-secondary);
				border-radius: 50%;
				cursor: pointer;
				flex-shrink: 0;
				transition: all 0.2s;
			}

			.icon-btn:hover {
				border-color: var(--primary-color);
				color: var(--text-primary);
			}

			/* More dropdown for overflow categories */
			.filter-more-dropdown {
				position: relative;
				flex-shrink: 0;
			}

			.filter-more-btn {
				display: flex;
				align-items: center;
				justify-content: center;
				width: 28px;
				height: 28px;
				border: 1px solid var(--border-color);
				background: var(--bg-secondary);
				color: var(--text-secondary);
				border-radius: 50%;
				cursor: pointer;
				font-size: 0.7rem;
				transition: all 0.2s;
			}

			.filter-more-btn:hover {
				border-color: var(--primary-color);
				color: var(--text-primary);
			}

			.filter-more-btn.has-active {
				background: var(--primary-color);
				color: var(--text-primary);
				border-color: var(--primary-color);
			}

			.filter-more-menu {
				position: absolute;
				top: 100%;
				left: 0;
				margin-top: 4px;
				background: var(--bg-panel);
				border: 1px solid var(--border-color);
				border-radius: 6px;
				min-width: 150px;
				max-height: 300px;
				overflow-y: auto;
				z-index: 100;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
				display: none;
			}

			.filter-more-menu.visible {
				display: block;
			}

			.filter-more-item {
				padding: 8px 12px;
				cursor: pointer;
				font-size: 0.85rem;
				color: var(--text-secondary);
				display: flex;
				align-items: center;
				gap: 8px;
				transition: background 0.2s;
			}

			.filter-more-item:hover {
				background: var(--bg-secondary);
				color: var(--text-primary);
			}

			.filter-more-item.active {
				background: var(--primary-color);
				color: var(--text-primary);
			}

			.filter-more-item .category-dot {
				width: 8px;
				height: 8px;
				border-radius: 50%;
				flex-shrink: 0;
			}

			.filter-more-item .category-delete {
				margin-left: auto;
				opacity: 0;
				color: var(--error-color);
				font-size: 1rem;
				padding: 0 4px;
			}

			.filter-more-item:hover .category-delete {
				opacity: 1;
			}

			/* Add category button */
			.filter-add-btn {
				display: flex;
				align-items: center;
				justify-content: center;
				width: 28px;
				height: 28px;
				border: 1px dashed var(--border-color);
				background: transparent;
				color: var(--text-secondary);
				border-radius: 50%;
				cursor: pointer;
				font-size: 1rem;
				transition: all 0.2s;
				flex-shrink: 0;
			}

			.filter-add-btn:hover {
				border-color: var(--primary-color);
				color: var(--primary-color);
			}

			/* Right section: search + actions */
			.header-section-right {
				display: flex;
				align-items: center;
				gap: 12px;
				flex-shrink: 0;
			}

			.search-wrapper {
				position: relative;
				display: flex;
				align-items: center;
			}

			.search-icon {
				position: absolute;
				left: 10px;
				color: var(--text-secondary);
				pointer-events: none;
			}

			.header-section-right .search-input {
				padding: 6px 12px 6px 32px;
				background: var(--bg-secondary);
				border: 1px solid transparent;
				border-radius: 6px;
				color: var(--text-primary);
				width: 160px;
				font-size: 0.85rem;
				transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
			}

			.header-section-right .search-input:focus {
				width: 240px;
				background: var(--bg-dark);
				border-color: var(--primary-color);
				outline: none;
				box-shadow: 0 0 0 2px rgba(94, 129, 172, 0.2);
			}

			.character-view-actions {
				display: flex;
				gap: 6px;
				border-left: 1px solid var(--border-color);
				padding-left: 12px;
				flex-shrink: 0;
			}

			.character-view-actions .btn-icon {
				padding: 6px 10px;
				background: transparent;
				border: 1px solid var(--border-color);
				border-radius: 6px;
				color: var(--text-secondary);
				cursor: pointer;
				transition: all 0.2s;
				font-size: 0.9rem;
			}

			.character-view-actions .btn-icon:hover {
				background: var(--bg-secondary);
				color: var(--text-primary);
				border-color: var(--text-secondary);
			}

			.character-view-actions .btn {
				white-space: nowrap;
				flex-shrink: 0;
			}

			.character-grid {
				flex: 1;
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
				gap: 16px;
				overflow-y: auto;
				align-content: start;
				padding-top: 16px;
			}

			.character-empty-state {
				grid-column: 1 / -1;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 200px;
				color: var(--text-secondary);
			}

			/* Character Card */
			.character-card {
				background: var(--bg-card);
				border: 1px solid var(--border-color);
				border-radius: 8px;
				cursor: pointer;
				transition: all 0.2s;
				display: flex;
				flex-direction: column;
			}

			.character-card:hover {
				border-color: var(--primary-color);
				transform: translateY(-2px);
			}

			.card-header {
				display: flex;
				align-items: center;
				gap: 12px;
				padding: 12px;
			}

			.card-avatar {
				width: 64px;
				height: 64px;
				border-radius: 6px;
				object-fit: contain;
				background: var(--bg-secondary);
				flex-shrink: 0;
			}

			.card-avatar-fallback {
				width: 64px;
				height: 64px;
				border-radius: 6px;
				background: var(--primary-color);
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 1.5rem;
				font-weight: 600;
				color: var(--text-primary);
				flex-shrink: 0;
			}

			.card-info {
				flex: 1;
				min-width: 0;
			}

			.card-name {
				font-weight: 600;
				font-size: 0.95rem;
				display: flex;
				align-items: center;
				gap: 8px;
			}

			.card-meta {
				font-size: 0.75rem;
				color: var(--text-secondary);
				margin-top: 2px;
			}

			.card-type-row {
				display: flex;
				gap: 4px;
				align-items: center;
				flex-wrap: wrap;
			}

			.card-type {
				font-size: 0.65rem;
				padding: 2px 6px;
				border-radius: 3px;
				font-weight: 600;
			}

			.card-type.kp {
				background: var(--critical-color);
				color: #000;
			}

			.card-type.npc {
				background: #b48ead;
				color: #000;
			}

			.card-type.pc {
				background: #88c0d0;
				color: #000;
			}

			.card-type.dice {
				background: #d08770;
				color: #000;
			}

			.card-category {
				font-size: 0.65rem;
				padding: 2px 6px;
				border-radius: 3px;
				font-weight: 500;
				background: var(--cat-color, #64b5f6);
				color: #000;
			}

			/* Batch Selection Styles - 覆盖模式 */
			.batch-toolbar {
				position: absolute;
				inset: 0;
				background: #2e3440;
				border-radius: 8px;
				display: none;
				align-items: center;
				justify-content: space-between;
				padding: 0 16px;
				z-index: 10;
				animation: batchFadeIn 0.2s ease;
			}

			@keyframes batchFadeIn {
				from {
					opacity: 0;
					transform: translateY(-5px);
				}
				to {
					opacity: 1;
					transform: translateY(0);
				}
			}

			.batch-toolbar.visible {
				display: flex;
			}

			.batch-count {
				font-size: 0.9rem;
				color: var(--text-primary);
				font-weight: bold;
			}

			.batch-actions {
				display: flex;
				gap: 8px;
			}

			.batch-actions .btn-sm {
				padding: 6px 12px;
				font-size: 0.8rem;
				background: var(--bg-secondary);
				border: 1px solid var(--border-color);
				border-radius: 4px;
				color: var(--text-secondary);
				cursor: pointer;
				transition: all 0.2s;
			}

			.batch-actions .btn-sm:hover {
				color: var(--text-primary);
			}

			.batch-delete-btn {
				border-color: var(--error-color) !important;
				color: var(--error-color) !important;
			}

			.batch-delete-btn:hover {
				background: var(--error-color) !important;
				color: white !important;
			}

			.batch-close-btn {
				margin-left: 8px;
				background: transparent !important;
				border: none !important;
				color: var(--text-secondary) !important;
				font-size: 1rem;
				padding: 6px 8px !important;
			}

			.batch-close-btn:hover {
				color: var(--text-primary) !important;
			}

			/* Character card in batch mode */
			.character-card.batch-mode {
				position: relative;
			}

			.character-card.selected {
				border-color: var(--primary-color);
				background: rgba(94, 129, 172, 0.1);
			}

			.batch-checkbox {
				position: absolute;
				top: 8px;
				right: 8px;
				width: 24px;
				height: 24px;
				background: rgba(0, 0, 0, 0.6);
				border: 2px solid rgba(255, 255, 255, 0.3);
				border-radius: 4px;
				display: flex;
				align-items: center;
				justify-content: center;
				cursor: pointer;
				transition: all 0.2s;
				z-index: 5;
			}

			.batch-checkbox:hover {
				border-color: var(--primary-color);
				background: rgba(0, 0, 0, 0.8);
			}

			.batch-checkbox.checked {
				background: var(--primary-color);
				border-color: var(--primary-color);
			}

			.batch-checkbox .checkbox-icon {
				color: white;
				font-size: 0.9rem;
				font-weight: bold;
			}

			/* Batch category list in modal */
			.batch-category-list {
				display: flex;
				flex-direction: column;
				gap: 4px;
				max-height: 300px;
				overflow-y: auto;
			}

			.batch-category-item {
				display: flex;
				align-items: center;
				gap: 8px;
				padding: 10px 12px;
				background: var(--bg-card);
				border: 1px solid var(--border-color);
				border-radius: 6px;
				cursor: pointer;
				transition: all 0.2s;
			}

			.batch-category-item:hover {
				border-color: var(--primary-color);
				background: var(--bg-secondary);
			}

			.batch-category-item .category-dot {
				width: 12px;
				height: 12px;
				border-radius: 50%;
				flex-shrink: 0;
			}

			.batch-category-item .category-count {
				margin-left: auto;
				font-size: 0.8rem;
				color: var(--text-secondary);
			}

			.batch-category-divider {
				font-size: 0.75rem;
				color: var(--text-secondary);
				padding: 8px 0 4px;
				margin-top: 8px;
				border-top: 1px solid var(--border-color);
			}

			/* Batch select button active state */
			#btn-batch-select.active {
				background: var(--primary-color);
				border-color: var(--primary-color);
				color: white;
			}

			.card-badges {
				display: flex;
				gap: 4px;
			}

			.card-badge {
				background: var(--bg-secondary);
				padding: 3px 5px;
				border-radius: 4px;
				font-size: 0.75rem;
			}

			.card-body {
				padding: 0 12px 12px;
			}

			.card-portraits {
				display: flex;
				gap: 4px;
				margin-bottom: 8px;
			}

			.card-portraits img {
				width: 36px;
				height: 48px;
				object-fit: cover;
				border-radius: 4px;
				background: var(--bg-secondary);
			}

			.card-portraits .portrait-more {
				width: 36px;
				height: 48px;
				background: var(--bg-secondary);
				border-radius: 4px;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 0.75rem;
				color: var(--text-secondary);
			}

			.card-stats {
				display: flex;
				gap: 12px;
				font-size: 0.75rem;
				color: var(--text-secondary);
			}

			/* Card Expanded Content */
			.card-expand {
				display: none;
				padding: 12px;
				border-top: 1px solid var(--border-color);
				background: var(--bg-panel);
			}

			.character-card.expanded .card-expand {
				display: block;
			}

			.expand-tabs {
				display: flex;
				gap: 4px;
				margin-bottom: 12px;
				border-bottom: 1px solid var(--border-color);
				padding-bottom: 8px;
			}

			.expand-tab {
				padding: 6px 12px;
				background: transparent;
				border: none;
				color: var(--text-secondary);
				cursor: pointer;
				font-size: 0.8rem;
				border-bottom: 2px solid transparent;
			}

			.expand-tab:hover {
				color: var(--text-primary);
			}

			.expand-tab.active {
				color: var(--primary-color);
				border-bottom-color: var(--primary-color);
			}

			.expand-panel {
				display: none;
			}

			.expand-panel.active {
				display: block;
			}

			/* === Portrait Panel Styles === */
			.portrait-panel-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 12px;
			}

			.portrait-count {
				font-size: 0.85rem;
				color: var(--text-secondary);
			}

			.btn-sm {
				padding: 4px 10px;
				font-size: 0.75rem;
			}

			.portrait-list {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
				gap: 12px;
			}

			.portrait-item {
				display: flex;
				gap: 10px;
				background: var(--bg-card);
				border: 1px solid var(--border-color);
				border-radius: 6px;
				transition: all 0.2s;
			}

			.portrait-item:hover {
				border-color: var(--primary-color);
			}

			.portrait-item img {
				width: 60px;
				height: 80px;
				object-fit: cover;
				border-radius: 4px;
				background: var(--bg-secondary);
				flex-shrink: 0;
			}

			.portrait-info {
				flex: 1;
				display: flex;
				flex-direction: column;
				gap: 4px;
				min-width: 0;
			}

			.portrait-name-input {
				padding: 4px 8px;
				background: var(--bg-input);
				border: 1px solid var(--border-color);
				border-radius: 4px;
				color: var(--text-primary);
				font-size: 0.8rem;
				width: 100%;
			}

			.portrait-name-input:focus {
				outline: none;
				border-color: var(--primary-color);
			}

			.portrait-usage {
				font-size: 0.7rem;
				color: var(--text-secondary);
			}

			.portrait-actions {
				display: flex;
				flex-direction: column;
				gap: 4px;
			}

			.btn-icon-sm {
				padding: 4px 6px;
				background: var(--bg-secondary);
				border: 1px solid var(--border-color);
				border-radius: 4px;
				cursor: pointer;
				font-size: 0.75rem;
				transition: all 0.2s;
			}

			.btn-icon-sm:hover {
				background: var(--bg-secondary-hover);
				border-color: var(--primary-color);
			}

			.portrait-empty {
				padding: 20px;
				text-align: center;
				color: var(--text-secondary);
			}

			/* Portrait Preview Modal - 大图预览 */
			.portrait-preview-modal {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(0, 0, 0, 0.9);
				display: flex;
				align-items: center;
				justify-content: center;
				z-index: 2000;
			}

			.portrait-preview-content {
				position: relative;
				display: flex;
				flex-direction: column;
				align-items: center;
				max-width: 90%;
				max-height: 90%;
			}

			.portrait-preview-modal img {
				max-width: 100%;
				max-height: calc(90vh - 60px);
				object-fit: contain;
				border-radius: 8px;
			}

			.portrait-preview-name {
				margin-top: 12px;
				font-size: 1rem;
				color: #fff;
				text-align: center;
			}

			.portrait-preview-close {
				position: absolute;
				top: -40px;
				right: -40px;
				width: 36px;
				height: 36px;
				background: rgba(255, 255, 255, 0.1);
				border: none;
				border-radius: 50%;
				color: #fff;
				font-size: 1.5rem;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				transition: background 0.2s;
			}

			.portrait-preview-close:hover {
				background: rgba(255, 255, 255, 0.2);
			}

			.portrait-preview-nav {
				position: absolute;
				top: 50%;
				transform: translateY(-50%);
				width: 48px;
				height: 48px;
				background: rgba(255, 255, 255, 0.1);
				border: none;
				border-radius: 50%;
				color: #fff;
				font-size: 1.5rem;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				transition: background 0.2s;
			}

			.portrait-preview-nav:hover:not(:disabled) {
				background: rgba(255, 255, 255, 0.2);
			}

			.portrait-preview-nav:disabled {
				opacity: 0.3;
				cursor: not-allowed;
			}

			.portrait-preview-prev {
				left: -70px;
			}

			.portrait-preview-next {
				right: -70px;
			}

			.portrait-preview-overlay {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				z-index: -1;
			}

			/* Portrait Selector - 带预览的差分选择器 */
			.portrait-selector {
				position: relative;
			}

			.portrait-selector-trigger {
				display: flex;
				align-items: center;
				gap: 10px;
				padding: 8px 12px;
				background: var(--bg-input);
				border: 1px solid var(--border-color);
				border-radius: 6px;
				cursor: pointer;
				transition: border-color 0.2s;
			}

			.portrait-selector-trigger:hover {
				border-color: var(--border-light);
			}

			.portrait-selector-trigger.open {
				border-color: var(--primary-color);
			}

			.portrait-selector-preview {
				width: 32px;
				height: 40px;
				object-fit: cover;
				border-radius: 4px;
				background: var(--bg-secondary);
			}

			.portrait-selector-preview.no-portrait {
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 0.7rem;
				color: var(--text-secondary);
			}

			.portrait-selector-text {
				flex: 1;
				font-size: 0.9rem;
				color: var(--text-primary);
			}

			.portrait-selector-arrow {
				color: var(--text-secondary);
				transition: transform 0.2s;
			}

			.portrait-selector-trigger.open .portrait-selector-arrow {
				transform: rotate(180deg);
			}

			.portrait-selector-dropdown {
				position: absolute;
				top: 100%;
				left: 0;
				right: 0;
				margin-top: 4px;
				background: var(--bg-card);
				border: 1px solid var(--border-color);
				border-radius: 6px;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
				max-height: 240px;
				overflow-y: auto;
				z-index: 100;
				display: none;
			}

			.portrait-selector-dropdown.open {
				display: block;
			}

			.portrait-selector-option {
				display: flex;
				align-items: center;
				gap: 10px;
				padding: 8px 12px;
				cursor: pointer;
				transition: background 0.15s;
			}

			.portrait-selector-option:hover {
				background: var(--bg-secondary);
			}

			.portrait-selector-option.selected {
				background: rgba(136, 192, 208, 0.15);
			}

			.portrait-selector-option img {
				width: 32px;
				height: 40px;
				object-fit: cover;
				border-radius: 4px;
				background: var(--bg-secondary);
			}

			.portrait-selector-option .option-name {
				flex: 1;
				font-size: 0.85rem;
			}

			.portrait-selector-option .option-check {
				color: var(--primary-color);
				opacity: 0;
			}

			.portrait-selector-option.selected .option-check {
				opacity: 1;
			}

			/* === Layout B Card Styles === */
			.character-card .card-title {
				flex: 1;
			}

			.character-card .card-title h3 {
				margin: 0 0 4px 0;
				font-size: 1rem;
				font-weight: 600;
			}

			.character-card .card-stats {
				display: flex;
				gap: 24px;
				padding: 12px;
				border-top: 1px solid var(--border-color);
			}

			.character-card .stat {
				text-align: center;
			}

			.character-card .stat-num {
				display: block;
				font-size: 1.25rem;
				font-weight: 600;
			}

			.character-card .stat-label {
				font-size: 0.75rem;
				color: var(--text-secondary);
			}

			.character-card .card-expand,
			.character-card .card-content {
				padding: 12px;
				border-top: 1px solid var(--border-color);
				flex: 1;
				display: flex;
				flex-direction: column;
			}

			.character-card .expand-section {
				margin-bottom: 12px;
			}

			.character-card .expand-title {
				font-size: 0.8rem;
				color: var(--text-secondary);
				margin-bottom: 8px;
			}

			.character-card .mini-portraits {
				display: flex;
				gap: 8px;
				min-height: 64px;
			}

			.character-card .mini-portraits img {
				width: 48px;
				height: 64px;
				object-fit: contain;
				border-radius: 4px;
				background: var(--bg-secondary);
			}

			.character-card .mini-portraits .portrait-placeholder {
				width: 48px;
				height: 64px;
				border-radius: 4px;
				background: var(--bg-secondary);
				border: 1px dashed var(--border-color);
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.character-card .mini-portraits .portrait-placeholder span {
				font-size: 0.7rem;
				color: var(--text-secondary);
				writing-mode: vertical-rl;
			}

			.character-card .mini-portraits .no-portraits {
				font-size: 0.8rem;
				color: var(--text-secondary);
			}

			.character-card .voice-preview {
				font-size: 0.9rem;
				color: var(--text-primary);
				min-height: 1.4em;
			}

			.character-card .btn-edit {
				width: 100%;
				padding: 10px;
				background: var(--primary-color);
				border: none;
				border-radius: 6px;
				color: var(--text-primary);
				cursor: pointer;
				font-size: 0.9rem;
				margin-top: auto;
				transition: background 0.2s;
			}

			.character-card .btn-edit:hover {
				background: var(--primary-hover);
			}

			.character-card .badge {
				background: var(--bg-secondary);
				padding: 4px 6px;
				border-radius: 4px;
				font-size: 0.8rem;
			}

			/* === Character Detail Page === */
			.character-detail-page {
				position: absolute;
				top: 60px;
				left: 0;
				right: 0;
				bottom: 0;
				background: var(--bg-panel);
				overflow-y: auto;
				z-index: 10;
			}

			.character-detail-page.hidden {
				display: none;
			}

			.detail-header {
				display: flex;
				align-items: center;
				gap: 16px;
				padding: 20px;
				border-bottom: 1px solid var(--border-color);
			}

			.detail-avatar {
				width: 80px;
				height: 80px;
				border-radius: 8px;
				object-fit: cover;
				background: var(--bg-secondary);
			}

			.detail-avatar-container {
				position: relative;
				cursor: pointer;
				transition: all 0.2s ease;
			}

			.detail-avatar-container:hover {
				transform: scale(1.05);
			}

			.detail-avatar-overlay {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(0, 0, 0, 0.5);
				display: flex;
				align-items: center;
				justify-content: center;
				border-radius: 8px;
				opacity: 0;
				transition: opacity 0.2s ease;
				font-size: 1.5rem;
			}

			.detail-avatar-container:hover .detail-avatar-overlay {
				opacity: 1;
			}

			/* Avatar Selector Modal */
			.avatar-selector-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
				gap: 12px;
				max-height: 400px;
				overflow-y: auto;
			}

			.avatar-option {
				position: relative;
				aspect-ratio: 3/4;
				border: 2px solid var(--border-color);
				border-radius: var(--radius-md);
				overflow: hidden;
				cursor: pointer;
				transition: all 0.2s ease;
			}

			.avatar-option:hover {
				border-color: var(--primary-color);
				transform: scale(1.05);
			}

			.avatar-option.current {
				border-color: var(--primary-color);
				box-shadow: 0 0 0 2px rgba(94, 129, 172, 0.3);
			}

			.avatar-option img {
				width: 100%;
				height: 100%;
				object-fit: cover;
			}

			.avatar-option-overlay {
				position: absolute;
				bottom: 0;
				left: 0;
				right: 0;
				background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
				color: white;
				padding: 8px;
				font-size: 0.75rem;
				text-align: center;
			}

			.avatar-option.current .avatar-option-overlay {
				background: linear-gradient(transparent, var(--primary-color));
			}

			/* Quick Portrait Edit Modal */
			.quick-portrait-info {
				margin-bottom: 16px;
				padding: 12px;
				background: var(--bg-card);
				border-radius: var(--radius-md);
				border-left: 3px solid var(--primary-color);
			}

			.quick-portrait-current-message {
				display: flex;
				flex-direction: column;
				gap: 4px;
			}

			.quick-portrait-current-message strong {
				color: var(--primary-color);
				font-size: 1rem;
			}

			.quick-portrait-current-message span {
				color: var(--text-secondary);
				font-size: 0.9rem;
				line-height: 1.4;
				max-height: 3em;
				overflow: hidden;
				text-overflow: ellipsis;
				display: -webkit-box;
				-webkit-line-clamp: 2;
				line-clamp: 2; /* 标准属性 */
				-webkit-box-orient: vertical;
			}

			.quick-portrait-selector-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
				gap: 12px;
				max-height: 400px;
				overflow-y: auto;
				padding: 10px;
			}

			.quick-portrait-option {
				position: relative;
				aspect-ratio: 3/4;
				border: 2px solid var(--border-color);
				border-radius: var(--radius-md);
				overflow: hidden;
				cursor: pointer;
				transition: all 0.2s ease;
			}

			.quick-portrait-option:hover {
				border-color: var(--primary-color);
				transform: scale(1.05);
			}

			.quick-portrait-option.current {
				border-color: var(--primary-color);
				box-shadow: 0 0 0 2px rgba(94, 129, 172, 0.3);
			}

			.quick-portrait-option img {
				width: 100%;
				height: 100%;
				object-fit: cover;
			}

			.quick-portrait-option-overlay {
				position: absolute;
				bottom: 0;
				left: 0;
				right: 0;
				background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
				color: white;
				padding: 8px;
				font-size: 0.75rem;
				text-align: center;
			}

			.quick-portrait-option.current .quick-portrait-option-overlay {
				background: linear-gradient(transparent, var(--primary-color));
			}

			/* Message item icon clickable */
			.message-item-icon {
				cursor: pointer;
				transition: transform 0.2s ease;
			}

			.message-item-icon:hover {
				transform: scale(1.1);
			}

			/* Portrait image right-click context */
			.portrait-image {
				cursor: context-menu;
			}

			.detail-title {
				flex: 1;
			}

			.detail-title h2 {
				margin: 0 0 8px 0;
				font-size: 1.25rem;
			}

			.type-select {
				padding: 6px 10px;
				background: var(--bg-input);
				border: 1px solid var(--border-color);
				border-radius: 4px;
				color: var(--text-primary);
				font-size: 0.85rem;
			}

			.detail-stats {
				color: var(--text-secondary);
				font-size: 0.9rem;
			}

			.detail-tabs {
				display: flex;
				border-bottom: 1px solid var(--border-color);
			}

			.detail-tab {
				padding: 12px 20px;
				background: transparent;
				border: none;
				color: var(--text-secondary);
				cursor: pointer;
				border-bottom: 2px solid transparent;
				font-size: 0.9rem;
				transition: all 0.2s;
			}

			.detail-tab:hover {
				color: var(--text-primary);
			}

			.detail-tab.active {
				color: var(--primary-color);
				border-bottom-color: var(--primary-color);
			}

			.detail-content {
				padding: 20px;
			}

			.detail-panel {
				display: none;
			}

			.detail-panel.active {
				display: block;
			}

			.section-title {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 16px;
				font-weight: 600;
			}

			.btn-small {
				padding: 4px 12px;
				background: var(--bg-secondary);
				border: 1px solid var(--border-color);
				border-radius: 4px;
				color: var(--text-secondary);
				font-size: 0.8rem;
				cursor: pointer;
				transition: all 0.2s;
			}

			.btn-small:hover {
				background: var(--bg-secondary-hover);
				color: var(--text-primary);
			}

			.portrait-grid {
				display: flex;
				flex-wrap: wrap;
				gap: 16px;
			}

			.portrait-grid .portrait-item {
				width: 180px;
				height: 180px;
				background: var(--bg-card);
				border-radius: 8px;
				cursor: pointer;
				border: none;
				transition: all 0.2s;
				position: relative;
				overflow: hidden;
				flex-shrink: 0;
			}

			.portrait-grid .portrait-item:hover {
				box-shadow: 0 0 0 2px var(--border-light);
			}

			.portrait-grid .portrait-item.active {
				box-shadow: 0 0 0 2px var(--primary-color);
			}

			.portrait-grid .portrait-item img {
				width: 100%;
				height: 100%;
				object-fit: contain;
				display: block;
				background: var(--bg-secondary);
			}

			/* 左上角替换按钮 - 悬浮 */
			.portrait-grid .portrait-replace-btn {
				position: absolute;
				top: 6px;
				left: 6px;
				padding: 4px 8px;
				font-size: 0.7rem;
				background: rgba(0, 0, 0, 0.7);
				color: #fff;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				opacity: 0;
				transform: translateY(-5px);
				transition: all 0.2s ease;
				z-index: 2;
			}

			.portrait-grid .portrait-item:hover .portrait-replace-btn {
				opacity: 1;
				transform: translateY(0);
			}

			.portrait-grid .portrait-replace-btn:hover {
				background: var(--primary-color);
			}

			/* 头像设置按钮 - 悬浮在左下角 */
			.portrait-grid .portrait-avatar-btn {
				position: absolute;
				bottom: 6px;
				left: 6px;
				width: 28px;
				height: 28px;
				background: rgba(0, 0, 0, 0.7);
				color: white;
				border: none;
				border-radius: 50%;
				font-size: 0.8rem;
				opacity: 0;
				transform: translateY(4px);
				transition: all 0.2s ease;
				cursor: pointer;
				z-index: 2;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			.portrait-grid .portrait-avatar-btn.active {
				background: var(--primary-color);
				opacity: 1;
				transform: translateY(0);
			}

			.portrait-grid .portrait-avatar-btn:hover {
				background: var(--primary-color);
			}

			.portrait-grid .portrait-item:hover .portrait-avatar-btn {
				opacity: 1;
				transform: translateY(0);
			}

			/* 右上角使用次数角标 - 悬浮 */
			.portrait-grid .portrait-usage-badge {
				position: absolute;
				top: 6px;
				right: 6px;
				padding: 2px 8px;
				font-size: 0.7rem;
				background: rgba(0, 0, 0, 0.7);
				color: #fff;
				border-radius: 10px;
				z-index: 2;
			}

			/* 底部差分名 - 悬浮半透明条 */
			.portrait-grid .portrait-name-overlay {
				position: absolute;
				bottom: 0;
				left: 0;
				right: 0;
				background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
				padding: 20px 8px 8px 8px;
				z-index: 2;
			}

			.portrait-grid .portrait-name-edit {
				width: 100%;
				padding: 4px 8px;
				background: rgba(255, 255, 255, 0.1);
				border: 1px solid rgba(255, 255, 255, 0.2);
				border-radius: 4px;
				color: #fff;
				font-size: 0.8rem;
				text-align: center;
			}

			.portrait-grid .portrait-name-edit:focus {
				outline: none;
				border-color: var(--primary-color);
				background: rgba(255, 255, 255, 0.15);
			}

			.portrait-grid .portrait-name-edit::placeholder {
				color: rgba(255, 255, 255, 0.5);
			}

			/* 隐藏旧的样式 */
			.portrait-grid .portrait-count {
				display: none;
			}

			.portrait-grid .portrait-item-actions {
				display: none;
			}

			.portrait-grid .portrait-item.add-new {
				width: 180px;
				height: 180px;
				border: 2px dashed var(--border-color);
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				flex-shrink: 0;
			}

			.portrait-grid .portrait-item.add-new:hover {
				border-color: var(--primary-color);
			}

			.portrait-grid .add-icon {
				font-size: 2rem;
				color: var(--text-secondary);
				margin-bottom: 8px;
			}

			.portrait-grid .portrait-name {
				font-size: 0.85rem;
				color: var(--text-secondary);
			}

			.placeholder-content {
				padding: 40px;
				text-align: center;
				color: var(--text-secondary);
			}

			/* Voice Settings Panel */
			.voice-settings-panel {
				padding: 16px;
			}

			.voice-settings-panel .form-group {
				margin-bottom: 16px;
			}

			.voice-settings-panel .form-label {
				display: flex;
				align-items: center;
				gap: 8px;
				margin-bottom: 6px;
				font-size: 0.875rem;
				color: var(--text-secondary);
			}

			.voice-settings-panel .form-label input[type="checkbox"] {
				width: 16px;
				height: 16px;
				accent-color: var(--primary-color);
			}

			.voice-settings-panel .form-input,
			.voice-settings-panel select {
				width: 100%;
				padding: 8px 12px;
				background: var(--bg-input);
				border: 1px solid var(--border-color);
				border-radius: var(--radius-md);
				color: var(--text-primary);
				font-size: 0.875rem;
			}

			.voice-settings-panel .form-input:focus,
			.voice-settings-panel select:focus {
				outline: none;
				border-color: var(--primary-color);
			}

			.voice-settings-panel .form-range {
				width: 100%;
				height: 6px;
				background: var(--border-color);
				border-radius: 3px;
				outline: none;
				-webkit-appearance: none;
				appearance: none;
			}

			.voice-settings-panel .form-range::-webkit-slider-thumb {
				-webkit-appearance: none;
				appearance: none;
				width: 16px;
				height: 16px;
				background: var(--primary-color);
				border-radius: 50%;
				cursor: pointer;
			}

			.voice-settings-panel .form-range::-moz-range-thumb {
				width: 16px;
				height: 16px;
				background: var(--primary-color);
				border-radius: 50%;
				cursor: pointer;
				border: none;
			}

			.voice-actions {
				display: flex;
				gap: 8px;
				margin-top: 20px;
			}

			.voice-actions .btn {
				flex: 1;
			}

			/* Character Detail Button in View Switcher */
			.char-detail-btn {
				background: var(--bg-card) !important;
				border: 1px solid var(--border-color) !important;
				color: var(--text-secondary) !important;
				display: flex;
				align-items: center;
				gap: 6px;
			}

			.char-detail-btn.active {
				background: var(--bg-secondary) !important;
				border: 1px solid var(--primary-color) !important;
				color: var(--primary-color) !important;
			}

			.char-detail-btn .close-detail {
				font-size: 1rem;
				opacity: 0.7;
				cursor: pointer;
				padding: 0 2px;
			}

			.char-detail-btn .close-detail:hover {
				opacity: 1;
			}

			/* === Loading & Error States === */
			.loading-overlay {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(0, 0, 0, 0.8);
				display: flex;
				align-items: center;
				justify-content: center;
				z-index: 100;
			}

			.loading-spinner {
				width: 48px;
				height: 48px;
				border: 3px solid var(--border-color);
				border-top-color: var(--primary-color);
				border-radius: 50%;
				animation: spin 1s linear infinite;
			}

			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}

			.error-message {
				background: var(--error-color);
				color: white;
				padding: 12px 16px;
				border-radius: 6px;
				margin: 8px 0;
			}

			/* === Utility Classes === */
			.hidden {
				display: none !important;
			}

			.flex {
				display: flex;
			}

			.items-center {
				align-items: center;
			}

			.gap-2 {
				gap: 8px;
			}

			.gap-4 {
				gap: 16px;
			}

			/* === Modal === */
			.modal-overlay {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(0, 0, 0, 0.7);
				display: flex;
				align-items: center;
				justify-content: center;
				z-index: 1000;
				opacity: 0;
				visibility: hidden;
				transition: opacity 0.2s, visibility 0.2s;
			}

			.modal-overlay.visible {
				opacity: 1;
				visibility: visible;
			}

			.modal {
				background: var(--bg-panel);
				border: 1px solid var(--border-color);
				border-radius: var(--radius-md);
				width: 90%;
				max-width: 500px;
				max-height: 90vh;
				overflow-y: auto;
				transform: scale(0.9);
				transition: transform 0.2s;
			}

			.modal-overlay.visible .modal {
				transform: scale(1);
			}

			.modal-header {
				padding: 16px;
				border-bottom: 1px solid var(--border-color);
				display: flex;
				align-items: center;
				justify-content: space-between;
			}

			.modal-title {
				font-size: 1.1rem;
				font-weight: 600;
			}

			.modal-close {
				background: none;
				border: none;
				color: var(--text-secondary);
				font-size: 1.5rem;
				cursor: pointer;
				padding: 4px;
				line-height: 1;
			}

			.modal-close:hover {
				color: var(--text-primary);
			}

			.modal-body {
				padding: 16px;
			}

			.modal-footer {
				padding: 16px;
				border-top: 1px solid var(--border-color);
				display: flex;
				justify-content: flex-end;
				gap: 8px;
			}

			.form-textarea {
				width: 100%;
				padding: 8px 12px;
				background: var(--bg-input);
				border: 1px solid var(--border-color);
				border-radius: var(--radius-md);
				color: var(--text-primary);
				font-size: 0.875rem;
				font-family: inherit;
				resize: vertical;
				min-height: 100px;
				transition: border-color 0.2s, box-shadow 0.2s;
			}

			.form-textarea:focus {
				outline: none;
				border-color: var(--primary-color);
				box-shadow: 0 0 0 3px rgba(94, 129, 172, 0.3);
			}

			/* Insert position indicator */
			.insert-indicator {
				padding: 8px 16px;
				background: var(--primary-color);
				color: white;
				text-align: center;
				font-size: 0.8rem;
				cursor: pointer;
				opacity: 0;
				height: 0;
				overflow: hidden;
				transition: all 0.2s;
			}

			.message-item:hover + .insert-indicator,
			.insert-indicator:hover {
				opacity: 1;
				height: auto;
				padding: 8px 16px;
			}

			.message-list-full .insert-indicator:first-child {
				opacity: 1;
				height: auto;
				padding: 8px 16px;
				background: var(--bg-secondary);
			}

			.message-list-full .insert-indicator:first-child:hover {
				background: var(--primary-color);
			}

			/* === Responsive === */
			@media (max-width: 768px) {
				.editor-panel {
					position: fixed;
					right: 0;
					top: 0;
					bottom: 0;
					z-index: 50;
					width: 85%;
					max-width: 400px;
					transform: translateX(100%);
				}

				/* Override floating-mode on mobile */
				.editor-panel.floating-mode {
					position: fixed;
					z-index: 50;
					transform: translateX(100%);
				}

				.editor-panel.open,
				.editor-panel.floating-mode.open {
					transform: translateX(0);
				}

				.editor-panel.collapsed,
				.editor-panel.floating-mode.collapsed {
					transform: translateX(100%);
				}

				/* 移动端按钮位置调整 - 露出面板外 */
				.editor-toggle {
					left: -24px;
				}

				/* 移动端遮罩层 */
				.editor-overlay {
					display: none;
					position: fixed;
					top: 0;
					left: 0;
					right: 0;
					bottom: 0;
					background: rgba(0, 0, 0, 0.5);
					z-index: 40;
				}

				.editor-overlay.visible {
					display: block;
				}
			}

			/* Context Menu */
			.context-menu {
				position: fixed;
				background: var(--bg-panel);
				border: 1px solid var(--border-color);
				border-radius: var(--radius-md);
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
				min-width: 160px;
				z-index: 1000;
				padding: 4px 0;
				display: none;
			}

			.context-menu.visible {
				display: block;
			}

			.context-menu-item {
				padding: 8px 16px;
				cursor: pointer;
				font-size: 0.875rem;
				color: var(--text-primary);
				display: flex;
				align-items: center;
				gap: 8px;
				transition: background 0.15s;
			}

			.context-menu-item:hover {
				background: var(--bg-secondary);
			}

			.context-menu-item.danger {
				color: var(--error-color);
			}

			.context-menu-item.danger:hover {
				background: rgba(191, 97, 106, 0.2);
			}

			.context-menu-divider {
				height: 1px;
				background: var(--border-color);
				margin: 4px 0;
			}
		</style>
	</head>
	<body>
		<div class="app-container" id="app">
			<!-- Header -->
			<header class="app-header">
				<h1 class="app-title">CCFOLIA Replay Editor</h1>
				<div class="header-actions">
					<button class="btn btn-secondary" id="btn-import">导入项目</button>
					<button class="btn btn-secondary" id="btn-save">保存项目</button>
					<button class="btn btn-secondary" id="btn-export-log">导出Log</button>
				</div>
			</header>

			<!-- Main Content -->
			<main class="main-content">
				<!-- Mobile Overlay -->
				<div class="editor-overlay" id="editor-overlay"></div>

				<!-- Preview Area (Player) -->
				<div class="preview-area">
					<!-- View Mode Switcher -->
					<div class="view-switcher">
						<button class="view-btn active" id="btn-view-replay" title="回放模式">🎬 回放</button>
						<button class="view-btn" id="btn-view-list" title="消息列表">📋 列表</button>
						<button class="view-btn" id="btn-view-character" title="角色管理">👤 角色</button>
					</div>

					<!-- Replay View -->
					<div class="view-container active" id="view-replay">
						<div class="player-container" id="player">
							<!-- Portrait Area -->
							<div class="portrait-area" id="portrait-area">
								<img class="portrait-image hidden" id="portrait-img" src="" alt="Portrait" />
							</div>

							<!-- Dialogue Area -->
							<div class="dialogue-area" id="dialogue-area">
								<div class="dialogue-box" id="dialogue-box">
									<div class="dialogue-name" id="dialogue-name">角色名</div>
									<div class="dialogue-text" id="dialogue-text">点击开始播放...</div>
									<div class="click-indicator">▼ 点击继续</div>
								</div>
							</div>

							<!-- History Panel (Hidden by default) -->
							<div class="history-panel" id="history-panel">
								<div class="history-header">
									<h3 class="history-title">历史记录</h3>
									<button class="history-close" id="history-close">&times;</button>
								</div>
								<div id="history-list"></div>
							</div>
						</div>

						<!-- Player Controls -->
						<div class="player-controls">
							<button class="btn btn-icon btn-secondary" id="btn-prev" title="上一条">⏮</button>
							<button class="btn btn-icon btn-secondary" id="btn-auto-play" title="自动播放">▶</button>
							<button class="btn btn-icon btn-secondary" id="btn-next" title="下一条">⏭</button>
							<div class="progress-bar" id="progress-bar">
								<div class="progress-fill" id="progress-fill"></div>
							</div>
							<span class="progress-text" id="progress-text">0 / 0</span>
							<button class="btn btn-icon btn-secondary" id="btn-history" title="历史记录">📜</button>
						</div>
					</div>

					<!-- Message List View -->
					<div class="view-container" id="view-list">
						<div class="message-list-view">
							<div class="message-list-header">
								<div class="message-list-actions">
									<button class="icon-btn" id="btn-message-search" title="搜索消息">🔍</button>
									<button class="icon-btn" id="btn-message-batch-mode" title="批量选择消息">☑️</button>
									<button class="icon-btn" id="btn-edit-mode" title="切换编辑/阅读模式">📖</button>
									<span class="page-size-label">每页</span>
									<select class="page-size-select" id="page-size-select">
										<option value="10">10</option>
										<option value="20" selected>20</option>
										<option value="50">50</option>
										<option value="100">100</option>
									</select>
									<span class="page-size-label">条</span>
								</div>
							</div>

							<!-- Message Search Toolbar -->
							<div class="message-search-toolbar" id="message-search-toolbar">
								<select class="message-search-select" id="message-search-character">
									<option value="">全部角色</option>
								</select>
								<input type="text" class="message-search-input" id="message-search-input" placeholder="搜索内容..." />
								<div class="message-search-nav">
									<button class="icon-btn" id="btn-search-prev" title="上一个">◀</button>
									<span class="message-search-count" id="message-search-count">0/0</span>
									<button class="icon-btn" id="btn-search-next" title="下一个">▶</button>
								</div>
								<button class="icon-btn" id="btn-search-close" title="关闭搜索">✕</button>
							</div>

							<!-- Message Batch Selection Toolbar -->
							<div class="message-batch-toolbar" id="message-batch-toolbar">
								<span class="message-batch-count">已选择 0 条消息</span>
								<div class="message-batch-actions">
									<button class="btn btn-secondary btn-sm" id="btn-message-select-all">全选</button>
									<button class="btn btn-secondary btn-sm" id="btn-message-deselect-all">取消全选</button>
									<button class="btn btn-secondary btn-sm" id="btn-message-batch-copy">📋 复制</button>
									<button class="btn btn-secondary btn-sm" id="btn-message-batch-cut">✂️ 剪切</button>
									<button class="btn btn-secondary btn-sm message-batch-delete-btn" id="btn-message-batch-delete">
										🗑️ 删除
									</button>
									<button class="btn btn-secondary btn-sm" id="btn-message-batch-close">退出批量</button>
								</div>
							</div>
							<div class="message-list-container">
								<ul class="message-list-full" id="message-list-full">
									<!-- Messages will be rendered here -->
								</ul>
							</div>
							<div class="pagination">
								<button class="pagination-btn" id="btn-page-first" title="第一页">⏮</button>
								<button class="pagination-btn" id="btn-page-prev" title="上一页">◀</button>
								<span class="pagination-label">第</span>
								<input type="number" class="pagination-input" id="pagination-input" value="1" min="1" />
								<span class="pagination-label">页</span>
								<span class="pagination-info" id="pagination-info">/ 共 0 页</span>
								<button class="pagination-btn" id="btn-page-next" title="下一页">▶</button>
								<button class="pagination-btn" id="btn-page-last" title="最后一页">⏭</button>
							</div>
						</div>
					</div>

					<!-- Character View -->
					<div class="view-container" id="view-character">
						<div class="character-view">
							<div class="character-view-header">
								<!-- 左侧：筛选区域 -->
								<div class="header-section-left">
									<div class="character-filter-tabs" id="character-filter-tabs">
										<button class="filter-tab active" data-filter="all">全部</button>
										<button class="filter-tab" data-filter="uncategorized">未归类</button>
										<button class="filter-tab" data-filter="kp">KP</button>
										<button class="filter-tab" data-filter="npc">NPC</button>
										<button class="filter-tab" data-filter="pc">PC</button>
										<button class="filter-tab" data-filter="dice">骰子</button>
										<!-- Custom category tabs will be inserted here -->
									</div>
									<div class="filter-more-dropdown" id="filter-more-dropdown" style="display: none">
										<button class="filter-more-btn" id="filter-more-btn" title="更多分类">•••</button>
										<div class="filter-more-menu" id="filter-more-menu">
											<!-- Overflow categories will be rendered here -->
										</div>
									</div>
									<button class="filter-add-btn" id="btn-add-category" title="添加自定义类别">+</button>
								</div>
								<!-- 右侧：搜索 + 操作按钮 -->
								<div class="header-section-right">
									<div class="search-wrapper">
										<svg
											class="search-icon"
											xmlns="http://www.w3.org/2000/svg"
											width="14"
											height="14"
											viewBox="0 0 24 24"
											fill="none"
											stroke="currentColor"
											stroke-width="2"
											stroke-linecap="round"
											stroke-linejoin="round">
											<circle cx="11" cy="11" r="8"></circle>
											<line x1="21" y1="21" x2="16.65" y2="16.65"></line>
										</svg>
										<input type="text" class="search-input" id="character-search" placeholder="搜索..." />
									</div>
									<div class="character-view-actions">
										<button class="btn-icon" id="btn-batch-select" title="批量选择">☑️</button>
										<button class="btn-icon" id="btn-import-rules" title="语音配置管理">🔊</button>
									</div>
								</div>
								<!-- Batch Selection Toolbar -->
								<div class="batch-toolbar" id="batch-toolbar">
									<span class="batch-count">已选择 0 个角色</span>
									<div class="batch-actions">
										<button class="btn-sm" id="btn-batch-select-all">全选</button>
										<button class="btn-sm" id="btn-batch-deselect">取消选择</button>
										<button class="btn-sm" id="btn-batch-add-category">批量加入类别</button>
										<button class="btn-sm batch-delete-btn" id="btn-batch-delete">批量删除</button>
										<button class="btn-sm batch-close-btn" id="btn-batch-close" title="退出批量选择">✕</button>
									</div>
								</div>
							</div>
							<div class="character-grid" id="character-grid">
								<!-- Character cards will be rendered here -->
								<div class="character-empty-state">
									<p>请先获取日志数据</p>
								</div>
							</div>
							<!-- Character Detail Page -->
							<div class="character-detail-page hidden" id="character-detail-page">
								<!-- Detail content will be rendered here -->
							</div>
						</div>
					</div>
				</div>

				<!-- Editor Panel (Drawer) -->
				<aside class="editor-panel" id="editor-panel">
					<button class="editor-toggle" id="editor-toggle" title="收起/展开">◀</button>

					<div class="editor-header">
						<span class="editor-title">编辑面板</span>
					</div>

					<div class="editor-content">
						<!-- Data Fetch Section -->
						<section class="editor-section" id="section-fetch">
							<h3 class="section-title">获取数据</h3>
							<div class="form-group">
								<label class="form-label">房间号 / URL</label>
								<input type="text" class="form-input" id="input-room" placeholder="输入房间号或粘贴URL" />
							</div>
							<button class="btn btn-primary" id="btn-fetch" style="width: 100%">获取日志</button>
						</section>

						<!-- Filter Section -->
						<section class="editor-section" id="section-filter">
							<h3 class="section-title">过滤规则</h3>
							<div class="form-group">
								<label class="flex items-center gap-2">
									<input type="checkbox" id="filter-empty" checked />
									<span>过滤空白消息</span>
								</label>
							</div>
							<div class="form-group">
								<label class="flex items-center gap-2">
									<input type="checkbox" id="filter-onoff" />
									<span>标记区间过滤</span>
								</label>
								<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px; padding-left: 20px">
									只保留开始标记和结束标记之间的消息
								</div>
								<div id="onoff-settings" style="margin-top: 8px; padding-left: 20px; display: none">
									<div style="display: flex; gap: 8px; margin-bottom: 4px">
										<input
											type="text"
											class="form-input"
											id="marker-start"
											placeholder="开始标记"
											value="on"
											style="flex: 1; padding: 4px 8px; font-size: 0.8rem" />
										<input
											type="text"
											class="form-input"
											id="marker-end"
											placeholder="结束标记"
											value="off"
											style="flex: 1; padding: 4px 8px; font-size: 0.8rem" />
									</div>
									<div style="font-size: 0.7rem; color: var(--text-secondary)">
										支持格式: ——on——、==开始==、-off- 等（自动匹配前后的符号）
									</div>
								</div>
							</div>
							<div class="form-group">
								<label class="form-label">前缀黑名单</label>
								<div class="prefix-tags-container">
									<div class="prefix-tags" id="prefix-tags"></div>
									<div class="prefix-input-container">
										<input
											type="text"
											class="form-input prefix-input"
											id="prefix-input"
											placeholder="输入前缀后按回车添加" />
										<button type="button" class="btn btn-secondary btn-sm" id="add-prefix-btn">添加</button>
									</div>
								</div>
							</div>
							<div class="form-group">
								<label class="form-label">排除频道</label>
								<div
									id="channel-checkboxes"
									style="
										max-height: 150px;
										overflow-y: auto;
										padding: 8px;
										background: var(--bg-input);
										border-radius: var(--radius-md);
										border: 1px solid var(--border-color);
									">
									<span style="color: var(--text-secondary); font-size: 0.8rem">请先获取日志数据</span>
								</div>
							</div>
							<button class="btn btn-secondary" id="btn-apply-filter" style="width: 100%">应用过滤</button>
							<div id="filter-stats" style="margin-top: 8px; font-size: 0.8rem; color: var(--text-secondary)"></div>
						</section>

						<!-- House Rules Section (村规设置) -->
						<section class="editor-section" id="section-house-rules">
							<h3 class="section-title">🎲 村规设置</h3>
							<div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 12px">
								自定义大成功/大失败的判定范围，应用后会修改所有CC检定的结果
							</div>
							<div class="form-group">
								<label class="form-label">大成功范围</label>
								<div style="display: flex; gap: 8px; align-items: center">
									<input
										type="number"
										class="form-input"
										id="critical-min"
										value="1"
										min="1"
										max="100"
										style="width: 70px" />
									<span>~</span>
									<input
										type="number"
										class="form-input"
										id="critical-max"
										value="5"
										min="1"
										max="100"
										style="width: 70px" />
									<span style="font-size: 0.8rem; color: var(--text-secondary)">（含边界）</span>
								</div>
							</div>
							<div class="form-group">
								<label class="form-label">大失败范围</label>
								<div style="display: flex; gap: 8px; align-items: center">
									<input
										type="number"
										class="form-input"
										id="fumble-min"
										value="96"
										min="1"
										max="100"
										style="width: 70px" />
									<span>~</span>
									<input
										type="number"
										class="form-input"
										id="fumble-max"
										value="100"
										min="1"
										max="100"
										style="width: 70px" />
									<span style="font-size: 0.8rem; color: var(--text-secondary)">（含边界）</span>
								</div>
							</div>
							<div style="display: flex; gap: 8px">
								<button class="btn btn-primary" id="btn-apply-house-rules" style="flex: 1">应用村规</button>
								<button class="btn btn-secondary" id="btn-reset-house-rules" style="flex: 1">重置</button>
							</div>
							<div
								id="house-rules-stats"
								style="margin-top: 8px; font-size: 0.8rem; color: var(--text-secondary)"></div>
						</section>

						<!-- Portrait Config Section -->
						<section class="editor-section" id="section-portrait">
							<h3 class="section-title">差分配置</h3>
							<div id="multi-mode-settings">
								<div class="form-group">
									<label class="form-label">缩放模式</label>
									<select class="form-input" id="scale-mode">
										<option value="percent">百分比自适应（位置随窗口缩放）</option>
										<option value="canvas" selected>固定画布（保持比例，可能有黑边）</option>
									</select>
								</div>
								<div id="canvas-settings" style="margin-bottom: 12px">
									<label class="form-label">画布尺寸</label>
									<div style="display: flex; gap: 8px; align-items: center">
										<input type="number" class="form-input" id="canvas-width" value="1920" style="width: 80px" />
										<span>×</span>
										<input type="number" class="form-input" id="canvas-height" value="1080" style="width: 80px" />
										<select class="form-input" id="canvas-preset" style="flex: 1">
											<option value="">自定义</option>
											<option value="1920x1080" selected>1080p (16:9)</option>
											<option value="1280x720">720p (16:9)</option>
											<option value="1600x900">900p (16:9)</option>
											<option value="800x600">800×600 (4:3)</option>
										</select>
									</div>
									<div style="margin-top: 12px">
										<label class="form-label">对话框样式</label>
										<div style="display: flex; gap: 8px; margin-bottom: 8px">
											<div style="flex: 1">
												<label style="font-size: 0.75rem; color: var(--text-secondary)">字体大小</label>
												<input type="number" class="form-input" id="dialogue-font-size" value="24" min="12" max="72" />
											</div>
											<div style="flex: 1">
												<label style="font-size: 0.75rem; color: var(--text-secondary)">名字大小</label>
												<input type="number" class="form-input" id="dialogue-name-size" value="20" min="12" max="48" />
											</div>
										</div>
										<div style="display: flex; gap: 8px; margin-bottom: 8px">
											<div style="flex: 1">
												<label style="font-size: 0.75rem; color: var(--text-secondary)">背景透明度</label>
												<input type="range" id="dialogue-bg-opacity" min="0" max="100" value="70" style="width: 100%" />
											</div>
											<div style="width: 50px">
												<span id="dialogue-bg-opacity-value" style="font-size: 0.8rem">70%</span>
											</div>
										</div>
										<div style="margin-bottom: 8px">
											<label style="font-size: 0.75rem; color: var(--text-secondary)">
												背景图片 URL（留空使用纯色）
											</label>
											<input
												type="text"
												class="form-input"
												id="dialogue-bg-image"
												placeholder="https://example.com/image.png"
												style="width: 100%" />
										</div>
										<div style="display: flex; gap: 8px; margin-bottom: 8px">
											<div style="flex: 1">
												<label style="font-size: 0.75rem; color: var(--text-secondary)">对话框高度</label>
												<input type="number" class="form-input" id="dialogue-height" value="150" min="80" max="400" />
											</div>
											<div style="flex: 1">
												<label style="font-size: 0.75rem; color: var(--text-secondary)">左右边距</label>
												<input type="number" class="form-input" id="dialogue-padding-x" value="20" min="4" max="80" />
											</div>
											<div style="flex: 1">
												<label style="font-size: 0.75rem; color: var(--text-secondary)">上下边距</label>
												<input type="number" class="form-input" id="dialogue-padding-y" value="16" min="4" max="60" />
											</div>
										</div>
										<button
											class="btn btn-secondary"
											id="btn-reset-dialogue-pos"
											style="width: 100%; margin-top: 8px; font-size: 0.8rem">
											重置对话框位置
										</button>
									</div>

									<!-- 文字样式设置 -->
									<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color)">
										<div style="font-weight: 500; margin-bottom: 10px; font-size: 0.85rem">📝 文字样式</div>

										<!-- 全局颜色 - 紧凑布局 -->
										<div style="display: flex; gap: 12px; margin-bottom: 10px; align-items: center">
											<div style="display: flex; align-items: center; gap: 6px; flex: 1">
												<input
													type="color"
													id="dialogue-name-color"
													value="#ffffff"
													style="
														width: 24px;
														height: 24px;
														padding: 0;
														border: 2px solid var(--border-color);
														border-radius: 4px;
														cursor: pointer;
														background: none;
													" />
												<input
													type="text"
													id="dialogue-name-color-text"
													value="#ffffff"
													class="form-input"
													style="flex: 1; font-size: 0.75rem; padding: 4px 6px; font-family: monospace"
													placeholder="名称色" />
											</div>
											<div style="display: flex; align-items: center; gap: 6px; flex: 1">
												<input
													type="color"
													id="dialogue-text-color"
													value="#ffffff"
													style="
														width: 24px;
														height: 24px;
														padding: 0;
														border: 2px solid var(--border-color);
														border-radius: 4px;
														cursor: pointer;
														background: none;
													" />
												<input
													type="text"
													id="dialogue-text-color-text"
													value="#ffffff"
													class="form-input"
													style="flex: 1; font-size: 0.75rem; padding: 4px 6px; font-family: monospace"
													placeholder="内容色" />
											</div>
										</div>

										<!-- 字体选择 -->
										<select
											class="form-input"
											id="dialogue-font-family"
											style="width: 100%; margin-bottom: 10px; font-size: 0.8rem">
											<option value="">默认字体</option>
											<option value="serif">衬线体</option>
											<option value="sans-serif">无衬线</option>
											<option value="monospace">等宽</option>
											<option value="cursive">手写</option>
										</select>

										<!-- 角色样式列表 -->
										<div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 4px">
											点击角色设置专属样式
										</div>
										<div
											id="character-style-list"
											style="max-height: 180px; overflow-y: auto; background: var(--bg-dark); border-radius: 6px"></div>
									</div>

									<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 8px">
										💡 滚轮缩放画布，拖拽空白移动画布，拖拽对话框移动位置，双击重置视图
									</div>
								</div>
								<div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 8px">
									💡 在回放视图中拖拽差分可调整位置，拖拽角落可调整大小
								</div>
								<button class="btn btn-secondary" id="btn-reset-positions" style="width: 100%">重置差分位置</button>
							</div>
						</section>

						<!-- Background Config Section -->
						<section class="editor-section" id="section-background">
							<h3 class="section-title">背景配置</h3>
							<div class="form-group">
								<label class="form-label">默认背景</label>
								<input type="text" class="form-input" id="default-bg" placeholder="背景图片URL" />
								<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px">
									未设置切换点的消息将使用此背景
								</div>
							</div>
							<div class="form-group">
								<label class="form-label">背景切换点</label>
								<div
									id="background-switch-list"
									style="
										max-height: 200px;
										overflow-y: auto;
										padding: 8px;
										background: var(--bg-input);
										border-radius: var(--radius-md);
										border: 1px solid var(--border-color);
									">
									<span style="color: var(--text-secondary); font-size: 0.8rem">暂无背景切换点</span>
								</div>
							</div>
							<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 8px">
								💡 在消息列表中点击 🖼️ 按钮为消息设置背景切换点
							</div>
						</section>

						<!-- BGM Config Section -->
						<section class="editor-section" id="section-bgm">
							<h3 class="section-title">🎵 背景音乐</h3>
							<div class="form-group">
								<label class="form-label">默认 BGM</label>
								<div class="custom-select" id="default-bgm-select">
									<button type="button" class="custom-select-trigger placeholder">无（不播放背景音乐）</button>
									<div class="custom-select-dropdown"></div>
								</div>
								<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px">
									未设置切换点时播放此音乐，请先在下方音乐库添加 BGM
								</div>
							</div>
							<div class="form-group">
								<label class="form-label">全局控制</label>
								<div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px">
									<button class="btn btn-secondary btn-icon" id="bgm-mute-btn" title="静音/取消静音">🔊</button>
									<input
										type="range"
										id="bgm-volume-slider"
										min="0"
										max="100"
										value="50"
										style="flex: 1"
										title="音量" />
									<span id="bgm-volume-value" style="font-size: 0.8rem; color: var(--text-secondary); min-width: 35px">
										50%
									</span>
								</div>
								<div style="display: flex; align-items: center; gap: 8px">
									<label style="display: flex; align-items: center; gap: 4px; font-size: 0.85rem; cursor: pointer">
										<input type="checkbox" id="bgm-loop-checkbox" checked />
										循环播放
									</label>
								</div>
							</div>
							<div class="form-group">
								<label class="form-label" style="display: flex; align-items: center; justify-content: space-between">
									<span>BGM 音乐库</span>
									<div style="display: flex; gap: 4px">
										<button class="btn btn-secondary" id="btn-bgm-import" style="padding: 4px 8px; font-size: 0.75rem">
											从房间导入
										</button>
										<button class="btn btn-secondary" id="btn-bgm-account" style="padding: 4px 8px; font-size: 0.75rem">
											从账号导入
										</button>
										<button class="btn btn-secondary" id="btn-bgm-custom" style="padding: 4px 8px; font-size: 0.75rem">
											+ 自定义
										</button>
									</div>
								</label>
								<div
									id="bgm-library-list"
									style="
										max-height: 180px;
										overflow-y: auto;
										padding: 8px;
										background: var(--bg-input);
										border-radius: var(--radius-md);
										border: 1px solid var(--border-color);
									">
									<span style="color: var(--text-secondary); font-size: 0.8rem">暂无 BGM，点击上方按钮添加</span>
								</div>
							</div>
							<div class="form-group">
								<label class="form-label">BGM 切换点</label>
								<div
									id="bgm-switch-list"
									style="
										max-height: 200px;
										overflow-y: auto;
										padding: 8px;
										background: var(--bg-input);
										border-radius: var(--radius-md);
										border: 1px solid var(--border-color);
									">
									<span style="color: var(--text-secondary); font-size: 0.8rem">暂无 BGM 切换点</span>
								</div>
							</div>
							<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 8px">
								💡 在消息列表中点击 🎵 按钮为消息设置 BGM 切换点
							</div>
						</section>
					</div>
				</aside>
			</main>
		</div>

		<!-- Edit Message Modal -->
		<div class="modal-overlay" id="modal-edit">
			<div class="modal">
				<div class="modal-header">
					<span class="modal-title" id="modal-edit-title">编辑消息</span>
					<button class="modal-close" id="modal-edit-close">&times;</button>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label class="form-label">说话人姓名</label>
						<input type="text" class="form-input" id="edit-name" placeholder="角色名（留空为旁白）" />
					</div>
					<div class="form-group">
						<label class="form-label">差分选择</label>
						<div class="portrait-selector" id="edit-portrait-selector">
							<div class="portrait-selector-trigger" id="edit-portrait-trigger">
								<div class="portrait-selector-preview no-portrait" id="edit-portrait-preview">无</div>
								<span class="portrait-selector-text" id="edit-portrait-text">无差分</span>
								<span class="portrait-selector-arrow">▼</span>
							</div>
							<div class="portrait-selector-dropdown" id="edit-portrait-dropdown">
								<!-- Options will be populated dynamically -->
							</div>
						</div>
						<input type="hidden" id="edit-icon" />
						<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px">选择该角色的差分图片</div>
					</div>
					<div class="form-group" id="edit-text-group">
						<label class="form-label">消息内容</label>
						<textarea class="form-textarea" id="edit-text" placeholder="输入消息内容..." rows="4"></textarea>
					</div>
					<div class="form-group" id="edit-dice-group" style="display: none">
						<label class="form-label">🎲 骰点编辑</label>
						<!-- CC检定类型 -->
						<div id="edit-dice-cc" style="display: none">
							<div style="display: flex; gap: 8px; margin-bottom: 8px">
								<div style="flex: 1">
									<label style="font-size: 0.75rem; color: var(--text-secondary)">技能值</label>
									<input type="number" class="form-input" id="edit-dice-cc-target" min="1" max="100" placeholder="70" />
								</div>
								<div style="flex: 1">
									<label style="font-size: 0.75rem; color: var(--text-secondary)">骰点结果</label>
									<input type="number" class="form-input" id="edit-dice-cc-roll" min="1" max="100" placeholder="69" />
								</div>
							</div>
							<div style="margin-bottom: 8px">
								<label style="font-size: 0.75rem; color: var(--text-secondary)">技能名（可空）</label>
								<input type="text" class="form-input" id="edit-dice-cc-name" />
							</div>
							<div style="font-size: 0.8rem; padding: 8px; background: var(--bg-secondary); border-radius: 4px">
								判定结果:
								<span id="edit-dice-cc-preview" style="font-weight: bold">--</span>
							</div>
						</div>
						<!-- 普通骰点类型 -->
						<div id="edit-dice-normal" style="display: none">
							<div style="display: flex; gap: 8px; margin-bottom: 8px">
								<div style="flex: 1">
									<label style="font-size: 0.75rem; color: var(--text-secondary)">算式</label>
									<input type="text" class="form-input" id="edit-dice-formula" placeholder="2D6+3" />
								</div>
								<div style="flex: 1">
									<label style="font-size: 0.75rem; color: var(--text-secondary)">结果</label>
									<input type="number" class="form-input" id="edit-dice-result" placeholder="10" />
								</div>
							</div>
							<div
								style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 8px"
								id="edit-dice-range-hint">
								有效范围: --
							</div>
							<div>
								<label style="font-size: 0.75rem; color: var(--text-secondary)">描述（可空）</label>
								<input type="text" class="form-input" id="edit-dice-desc" />
							</div>
						</div>
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-edit-cancel">取消</button>
					<button class="btn btn-primary" id="modal-edit-save">保存</button>
				</div>
			</div>
		</div>

		<!-- Insert Message Modal -->
		<div class="modal-overlay" id="modal-insert">
			<div class="modal">
				<div class="modal-header">
					<span class="modal-title">插入新消息</span>
					<button class="modal-close" id="modal-insert-close">&times;</button>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label class="form-label">说话人姓名</label>
						<input type="text" class="form-input" id="insert-name" placeholder="角色名（留空为旁白）" />
					</div>
					<div class="form-group">
						<label class="form-label">差分选择</label>
						<div class="portrait-selector" id="insert-portrait-selector">
							<div class="portrait-selector-trigger" id="insert-portrait-trigger">
								<div class="portrait-selector-preview no-portrait" id="insert-portrait-preview">无</div>
								<span class="portrait-selector-text" id="insert-portrait-text">无差分</span>
								<span class="portrait-selector-arrow">▼</span>
							</div>
							<div class="portrait-selector-dropdown" id="insert-portrait-dropdown">
								<!-- Options will be populated dynamically -->
							</div>
						</div>
						<input type="hidden" id="insert-icon" />
						<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px">选择该角色的差分图片</div>
					</div>
					<div class="form-group">
						<label class="form-label">消息内容</label>
						<textarea class="form-textarea" id="insert-text" placeholder="输入消息内容..." rows="4"></textarea>
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-insert-cancel">取消</button>
					<button class="btn btn-primary" id="modal-insert-save">插入</button>
				</div>
			</div>
		</div>

		<!-- Insert Dice Modal -->
		<div class="modal-overlay" id="modal-insert-dice">
			<div class="modal">
				<div class="modal-header">
					<span class="modal-title">插入骰点</span>
					<button class="modal-close" id="modal-insert-dice-close">&times;</button>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label class="form-label">说话人姓名</label>
						<input type="text" class="form-input" id="insert-dice-name" placeholder="角色名" />
					</div>
					<div class="form-group">
						<label class="form-label">差分选择</label>
						<div class="portrait-selector" id="insert-dice-portrait-selector">
							<div class="portrait-selector-trigger" id="insert-dice-portrait-trigger">
								<div class="portrait-selector-preview no-portrait" id="insert-dice-portrait-preview">无</div>
								<span class="portrait-selector-text" id="insert-dice-portrait-text">无差分</span>
								<span class="portrait-selector-arrow">▼</span>
							</div>
							<div class="portrait-selector-dropdown" id="insert-dice-portrait-dropdown">
								<!-- Options will be populated dynamically -->
							</div>
						</div>
						<input type="hidden" id="insert-dice-icon" />
					</div>
					<div class="form-group">
						<label class="form-label">骰点类型</label>
						<select class="form-input" id="insert-dice-type">
							<option value="cc">技能检定</option>
							<option value="normal">普通骰点</option>
						</select>
					</div>
					<!-- CC检定类型 -->
					<div id="insert-dice-cc">
						<div style="display: flex; gap: 8px; margin-bottom: 8px">
							<div style="flex: 1">
								<label style="font-size: 0.75rem; color: var(--text-secondary)">技能值</label>
								<input type="number" class="form-input" id="insert-dice-cc-target" min="1" max="100" />
							</div>
							<div style="flex: 1">
								<label style="font-size: 0.75rem; color: var(--text-secondary)">骰点结果</label>
								<input type="number" class="form-input" id="insert-dice-cc-roll" min="1" max="100" />
							</div>
						</div>
						<div style="margin-bottom: 8px">
							<label style="font-size: 0.75rem; color: var(--text-secondary)">技能名（可空）</label>
							<input type="text" class="form-input" id="insert-dice-cc-skill" />
						</div>
						<div style="font-size: 0.8rem; padding: 8px; background: var(--bg-secondary); border-radius: 4px">
							判定结果:
							<span id="insert-dice-cc-preview" style="font-weight: bold">--</span>
						</div>
					</div>
					<!-- 普通骰点类型 -->
					<div id="insert-dice-normal" style="display: none">
						<div style="display: flex; gap: 8px; margin-bottom: 8px">
							<div style="flex: 1">
								<label style="font-size: 0.75rem; color: var(--text-secondary)">算式</label>
								<input type="text" class="form-input" id="insert-dice-formula" placeholder="例如:2D6+3" />
							</div>
							<div style="flex: 1">
								<label style="font-size: 0.75rem; color: var(--text-secondary)">结果</label>
								<input type="number" class="form-input" id="insert-dice-result" />
							</div>
						</div>
						<div
							style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 8px"
							id="insert-dice-range-hint">
							有效范围: --
						</div>
						<div>
							<label style="font-size: 0.75rem; color: var(--text-secondary)">描述（可空）</label>
							<input type="text" class="form-input" id="insert-dice-desc" />
						</div>
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-insert-dice-cancel">取消</button>
					<button class="btn btn-primary" id="modal-insert-dice-save">插入</button>
				</div>
			</div>
		</div>

		<!-- Stage Control Modal -->
		<div class="modal-overlay" id="modal-stage">
			<div class="modal">
				<div class="modal-header">
					<span class="modal-title" id="modal-stage-title">角色进退场</span>
					<button class="modal-close" id="modal-stage-close">&times;</button>
				</div>
				<div class="modal-body">
					<p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px">
						选择在此消息时进场或退场的角色
					</p>
					<div class="form-group">
						<label class="form-label">进场角色（勾选后显示）</label>
						<div
							id="stage-enter-list"
							style="
								max-height: 150px;
								overflow-y: auto;
								padding: 8px;
								background: var(--bg-input);
								border-radius: var(--radius-md);
								border: 1px solid var(--border-color);
							">
							<span style="color: var(--text-secondary); font-size: 0.8rem">请先获取日志数据</span>
						</div>
					</div>
					<div class="form-group">
						<label class="form-label">退场角色（勾选后隐藏）</label>
						<div
							id="stage-exit-list"
							style="
								max-height: 150px;
								overflow-y: auto;
								padding: 8px;
								background: var(--bg-input);
								border-radius: var(--radius-md);
								border: 1px solid var(--border-color);
							">
							<span style="color: var(--text-secondary); font-size: 0.8rem">请先获取日志数据</span>
						</div>
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-stage-cancel">取消</button>
					<button class="btn btn-primary" id="modal-stage-save">保存</button>
				</div>
			</div>
		</div>

		<!-- Background Setting Modal -->
		<div class="modal-overlay" id="modal-background">
			<div class="modal">
				<div class="modal-header">
					<span class="modal-title" id="modal-background-title">设置背景</span>
					<button class="modal-close" id="modal-background-close">&times;</button>
				</div>
				<div class="modal-body">
					<p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px">
						从此消息开始使用新的背景图片
					</p>
					<div class="form-group">
						<label class="form-label">背景图片 URL</label>
						<input
							type="text"
							class="form-input"
							id="background-url-input"
							placeholder="输入背景图片URL（留空则清除背景设置）" />
					</div>
					<div class="form-group">
						<label class="form-label">预览</label>
						<div
							id="background-preview"
							style="
								width: 100%;
								height: 120px;
								background: var(--bg-input);
								border: 1px solid var(--border-color);
								border-radius: var(--radius-md);
								background-size: cover;
								background-position: center;
								display: flex;
								align-items: center;
								justify-content: center;
								color: var(--text-secondary);
								font-size: 0.8rem;
							">
							无背景
						</div>
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-background-cancel">取消</button>
					<button class="btn btn-secondary" id="modal-background-remove" style="color: var(--error-color)">
						移除背景
					</button>
					<button class="btn btn-primary" id="modal-background-save">保存</button>
				</div>
			</div>
		</div>

		<!-- BGM Setting Modal -->
		<div class="modal-overlay" id="modal-bgm">
			<div class="modal">
				<div class="modal-header">
					<span class="modal-title" id="modal-bgm-title">设置背景音乐</span>
					<button class="modal-close" id="modal-bgm-close">&times;</button>
				</div>
				<div class="modal-body">
					<p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px">
						从此消息开始播放新的背景音乐
					</p>
					<div class="form-group">
						<label class="form-label">选择 BGM</label>
						<div class="custom-select" id="bgm-modal-select">
							<button type="button" class="custom-select-trigger placeholder">请选择...</button>
							<div class="custom-select-dropdown"></div>
						</div>
						<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px">
							请先在右侧面板的 BGM 音乐库中添加音乐
						</div>
					</div>
					<div class="form-group">
						<label class="form-label">预览</label>
						<div
							id="bgm-preview-container"
							style="
								display: flex;
								align-items: center;
								gap: 12px;
								padding: 12px;
								background: var(--bg-input);
								border: 1px solid var(--border-color);
								border-radius: var(--radius-md);
							">
							<button
								id="bgm-preview-btn"
								class="btn btn-secondary btn-icon"
								style="width: 40px; height: 40px; border-radius: 50%; font-size: 1.2rem"
								title="播放/暂停预览">
								▶️
							</button>
							<div style="flex: 1">
								<div id="bgm-preview-status" style="font-size: 0.8rem; color: var(--text-secondary)">
									选择 BGM 后点击播放预览
								</div>
								<input
									type="range"
									id="bgm-preview-volume"
									min="0"
									max="100"
									value="50"
									style="width: 100%; margin-top: 4px"
									title="预览音量" />
							</div>
						</div>
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-bgm-cancel">取消</button>
					<button class="btn btn-secondary" id="modal-bgm-stop" style="color: var(--warning-color)">设为静音点</button>
					<button class="btn btn-secondary" id="modal-bgm-remove" style="color: var(--error-color)">移除设置</button>
					<button class="btn btn-primary" id="modal-bgm-save">保存</button>
				</div>
			</div>
		</div>

		<!-- Add Category Modal -->
		<div class="modal-overlay" id="modal-add-category">
			<div class="modal" style="max-width: 400px">
				<div class="modal-header">
					<span class="modal-title">添加自定义类别</span>
					<button class="modal-close" id="modal-category-close">&times;</button>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label class="form-label">类别名称</label>
						<input
							type="text"
							class="form-input"
							id="category-name-input"
							placeholder="输入类别名称..."
							maxlength="20" />
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-category-cancel">取消</button>
					<button class="btn btn-primary" id="modal-category-save">创建</button>
				</div>
			</div>
		</div>

		<!-- Delete Category Confirm Modal -->
		<div class="modal-overlay" id="modal-delete-category">
			<div class="modal" style="max-width: 400px">
				<div class="modal-header">
					<span class="modal-title">删除类别</span>
					<button class="modal-close" id="modal-delete-category-close">&times;</button>
				</div>
				<div class="modal-body">
					<p style="color: var(--text-secondary); margin-bottom: 12px">
						确定要删除类别 "
						<span id="delete-category-name"></span>
						" 吗？
					</p>
					<p style="font-size: 0.85rem; color: var(--warning-color)">该类别下的角色将被移出类别，但不会被删除。</p>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-delete-category-cancel">取消</button>
					<button class="btn btn-primary" id="modal-delete-category-confirm" style="background: var(--error-color)">
						删除
					</button>
				</div>
			</div>
		</div>

		<!-- Batch Add to Category Modal -->
		<div class="modal-overlay" id="modal-batch-category">
			<div class="modal" style="max-width: 400px">
				<div class="modal-header">
					<span class="modal-title">批量加入类别</span>
					<button class="modal-close" id="modal-batch-category-close">&times;</button>
				</div>
				<div class="modal-body">
					<p style="color: var(--text-secondary); margin-bottom: 12px">选择要加入的类别：</p>
					<div class="batch-category-list" id="batch-category-list">
						<!-- Category items will be rendered here -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-batch-category-cancel">取消</button>
				</div>
			</div>
		</div>

		<!-- Batch Delete Confirm Modal -->
		<div class="modal-overlay" id="modal-batch-delete">
			<div class="modal" style="max-width: 450px">
				<div class="modal-header">
					<span class="modal-title">批量删除角色</span>
					<button class="modal-close" id="modal-batch-delete-close">&times;</button>
				</div>
				<div class="modal-body">
					<p style="color: var(--text-secondary); margin-bottom: 12px">
						确定要删除选中的
						<strong id="batch-delete-char-count">0</strong>
						个角色吗？
					</p>
					<p style="font-size: 0.9rem; color: var(--error-color); margin-bottom: 12px">
						⚠️ 这将同时删除这些角色的
						<strong id="batch-delete-msg-count">0</strong>
						条消息！
					</p>
					<p style="font-size: 0.85rem; color: var(--warning-color)">此操作不可撤销。</p>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-batch-delete-cancel">取消</button>
					<button class="btn btn-primary" id="modal-batch-delete-confirm" style="background: var(--error-color)">
						确认删除
					</button>
				</div>
			</div>
		</div>

		<!-- BGM Import from CCFOLIA Modal -->
		<div class="modal-overlay" id="modal-bgm-import">
			<div class="modal" style="max-width: 500px">
				<div class="modal-header">
					<span class="modal-title">从 CCFOLIA 房间导入 BGM</span>
					<button class="modal-close" id="modal-bgm-import-close">&times;</button>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label class="form-label">房间 ID</label>
						<div style="display: flex; gap: 8px">
							<input
								type="text"
								class="form-input"
								id="bgm-import-room-id"
								placeholder="输入 CCFOLIA 房间 ID..."
								style="flex: 1" />
							<button class="btn btn-primary" id="bgm-import-fetch-btn">获取</button>
						</div>
						<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px">
							房间 ID 可从 CCFOLIA 房间 URL 中获取
						</div>
					</div>
					<div class="form-group">
						<label class="form-label">场景 BGM 列表</label>
						<div
							id="bgm-import-list"
							style="
								max-height: 250px;
								overflow-y: auto;
								padding: 8px;
								background: var(--bg-input);
								border-radius: var(--radius-md);
								border: 1px solid var(--border-color);
							">
							<span style="color: var(--text-secondary); font-size: 0.85rem">输入房间 ID 后点击获取</span>
						</div>
					</div>
					<div id="bgm-import-status" style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 8px"></div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-bgm-import-cancel">取消</button>
					<button class="btn btn-primary" id="modal-bgm-import-confirm" disabled>导入选中</button>
				</div>
			</div>
		</div>

		<!-- Add Custom BGM Modal -->
		<div class="modal-overlay" id="modal-bgm-custom">
			<div class="modal" style="max-width: 400px">
				<div class="modal-header">
					<span class="modal-title">添加自定义 BGM</span>
					<button class="modal-close" id="modal-bgm-custom-close">&times;</button>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label class="form-label">名称</label>
						<input type="text" class="form-input" id="bgm-custom-name" placeholder="输入 BGM 名称..." />
					</div>
					<div class="form-group">
						<label class="form-label">URL</label>
						<input type="text" class="form-input" id="bgm-custom-url" placeholder="输入音频 URL（mp3, ogg, wav）..." />
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-bgm-custom-cancel">取消</button>
					<button class="btn btn-primary" id="modal-bgm-custom-save">添加</button>
				</div>
			</div>
		</div>

		<!-- Account BGM Import Modal -->
		<div class="modal-overlay" id="modal-bgm-account">
			<div class="modal" style="max-width: 520px">
				<div class="modal-header">
					<span class="modal-title">从 CCFOLIA 账号导入 BGM</span>
					<button class="modal-close" id="modal-bgm-account-close">&times;</button>
				</div>
				<div class="modal-body">
					<!-- 免责声明 -->
					<div
						style="
							background: rgba(235, 203, 139, 0.1);
							border: 1px solid var(--warning-color);
							border-radius: var(--radius-md);
							padding: 12px;
							margin-bottom: 16px;
							font-size: 0.8rem;
							line-height: 1.6;
						">
						<div style="color: var(--warning-color); font-weight: 600; margin-bottom: 8px">⚠️ 安全提示与免责声明</div>
						<ul style="color: var(--text-secondary); margin: 0; padding-left: 16px">
							<li>此功能需要您的 CCFOLIA 账号密码来获取您的个人音乐库</li>
							<li>
								您的账号密码
								<strong style="color: var(--text-primary)">仅用于直接向 Google Firebase 认证服务器发送请求</strong>
								，不会被本页面存储或发送到任何其他地方
							</li>
							<li>本工具为开源项目，您可以检查源代码确认安全性</li>
							<li>如果您对此有任何顾虑，可以选择不使用此功能，改用"从房间导入"</li>
						</ul>
					</div>

					<!-- 登录表单 -->
					<div id="account-login-form">
						<div class="form-group">
							<label class="form-label">CCFOLIA 邮箱</label>
							<input
								type="email"
								class="form-input"
								id="account-email"
								placeholder="输入您的 CCFOLIA 登录邮箱..."
								autocomplete="email" />
						</div>
						<div class="form-group">
							<label class="form-label">密码</label>
							<input
								type="password"
								class="form-input"
								id="account-password"
								placeholder="输入密码..."
								autocomplete="current-password" />
						</div>
						<div style="display: flex; gap: 8px; margin-top: 12px">
							<button class="btn btn-primary" id="account-login-btn" style="flex: 1">登录并获取音乐库</button>
						</div>
						<div id="account-login-status" style="font-size: 0.85rem; margin-top: 8px; min-height: 20px"></div>
					</div>

					<!-- 音乐列表（登录成功后显示） -->
					<div id="account-media-section" style="display: none">
						<div class="form-group">
							<label class="form-label" style="display: flex; align-items: center; justify-content: space-between">
								<span>账号音乐库</span>
								<button
									class="btn btn-secondary"
									id="account-select-all-btn"
									style="padding: 2px 8px; font-size: 0.7rem">
									全选/取消
								</button>
							</label>
							<div
								id="account-media-list"
								style="
									max-height: 280px;
									overflow-y: auto;
									padding: 8px;
									background: var(--bg-input);
									border-radius: var(--radius-md);
									border: 1px solid var(--border-color);
								"></div>
						</div>
						<div
							id="account-media-status"
							style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 8px"></div>
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-bgm-account-cancel">取消</button>
					<button class="btn btn-primary" id="modal-bgm-account-confirm" disabled>导入选中</button>
				</div>
			</div>
		</div>

		<!-- Quick Portrait Edit Modal -->
		<div class="modal-overlay" id="modal-quick-portrait-edit">
			<div class="modal" style="max-width: 600px">
				<div class="modal-header">
					<span class="modal-title">快速差分编辑</span>
					<button class="modal-close" id="modal-quick-portrait-edit-close">&times;</button>
				</div>
				<div class="modal-body">
					<div class="quick-portrait-info">
						<div class="quick-portrait-current-message">
							<strong id="quick-portrait-character-name">角色名</strong>
							<span id="quick-portrait-message-text">消息内容...</span>
						</div>
					</div>
					<div class="quick-portrait-selector-grid" id="quick-portrait-selector-grid">
						<!-- Portrait options will be populated dynamically -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-quick-portrait-edit-cancel">取消</button>
				</div>
			</div>
		</div>

		<!-- Message Batch Delete Confirm Modal -->
		<div class="modal-overlay" id="modal-message-batch-delete">
			<div class="modal" style="max-width: 450px">
				<div class="modal-header">
					<span class="modal-title">批量删除消息</span>
					<button class="modal-close" id="modal-message-batch-delete-close">&times;</button>
				</div>
				<div class="modal-body">
					<p style="font-size: 0.9rem; color: var(--text-primary); margin-bottom: 12px">
						确定要删除选中的
						<strong id="message-batch-delete-count">0</strong>
						条消息吗？
					</p>
					<p style="font-size: 0.9rem; color: var(--error-color); margin-bottom: 12px">⚠️ 此操作不可撤销！</p>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-message-batch-delete-cancel">取消</button>
					<button
						class="btn btn-primary"
						id="modal-message-batch-delete-confirm"
						style="background: var(--error-color)">
						确认删除
					</button>
				</div>
			</div>
		</div>

		<!-- Avatar Selector Modal -->
		<div class="modal-overlay" id="modal-avatar-selector">
			<div class="modal" style="max-width: 600px">
				<div class="modal-header">
					<span class="modal-title">选择角色头像</span>
					<button class="modal-close" id="modal-avatar-selector-close">&times;</button>
				</div>
				<div class="modal-body">
					<div class="avatar-selector-grid" id="avatar-selector-grid">
						<!-- Portrait options will be populated dynamically -->
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-avatar-selector-cancel">取消</button>
				</div>
			</div>
		</div>

		<!-- Character Rename Modal -->
		<div class="modal-overlay" id="modal-rename">
			<div class="modal" style="max-width: 400px">
				<div class="modal-header">
					<span class="modal-title">角色重命名</span>
					<button class="modal-close" id="modal-rename-close">&times;</button>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label class="form-label">角色名称</label>
						<input type="text" class="form-input" id="rename-character-name" placeholder="输入角色名称..." />
					</div>
					<div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 8px">
						<p>• 如果新名称与现有角色相同，将合并立绘和消息</p>
						<p>• 立绘列表相同时直接合并，不同时会顺延添加</p>
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-rename-cancel">取消</button>
					<button class="btn btn-primary" id="modal-rename-save">确认重命名</button>
				</div>
			</div>
		</div>

		<!-- Import Plugin Rules Modal -->
		<div class="modal-overlay" id="modal-import-rules">
			<div class="modal" style="max-width: 550px">
				<div class="modal-header">
					<span class="modal-title">语音配置管理</span>
					<button class="modal-close" id="modal-import-rules-close">&times;</button>
				</div>
				<div class="modal-body">
					<!-- 快捷操作按钮 -->
					<div class="form-group" style="display: flex; gap: 8px; margin-bottom: 16px">
						<button class="btn btn-secondary" id="btn-export-voice-config" style="flex: 1">📤 导出当前配置</button>
						<button class="btn btn-secondary" id="btn-reset-voice-config" style="flex: 1; color: var(--error-color)">
							🗑️ 重置所有语音
						</button>
					</div>

					<div style="border-top: 1px solid var(--border-color); margin: 16px 0"></div>

					<div class="form-group">
						<div
							style="
								background: var(--bg-secondary);
								padding: 12px;
								border-radius: var(--radius-md);
								margin-bottom: 12px;
								font-size: 0.85rem;
								line-height: 1.6;
							">
							<div style="font-weight: 600; margin-bottom: 8px; color: var(--primary-color)">📋 如何获取插件配置？</div>
							<ol style="margin: 0; padding-left: 20px; color: var(--text-default)">
								<li>在 CCFOLIA 房间中打开插件悬浮球</li>
								<li>
									点击
									<strong>设置</strong>
									→
									<strong>导出配置</strong>
								</li>
								<li>复制导出的 JSON 内容粘贴到下方</li>
							</ol>
							<div style="margin-top: 8px; color: var(--text-secondary); font-size: 0.8rem">
								💡 也可以直接上传 JSON 文件
							</div>
						</div>
					</div>
					<div class="form-group">
						<label class="form-label" style="display: flex; align-items: center; justify-content: space-between">
							<span>插件配置 JSON</span>
							<label class="btn btn-secondary" style="padding: 4px 10px; font-size: 0.75rem; cursor: pointer">
								📁 选择文件
								<input type="file" id="import-rules-file" accept=".json" style="display: none" />
							</label>
						</label>
						<textarea
							class="form-textarea"
							id="import-rules-json"
							placeholder="粘贴插件导出的 JSON 配置..."
							style="min-height: 150px; font-family: monospace; font-size: 0.8rem"></textarea>
					</div>
					<div id="import-rules-preview" style="display: none">
						<div class="form-group">
							<label class="form-label">检测到的语音配置</label>
							<div
								id="import-rules-list"
								style="
									max-height: 180px;
									overflow-y: auto;
									padding: 8px;
									background: var(--bg-input);
									border-radius: var(--radius-md);
									border: 1px solid var(--border-color);
								"></div>
						</div>
					</div>
					<div id="import-rules-status" style="font-size: 0.85rem; margin-top: 8px; min-height: 20px"></div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-import-rules-cancel">取消</button>
					<button class="btn btn-primary" id="modal-import-rules-confirm" disabled>导入配置</button>
				</div>
			</div>
		</div>

		<!-- Dialogue Context Menu (for dialogue box only) -->
		<div class="context-menu" id="dialogue-context-menu">
			<div class="context-menu-item" data-action="edit">✏️ 编辑消息</div>
			<div class="context-menu-item" data-action="dialogue-bg">🎨 对话框背景</div>
		</div>

		<!-- Canvas Area Context Menu (for portrait area) -->
		<div class="context-menu" id="canvas-context-menu">
			<div class="context-menu-item" data-action="stage">🎭 进退场设置</div>
			<div class="context-menu-item" data-action="background">🌄 设置背景</div>
			<div class="context-menu-item" data-action="bgm">🎵 设置BGM</div>
		</div>

		<!-- Portrait Context Menu (for portrait image) -->
		<div class="context-menu" id="portrait-context-menu">
			<div class="context-menu-item" data-action="edit-portrait">🖼️ 编辑立绘</div>
			<div class="context-menu-item" data-action="edit-tts">🔊 TTS设置</div>
		</div>

		<!-- Portrait Item Context Menu (for character detail page) -->
		<div class="context-menu" id="portrait-item-context-menu">
			<div class="context-menu-item" data-action="set-avatar">👤 设为头像</div>
			<div class="context-menu-item" data-action="preview">🔍 查看大图</div>
			<div class="context-menu-item" data-action="replace">🔄 替换差分</div>
			<div class="context-menu-divider"></div>
			<div class="context-menu-item danger" data-action="delete">🗑️ 删除差分</div>
		</div>

		<!-- Message List Context Menu -->
		<div class="context-menu" id="message-context-menu">
			<div class="context-menu-item" data-action="copy">📋 复制</div>
			<div class="context-menu-item" data-action="cut">✂️ 剪切</div>
			<div class="context-menu-item" data-action="paste" id="message-paste-item" style="display: none">
				📥 粘贴到此处
			</div>
			<div class="context-menu-divider"></div>
			<div class="context-menu-item" data-action="edit">✏️ 编辑</div>
			<div class="context-menu-item" data-action="insert">➕ 插入消息</div>
			<div class="context-menu-item" data-action="insert-dice">🎲 插入骰点</div>
			<div class="context-menu-item" data-action="reset" id="message-reset-item" style="display: none">↩️ 重置消息</div>
			<div class="context-menu-divider"></div>
			<div class="context-menu-item danger" data-action="delete">🗑️ 删除</div>
		</div>

		<!-- Quick TTS Settings Modal -->
		<div class="modal-overlay" id="modal-quick-tts">
			<div class="modal" style="width: 380px">
				<div class="modal-header">
					<h3 class="modal-title" id="quick-tts-title">TTS设置</h3>
					<button class="modal-close" id="modal-quick-tts-close">&times;</button>
				</div>
				<div class="modal-body">
					<div class="form-group">
						<label class="form-label">选择语音</label>
						<select id="quick-tts-voice" class="form-input"></select>
					</div>
					<div class="form-group">
						<label class="form-label">
							语速:
							<span id="quick-tts-rate-value">1</span>
						</label>
						<input type="range" id="quick-tts-rate" class="form-range" min="0.5" max="2" step="0.1" value="1" />
					</div>
					<div class="form-group">
						<label class="form-label">
							音调:
							<span id="quick-tts-pitch-value">1</span>
						</label>
						<input type="range" id="quick-tts-pitch" class="form-range" min="0.5" max="2" step="0.1" value="1" />
					</div>
					<div class="form-group">
						<label class="form-label">
							音量:
							<span id="quick-tts-volume-value">1</span>
						</label>
						<input type="range" id="quick-tts-volume" class="form-range" min="0" max="1" step="0.1" value="1" />
					</div>
					<div style="display: flex; gap: 8px; margin-top: 12px">
						<button class="btn btn-secondary" id="quick-tts-test" style="flex: 1">🔊 试听</button>
						<button class="btn btn-secondary" id="quick-tts-reset" style="flex: 1">🔄 重置</button>
					</div>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" id="modal-quick-tts-cancel">取消</button>
					<button class="btn btn-primary" id="modal-quick-tts-save">保存</button>
				</div>
			</div>
		</div>

		<script>
			// ============================================================
			// Type Definitions (JSDoc for IDE support)
			// ============================================================

			/**
			 * @typedef {Object} VoiceConfig
			 * @property {boolean} enabled - 是否启用语音
			 * @property {string} voiceName - 语音名称
			 * @property {number} rate - 语速 0.5-2
			 * @property {number} pitch - 音调 0.5-2
			 * @property {number} volume - 音量 0-1
			 * @property {boolean} delimiterEnabled - 是否启用分隔符提取
			 * @property {string} delimiterStart - 开始分隔符
			 * @property {string} delimiterEnd - 结束分隔符
			 */

			/**
			 * @typedef {Object} SoundTrigger
			 * @property {string} id - 触发器ID
			 * @property {string} pattern - 正则表达式
			 * @property {string} audioUrl - 音效URL
			 * @property {string} name - 触发器名称
			 */

			/**
			 * @typedef {Object} CharacterCard
			 * @property {string} description - 角色描述
			 * @property {string} background - 背景故事
			 * @property {Object.<string, number>} stats - 数值属性
			 * @property {boolean} showDuringPlay - 播放时是否显示
			 */

			/**
			 * @typedef {Object} PortraitVariant
			 * @property {string} id - 立绘ID
			 * @property {string} url - 立绘URL
			 * @property {string} name - 用户命名（如"普通"、"惊讶"）
			 * @property {number} usageCount - 使用次数
			 */

			/**
			 * @typedef {Object} CharacterConfig
			 * @property {string} name - 角色名称
			 * @property {'kp' | 'npc' | 'pl' | string} type - 角色类型
			 * @property {number} messageCount - 出场次数
			 * @property {PortraitVariant[]} portraits - 所有立绘变体
			 * @property {string} defaultPortrait - 默认立绘URL
			 * @property {VoiceConfig} voice - 语音配置
			 * @property {SoundTrigger[]} soundTriggers - 音效触发器
			 * @property {CharacterCard|null} card - 角色卡
			 */

			/**
			 * @typedef {Object} GlobalTTSSettings
			 * @property {boolean} enabled - 全局开关
			 * @property {'parallel' | 'sequential'} mode - 与打字机的协调模式
			 * @property {VoiceConfig} defaultVoice - 默认语音配置
			 * @property {boolean} autoAdvance - TTS完成后自动前进
			 */

			/**
			 * @typedef {Object} BGMSettings
			 * @property {string} defaultBgmUrl - 默认 BGM URL
			 * @property {number} volume - 音量 (0-1)
			 * @property {boolean} muted - 是否静音
			 * @property {boolean} loop - 是否循环播放
			 * @property {number} fadeInDuration - 淡入时长（毫秒）
			 * @property {number} fadeOutDuration - 淡出时长（毫秒）
			 */

			/**
			 * @typedef {Object} BGMLibraryItem
			 * @property {string} id - 唯一标识符
			 * @property {string} name - 显示名称
			 * @property {string} url - BGM URL
			 * @property {'ccfolia' | 'custom'} source - 来源类型
			 * @property {string} [sceneName] - 场景名（仅 ccfolia 来源）
			 */

			/**
			 * @typedef {Object} DiceInfo
			 * @property {string} result - 骰子结果文本
			 * @property {boolean} isSuccess - 是否成功
			 * @property {boolean} isFailure - 是否失败
			 * @property {boolean} isCritical - 是否大成功
			 * @property {boolean} isFumble - 是否大失败
			 */

			/**
			 * @typedef {Object} Message
			 * @property {string} id - 唯一标识符
			 * @property {'dialogue' | 'narration' | 'system'} type - 消息类型
			 * @property {string} name - 角色名
			 * @property {string} text - 消息内容
			 * @property {string} iconUrl - 立绘/头像URL
			 * @property {string} color - 角色颜色
			 * @property {string} channelName - 频道名
			 * @property {number} timestamp - 时间戳
			 * @property {DiceInfo} [diceInfo] - 骰子信息
			 * @property {boolean} [isEdited] - 是否已编辑
			 * @property {boolean} [isInserted] - 是否为插入的消息
			 * @property {string} [backgroundUrl] - 背景切换点
			 * @property {string} [bgmUrl] - BGM 切换点（空字符串表示停止 BGM）
			 * @property {string[]} [stageEnter] - 进场角色列表
			 * @property {string[]} [stageExit] - 退场角色列表
			 */

			/**
			 * @typedef {Object} FilterRules
			 * @property {boolean} removeEmpty - 是否过滤空白消息
			 * @property {boolean} useOnOffMarkers - 是否使用标记区间过滤
			 * @property {string} markerStart - 开始标记关键词
			 * @property {string} markerEnd - 结束标记关键词
			 * @property {string[]} prefixBlacklist - 前缀黑名单
			 * @property {string[]} channelBlacklist - 频道黑名单
			 */

			/**
			 * @typedef {Object} PortraitPosition
			 * @property {number} x - X坐标（百分比 0-100）
			 * @property {number} y - Y坐标（百分比 0-100）
			 * @property {number} width - 宽度（百分比 0-100）
			 * @property {number} height - 高度（百分比 0-100）
			 */

			/**
			 * @typedef {Object} StageConfig
			 * @property {string} fromMessageId - 起始消息ID
			 * @property {string} toMessageId - 结束消息ID
			 * @property {string[]} characters - 出场角色列表
			 */

			/**
			 * @typedef {Object} PortraitConfig
			 * @property {'percent' | 'canvas'} scaleMode - 缩放模式：percent=百分比自适应，canvas=固定画布等比缩放
			 * @property {number} canvasWidth - 画布设计宽度（canvas模式）
			 * @property {number} canvasHeight - 画布设计高度（canvas模式）
			 * @property {Object.<string, PortraitPosition>} positions - 角色位置配置
			 * @property {StageConfig[]} stageConfig - 时间段出场配置
			 */

			/**
			 * @typedef {Object} EditorSettings
			 * @property {number} typingSpeed - 打字机速度（毫秒/字）
			 * @property {string} defaultBackground - 默认背景URL
			 */

			/**
			 * @typedef {Object} EditorMeta
			 * @property {string} roomId - 房间号
			 * @property {number} createdAt - 创建时间
			 * @property {number} lastModified - 最后修改时间
			 */

			/**
			 * @typedef {Object} EditorState
			 * @property {Message[]} originalMessages - 原始消息列表
			 * @property {Message[]} editedMessages - 编辑后的消息列表
			 * @property {Set<string>} deletedIds - 已删除的消息ID集合
			 * @property {FilterRules} filterRules - 过滤规则
			 * @property {PortraitConfig} portraitConfig - 立绘配置
			 * @property {EditorSettings} settings - 全局设置
			 * @property {EditorMeta} meta - 元数据
			 */

			// ============================================================
			// Global State
			// ============================================================

			/** @type {EditorState} */
			const state = {
				originalMessages: [],
				editedMessages: [],
				deletedIds: new Set(),
				filterRules: {
					removeEmpty: true,
					useOnOffMarkers: false,
					markerStart: "on",
					markerEnd: "off",
					prefixBlacklist: [],
					channelBlacklist: [],
				},
				houseRules: {
					criticalMin: 1,
					criticalMax: 5,
					fumbleMin: 96,
					fumbleMax: 100,
				},
				portraitConfig: {
					scaleMode: "canvas", // "percent" 或 "canvas"
					canvasWidth: 1920,
					canvasHeight: 1080,
					positions: {},
					stageConfig: [],
					dialogueStyle: {
						fontSize: 24,
						nameSize: 20,
						bgOpacity: 70,
						bgImage: "", // 背景图片 URL
						height: 150,
						paddingX: 20, // 左右内边距
						paddingY: 16, // 上下内边距
						// Position as percentage of canvas (null = default bottom)
						x: null,
						y: null,
						width: 100, // percentage of canvas width
						// 文字样式
						nameColor: "#ffffff",
						textColor: "#ffffff",
						fontFamily: "",
						// 角色特定样式
						characterStyles: {},
					},
				},
				settings: {
					typingSpeed: 50,
					defaultBackground: "",
				},
				/** @type {Object.<string, CharacterConfig>} */
				characters: {},
				/** @type {GlobalTTSSettings} */
				ttsSettings: {
					enabled: false,
					mode: "parallel",
					defaultVoice: {
						enabled: true,
						voiceName: "",
						rate: 1,
						pitch: 1,
						volume: 1,
						delimiterEnabled: false,
						delimiterStart: "「",
						delimiterEnd: "」",
					},
					autoAdvance: true,
				},
				/** @type {BGMSettings} */
				bgmSettings: {
					defaultBgmUrl: "",
					volume: 0.5,
					muted: false,
					loop: true,
					fadeInDuration: 1000,
					fadeOutDuration: 1000,
				},
				/** @type {BGMLibraryItem[]} */
				bgmLibrary: [],
				/** @type {CustomCategory[]} */
				customCategories: [],
				meta: {
					roomId: "",
					createdAt: 0,
					lastModified: 0,
				},
			};

			/** @type {number} */
			let currentMessageIndex = 0;

			/** @type {boolean} */
			let isTyping = false;

			/** @type {boolean} - 是否正在自动播放 */
			let isAutoPlaying = false;

			/** @type {number|null} */
			let typingTimeout = null;

			/** @type {number} */
			let currentPage = 1;

			/** @type {number} */
			let pageSize = 20;

			/** @type {string} */
			let currentView = "replay"; // "replay" or "list"

			/** @type {number} */
			let dragSourceIndex = -1;

			// ============================================================
			// DOM References
			// ============================================================

			const DOM = {
				// Player elements
				player: document.getElementById("player"),
				portraitArea: document.getElementById("portrait-area"),
				portraitImg: document.getElementById("portrait-img"),
				dialogueArea: document.getElementById("dialogue-area"),
				dialogueBox: document.getElementById("dialogue-box"),
				dialogueName: document.getElementById("dialogue-name"),
				dialogueText: document.getElementById("dialogue-text"),
				dialogueContextMenu: document.getElementById("dialogue-context-menu"),
				canvasContextMenu: document.getElementById("canvas-context-menu"),
				portraitContextMenu: document.getElementById("portrait-context-menu"),
				portraitItemContextMenu: document.getElementById("portrait-item-context-menu"),
				messageContextMenu: document.getElementById("message-context-menu"),
				messagePasteItem: document.getElementById("message-paste-item"),
				modalQuickTts: document.getElementById("modal-quick-tts"),
				modalQuickTtsClose: document.getElementById("modal-quick-tts-close"),
				modalQuickTtsCancel: document.getElementById("modal-quick-tts-cancel"),
				modalQuickTtsSave: document.getElementById("modal-quick-tts-save"),
				quickTtsTitle: document.getElementById("quick-tts-title"),
				quickTtsVoice: document.getElementById("quick-tts-voice"),
				quickTtsRate: document.getElementById("quick-tts-rate"),
				quickTtsRateValue: document.getElementById("quick-tts-rate-value"),
				quickTtsPitch: document.getElementById("quick-tts-pitch"),
				quickTtsPitchValue: document.getElementById("quick-tts-pitch-value"),
				quickTtsVolume: document.getElementById("quick-tts-volume"),
				quickTtsVolumeValue: document.getElementById("quick-tts-volume-value"),
				quickTtsTest: document.getElementById("quick-tts-test"),
				quickTtsReset: document.getElementById("quick-tts-reset"),
				historyPanel: document.getElementById("history-panel"),
				historyList: document.getElementById("history-list"),
				historyClose: document.getElementById("history-close"),
				progressBar: document.getElementById("progress-bar"),
				progressFill: document.getElementById("progress-fill"),
				progressText: document.getElementById("progress-text"),

				// View switcher
				viewReplay: document.getElementById("view-replay"),
				viewList: document.getElementById("view-list"),
				viewCharacter: document.getElementById("view-character"),
				btnViewReplay: document.getElementById("btn-view-replay"),
				btnViewList: document.getElementById("btn-view-list"),
				btnViewCharacter: document.getElementById("btn-view-character"),

				// Character view
				characterGrid: document.getElementById("character-grid"),
				characterSearch: document.getElementById("character-search"),
				btnImportRules: document.getElementById("btn-import-rules"),
				characterDetailPage: document.getElementById("character-detail-page"),
				viewSwitcher: document.querySelector(".view-switcher"),

				// Message list view
				messageListFull: document.getElementById("message-list-full"),
				pageSizeSelect: document.getElementById("page-size-select"),
				paginationInfo: document.getElementById("pagination-info"),
				paginationInput: document.getElementById("pagination-input"),
				btnPageFirst: document.getElementById("btn-page-first"),
				btnPagePrev: document.getElementById("btn-page-prev"),
				btnPageNext: document.getElementById("btn-page-next"),
				btnPageLast: document.getElementById("btn-page-last"),

				// Message search
				btnMessageSearch: document.getElementById("btn-message-search"),
				btnEditMode: document.getElementById("btn-edit-mode"),
				messageSearchToolbar: document.getElementById("message-search-toolbar"),
				messageSearchCharacter: document.getElementById("message-search-character"),
				messageSearchInput: document.getElementById("message-search-input"),
				messageSearchCount: document.getElementById("message-search-count"),
				btnSearchPrev: document.getElementById("btn-search-prev"),
				btnSearchNext: document.getElementById("btn-search-next"),
				btnSearchClose: document.getElementById("btn-search-close"),

				// Modals
				modalEdit: document.getElementById("modal-edit"),
				modalEditTitle: document.getElementById("modal-edit-title"),
				modalEditClose: document.getElementById("modal-edit-close"),
				modalEditCancel: document.getElementById("modal-edit-cancel"),
				modalEditSave: document.getElementById("modal-edit-save"),
				editName: document.getElementById("edit-name"),
				editIcon: document.getElementById("edit-icon"),
				editTextGroup: document.getElementById("edit-text-group"),
				editText: document.getElementById("edit-text"),
				editDiceGroup: document.getElementById("edit-dice-group"),
				editDiceCc: document.getElementById("edit-dice-cc"),
				editDiceCcTarget: document.getElementById("edit-dice-cc-target"),
				editDiceCcRoll: document.getElementById("edit-dice-cc-roll"),
				editDiceCcName: document.getElementById("edit-dice-cc-name"),
				editDiceCcPreview: document.getElementById("edit-dice-cc-preview"),
				editDiceNormal: document.getElementById("edit-dice-normal"),
				editDiceFormula: document.getElementById("edit-dice-formula"),
				editDiceResult: document.getElementById("edit-dice-result"),
				editDiceDesc: document.getElementById("edit-dice-desc"),
				editDiceRangeHint: document.getElementById("edit-dice-range-hint"),

				modalInsert: document.getElementById("modal-insert"),
				modalInsertClose: document.getElementById("modal-insert-close"),
				modalInsertCancel: document.getElementById("modal-insert-cancel"),
				modalInsertSave: document.getElementById("modal-insert-save"),
				insertName: document.getElementById("insert-name"),
				insertIcon: document.getElementById("insert-icon"),
				insertText: document.getElementById("insert-text"),

				// Insert dice modal
				modalInsertDice: document.getElementById("modal-insert-dice"),
				modalInsertDiceClose: document.getElementById("modal-insert-dice-close"),
				modalInsertDiceCancel: document.getElementById("modal-insert-dice-cancel"),
				modalInsertDiceSave: document.getElementById("modal-insert-dice-save"),
				insertDiceName: document.getElementById("insert-dice-name"),
				insertDiceIcon: document.getElementById("insert-dice-icon"),
				insertDiceType: document.getElementById("insert-dice-type"),
				insertDiceCc: document.getElementById("insert-dice-cc"),
				insertDiceCcTarget: document.getElementById("insert-dice-cc-target"),
				insertDiceCcRoll: document.getElementById("insert-dice-cc-roll"),
				insertDiceCcSkill: document.getElementById("insert-dice-cc-skill"),
				insertDiceCcPreview: document.getElementById("insert-dice-cc-preview"),
				insertDiceNormal: document.getElementById("insert-dice-normal"),
				insertDiceFormula: document.getElementById("insert-dice-formula"),
				insertDiceResult: document.getElementById("insert-dice-result"),
				insertDiceDesc: document.getElementById("insert-dice-desc"),
				insertDiceRangeHint: document.getElementById("insert-dice-range-hint"),

				// Stage modal
				modalStage: document.getElementById("modal-stage"),
				modalStageTitle: document.getElementById("modal-stage-title"),
				modalStageClose: document.getElementById("modal-stage-close"),
				modalStageCancel: document.getElementById("modal-stage-cancel"),
				modalStageSave: document.getElementById("modal-stage-save"),
				stageEnterList: document.getElementById("stage-enter-list"),
				stageExitList: document.getElementById("stage-exit-list"),

				// Control buttons
				btnPrev: document.getElementById("btn-prev"),
				btnNext: document.getElementById("btn-next"),
				btnAutoPlay: document.getElementById("btn-auto-play"),
				btnHistory: document.getElementById("btn-history"),

				// Editor panel
				editorPanel: document.getElementById("editor-panel"),
				editorToggle: document.getElementById("editor-toggle"),

				// Form inputs
				inputRoom: document.getElementById("input-room"),
				filterEmpty: document.getElementById("filter-empty"),
				filterOnOff: document.getElementById("filter-onoff"),
				onoffSettings: document.getElementById("onoff-settings"),
				markerStart: document.getElementById("marker-start"),
				markerEnd: document.getElementById("marker-end"),
				prefixTags: document.getElementById("prefix-tags"),
				prefixInput: document.getElementById("prefix-input"),
				addPrefixBtn: document.getElementById("add-prefix-btn"),
				channelCheckboxes: document.getElementById("channel-checkboxes"),
				filterStats: document.getElementById("filter-stats"),
				scaleMode: document.getElementById("scale-mode"),
				canvasSettings: document.getElementById("canvas-settings"),
				canvasWidth: document.getElementById("canvas-width"),
				canvasHeight: document.getElementById("canvas-height"),
				canvasPreset: document.getElementById("canvas-preset"),
				dialogueFontSize: document.getElementById("dialogue-font-size"),
				dialogueNameSize: document.getElementById("dialogue-name-size"),
				dialogueBgOpacity: document.getElementById("dialogue-bg-opacity"),
				dialogueBgOpacityValue: document.getElementById("dialogue-bg-opacity-value"),
				dialogueBgImage: document.getElementById("dialogue-bg-image"),
				dialogueHeight: document.getElementById("dialogue-height"),
				dialoguePaddingX: document.getElementById("dialogue-padding-x"),
				dialoguePaddingY: document.getElementById("dialogue-padding-y"),
				dialogueNameColor: document.getElementById("dialogue-name-color"),
				dialogueNameColorText: document.getElementById("dialogue-name-color-text"),
				dialogueTextColor: document.getElementById("dialogue-text-color"),
				dialogueTextColorText: document.getElementById("dialogue-text-color-text"),
				dialogueFontFamily: document.getElementById("dialogue-font-family"),
				characterStyleList: document.getElementById("character-style-list"),
				btnResetDialoguePos: document.getElementById("btn-reset-dialogue-pos"),
				multiModeSettings: document.getElementById("multi-mode-settings"),
				btnResetPositions: document.getElementById("btn-reset-positions"),
				defaultBg: document.getElementById("default-bg"),
				backgroundSwitchList: document.getElementById("background-switch-list"),

				// Background modal
				modalBackground: document.getElementById("modal-background"),
				modalBackgroundTitle: document.getElementById("modal-background-title"),
				modalBackgroundClose: document.getElementById("modal-background-close"),
				modalBackgroundCancel: document.getElementById("modal-background-cancel"),
				modalBackgroundRemove: document.getElementById("modal-background-remove"),
				modalBackgroundSave: document.getElementById("modal-background-save"),
				backgroundUrlInput: document.getElementById("background-url-input"),
				backgroundPreview: document.getElementById("background-preview"),

				// BGM modal
				modalBgm: document.getElementById("modal-bgm"),
				modalBgmTitle: document.getElementById("modal-bgm-title"),
				modalBgmClose: document.getElementById("modal-bgm-close"),
				modalBgmCancel: document.getElementById("modal-bgm-cancel"),
				modalBgmStop: document.getElementById("modal-bgm-stop"),
				modalBgmRemove: document.getElementById("modal-bgm-remove"),
				modalBgmSave: document.getElementById("modal-bgm-save"),
				bgmModalSelect: document.getElementById("bgm-modal-select"),
				bgmPreviewBtn: document.getElementById("bgm-preview-btn"),
				bgmPreviewStatus: document.getElementById("bgm-preview-status"),
				bgmPreviewVolume: document.getElementById("bgm-preview-volume"),

				// BGM config panel
				defaultBgmSelect: document.getElementById("default-bgm-select"),
				bgmMuteBtn: document.getElementById("bgm-mute-btn"),
				bgmVolumeSlider: document.getElementById("bgm-volume-slider"),
				bgmVolumeValue: document.getElementById("bgm-volume-value"),
				bgmLoopCheckbox: document.getElementById("bgm-loop-checkbox"),
				bgmSwitchList: document.getElementById("bgm-switch-list"),
				bgmLibraryList: document.getElementById("bgm-library-list"),
				btnBgmImport: document.getElementById("btn-bgm-import"),
				btnBgmAccount: document.getElementById("btn-bgm-account"),
				btnBgmCustom: document.getElementById("btn-bgm-custom"),

				// Category modals
				modalAddCategory: document.getElementById("modal-add-category"),
				modalCategoryClose: document.getElementById("modal-category-close"),
				modalCategoryCancel: document.getElementById("modal-category-cancel"),
				modalCategorySave: document.getElementById("modal-category-save"),
				categoryNameInput: document.getElementById("category-name-input"),
				modalDeleteCategory: document.getElementById("modal-delete-category"),
				modalDeleteCategoryClose: document.getElementById("modal-delete-category-close"),
				modalDeleteCategoryCancel: document.getElementById("modal-delete-category-cancel"),
				modalDeleteCategoryConfirm: document.getElementById("modal-delete-category-confirm"),
				deleteCategoryName: document.getElementById("delete-category-name"),

				// Batch selection modals
				modalBatchCategory: document.getElementById("modal-batch-category"),
				modalBatchCategoryClose: document.getElementById("modal-batch-category-close"),
				modalBatchCategoryCancel: document.getElementById("modal-batch-category-cancel"),
				modalBatchDelete: document.getElementById("modal-batch-delete"),
				modalBatchDeleteClose: document.getElementById("modal-batch-delete-close"),
				modalBatchDeleteCancel: document.getElementById("modal-batch-delete-cancel"),
				modalBatchDeleteConfirm: document.getElementById("modal-batch-delete-confirm"),

				// Rename modal
				modalRename: document.getElementById("modal-rename"),
				modalRenameClose: document.getElementById("modal-rename-close"),
				modalRenameCancel: document.getElementById("modal-rename-cancel"),
				modalRenameSave: document.getElementById("modal-rename-save"),
				renameCharacterName: document.getElementById("rename-character-name"),

				// Avatar selector modal
				modalAvatarSelector: document.getElementById("modal-avatar-selector"),
				modalAvatarSelectorClose: document.getElementById("modal-avatar-selector-close"),
				modalAvatarSelectorCancel: document.getElementById("modal-avatar-selector-cancel"),
				avatarSelectorGrid: document.getElementById("avatar-selector-grid"),

				// Message batch selection
				btnMessageBatchMode: document.getElementById("btn-message-batch-mode"),
				messageBatchToolbar: document.getElementById("message-batch-toolbar"),
				btnMessageSelectAll: document.getElementById("btn-message-select-all"),
				btnMessageDeselectAll: document.getElementById("btn-message-deselect-all"),
				btnMessageBatchCopy: document.getElementById("btn-message-batch-copy"),
				btnMessageBatchCut: document.getElementById("btn-message-batch-cut"),
				btnMessageBatchDelete: document.getElementById("btn-message-batch-delete"),
				btnMessageBatchClose: document.getElementById("btn-message-batch-close"),

				// Message batch delete modal
				modalMessageBatchDelete: document.getElementById("modal-message-batch-delete"),
				modalMessageBatchDeleteClose: document.getElementById("modal-message-batch-delete-close"),
				modalMessageBatchDeleteCancel: document.getElementById("modal-message-batch-delete-cancel"),
				modalMessageBatchDeleteConfirm: document.getElementById("modal-message-batch-delete-confirm"),
				messageBatchDeleteCount: document.getElementById("message-batch-delete-count"),

				// Quick portrait edit modal
				modalQuickPortraitEdit: document.getElementById("modal-quick-portrait-edit"),
				modalQuickPortraitEditClose: document.getElementById("modal-quick-portrait-edit-close"),
				modalQuickPortraitEditCancel: document.getElementById("modal-quick-portrait-edit-cancel"),
				quickPortraitCharacterName: document.getElementById("quick-portrait-character-name"),
				quickPortraitMessageText: document.getElementById("quick-portrait-message-text"),
				quickPortraitSelectorGrid: document.getElementById("quick-portrait-selector-grid"),
				batchDeleteCharCount: document.getElementById("batch-delete-char-count"),
				batchDeleteMsgCount: document.getElementById("batch-delete-msg-count"),

				// BGM import modals
				modalBgmImport: document.getElementById("modal-bgm-import"),
				modalBgmImportClose: document.getElementById("modal-bgm-import-close"),
				modalBgmImportCancel: document.getElementById("modal-bgm-import-cancel"),
				modalBgmImportConfirm: document.getElementById("modal-bgm-import-confirm"),
				bgmImportRoomId: document.getElementById("bgm-import-room-id"),
				bgmImportFetchBtn: document.getElementById("bgm-import-fetch-btn"),
				bgmImportList: document.getElementById("bgm-import-list"),
				bgmImportStatus: document.getElementById("bgm-import-status"),
				modalBgmCustom: document.getElementById("modal-bgm-custom"),
				modalBgmCustomClose: document.getElementById("modal-bgm-custom-close"),
				modalBgmCustomCancel: document.getElementById("modal-bgm-custom-cancel"),
				modalBgmCustomSave: document.getElementById("modal-bgm-custom-save"),
				bgmCustomName: document.getElementById("bgm-custom-name"),
				bgmCustomUrl: document.getElementById("bgm-custom-url"),

				// Account BGM import modal
				modalBgmAccount: document.getElementById("modal-bgm-account"),
				modalBgmAccountClose: document.getElementById("modal-bgm-account-close"),
				modalBgmAccountCancel: document.getElementById("modal-bgm-account-cancel"),
				modalBgmAccountConfirm: document.getElementById("modal-bgm-account-confirm"),
				accountEmail: document.getElementById("account-email"),
				accountPassword: document.getElementById("account-password"),
				accountLoginBtn: document.getElementById("account-login-btn"),
				accountLoginStatus: document.getElementById("account-login-status"),
				accountLoginForm: document.getElementById("account-login-form"),
				accountMediaSection: document.getElementById("account-media-section"),
				accountMediaList: document.getElementById("account-media-list"),
				accountMediaStatus: document.getElementById("account-media-status"),
				accountSelectAllBtn: document.getElementById("account-select-all-btn"),

				// Import plugin rules modal
				modalImportRules: document.getElementById("modal-import-rules"),
				modalImportRulesClose: document.getElementById("modal-import-rules-close"),
				modalImportRulesCancel: document.getElementById("modal-import-rules-cancel"),
				modalImportRulesConfirm: document.getElementById("modal-import-rules-confirm"),
				importRulesJson: document.getElementById("import-rules-json"),
				importRulesFile: document.getElementById("import-rules-file"),
				importRulesPreview: document.getElementById("import-rules-preview"),
				importRulesList: document.getElementById("import-rules-list"),
				importRulesStatus: document.getElementById("import-rules-status"),
				btnExportVoiceConfig: document.getElementById("btn-export-voice-config"),
				btnResetVoiceConfig: document.getElementById("btn-reset-voice-config"),

				// Category filter elements
				characterFilterTabs: document.getElementById("character-filter-tabs"),
				filterMoreDropdown: document.getElementById("filter-more-dropdown"),
				filterMoreBtn: document.getElementById("filter-more-btn"),
				filterMoreMenu: document.getElementById("filter-more-menu"),
				btnAddCategory: document.getElementById("btn-add-category"),

				// Buttons
				btnFetch: document.getElementById("btn-fetch"),
				btnApplyFilter: document.getElementById("btn-apply-filter"),
				btnImport: document.getElementById("btn-import"),
				btnSave: document.getElementById("btn-save"),
				btnExportLog: document.getElementById("btn-export-log"),

				// House rules (村规)
				criticalMin: document.getElementById("critical-min"),
				criticalMax: document.getElementById("critical-max"),
				fumbleMin: document.getElementById("fumble-min"),
				fumbleMax: document.getElementById("fumble-max"),
				btnApplyHouseRules: document.getElementById("btn-apply-house-rules"),
				btnResetHouseRules: document.getElementById("btn-reset-house-rules"),
				houseRulesStats: document.getElementById("house-rules-stats"),
			};

			// ============================================================
			// Utility Functions
			// ============================================================

			/**
			 * Escape HTML special characters to prevent XSS
			 * @param {string} str - String to escape
			 * @returns {string} - Escaped string
			 */
			function escapeHtml(str) {
				if (!str) return "";
				const div = document.createElement("div");
				div.textContent = str;
				return div.innerHTML;
			}

			/**
			 * Escape string for use in HTML attributes (especially onclick handlers)
			 * Handles quotes and special characters that could break attribute syntax
			 * @param {string} str - String to escape
			 * @returns {string} - Escaped string safe for HTML attributes
			 */
			function escapeAttr(str) {
				if (!str) return "";
				return str
					.replace(/&/g, "&amp;")
					.replace(/'/g, "&#39;")
					.replace(/"/g, "&quot;")
					.replace(/</g, "&lt;")
					.replace(/>/g, "&gt;");
			}

			/**
			 * Setup modal overlay click-to-close with drag protection
			 * Only closes if mousedown and mouseup both happen on the overlay
			 * @param {HTMLElement} modal - Modal overlay element
			 * @param {Function} closeFunc - Function to close the modal
			 */
			function setupModalOverlayClose(modal, closeFunc) {
				let mouseDownOnOverlay = false;

				modal.addEventListener("mousedown", (e) => {
					mouseDownOnOverlay = e.target === modal;
				});

				modal.addEventListener("mouseup", (e) => {
					if (mouseDownOnOverlay && e.target === modal) {
						closeFunc();
					}
					mouseDownOnOverlay = false;
				});
			}

			/**
			 * Generate a unique ID
			 * @returns {string}
			 */
			function generateId() {
				return Date.now().toString(36) + Math.random().toString(36).substring(2);
			}

			/**
			 * Debounce function to limit execution rate
			 * @param {Function} func - Function to debounce
			 * @param {number} wait - Wait time in milliseconds
			 * @returns {Function}
			 */
			function debounce(func, wait) {
				let timeout;
				return function executedFunction(...args) {
					const later = () => {
						clearTimeout(timeout);
						func(...args);
					};
					clearTimeout(timeout);
					timeout = setTimeout(later, wait);
				};
			}

			/**
			 * Create a default message object
			 * @param {'dialogue' | 'narration' | 'system'} type
			 * @returns {Message}
			 */
			function createMessage(type) {
				return {
					id: generateId(),
					type,
					name: type === "narration" ? "" : type === "system" ? "System" : "",
					text: "",
					iconUrl: "",
					color: "",
					channelName: "",
					timestamp: Date.now(),
					isInserted: true,
				};
			}

			// ============================================================
			// Prefix Tags Management
			// ============================================================

			/**
			 * Render prefix tags in the UI
			 */
			function renderPrefixTags() {
				const container = DOM.prefixTags;
				if (!container) return;

				container.innerHTML = "";

				state.filterRules.prefixBlacklist.forEach((prefix) => {
					const tag = document.createElement("div");
					tag.className = "prefix-tag";
					tag.innerHTML = `
						<span>${escapeHtml(prefix)}</span>
						<span class="prefix-tag-remove" data-prefix="${escapeHtml(prefix)}">&times;</span>
					`;
					container.appendChild(tag);
				});

				// Add event listeners for remove buttons
				container.querySelectorAll(".prefix-tag-remove").forEach((btn) => {
					btn.addEventListener("click", (e) => {
						const prefix = e.target.dataset.prefix;
						removePrefixTag(prefix);
					});
				});
			}

			/**
			 * Add a new prefix tag
			 * @param {string} prefix - Prefix to add
			 */
			function addPrefixTag(prefix) {
				const trimmed = prefix.trim();
				if (!trimmed) return;

				// Check if already exists
				if (state.filterRules.prefixBlacklist.includes(trimmed)) {
					return;
				}

				state.filterRules.prefixBlacklist.push(trimmed);
				renderPrefixTags();
				savePrefixBlacklist();
			}

			/**
			 * Remove a prefix tag
			 * @param {string} prefix - Prefix to remove
			 */
			function removePrefixTag(prefix) {
				const index = state.filterRules.prefixBlacklist.indexOf(prefix);
				if (index > -1) {
					state.filterRules.prefixBlacklist.splice(index, 1);
					renderPrefixTags();
					savePrefixBlacklist();
				}
			}

			/**
			 * Save prefix blacklist to localStorage
			 */
			function savePrefixBlacklist() {
				try {
					localStorage.setItem("ccfolia-replay-prefix-blacklist", JSON.stringify(state.filterRules.prefixBlacklist));
				} catch (e) {
					console.warn("Failed to save prefix blacklist:", e);
				}
			}

			/**
			 * Load prefix blacklist from localStorage
			 */
			function loadPrefixBlacklist() {
				try {
					const saved = localStorage.getItem("ccfolia-replay-prefix-blacklist");
					if (saved) {
						const parsed = JSON.parse(saved);
						if (Array.isArray(parsed)) {
							state.filterRules.prefixBlacklist = parsed;
							renderPrefixTags();
						}
					}
				} catch (e) {
					console.warn("Failed to load prefix blacklist:", e);
				}
			}

			/**
			 * Save filter options to localStorage
			 */
			function saveFilterOptions() {
				try {
					const options = {
						removeEmpty: state.filterRules.removeEmpty,
						useOnOffMarkers: state.filterRules.useOnOffMarkers,
						markerStart: state.filterRules.markerStart,
						markerEnd: state.filterRules.markerEnd,
					};
					localStorage.setItem("ccfolia-replay-filter-options", JSON.stringify(options));
				} catch (e) {
					console.warn("Failed to save filter options:", e);
				}
			}

			/**
			 * Load filter options from localStorage
			 */
			function loadFilterOptions() {
				try {
					const saved = localStorage.getItem("ccfolia-replay-filter-options");
					if (saved) {
						const options = JSON.parse(saved);
						if (typeof options.removeEmpty === "boolean") {
							state.filterRules.removeEmpty = options.removeEmpty;
							DOM.filterEmpty.checked = options.removeEmpty;
						}
						if (typeof options.useOnOffMarkers === "boolean") {
							state.filterRules.useOnOffMarkers = options.useOnOffMarkers;
							DOM.filterOnOff.checked = options.useOnOffMarkers;
							// Show/hide onoff settings based on checkbox
							DOM.onoffSettings.style.display = options.useOnOffMarkers ? "block" : "none";
						}
						if (options.markerStart) {
							state.filterRules.markerStart = options.markerStart;
							DOM.markerStart.value = options.markerStart;
						}
						if (options.markerEnd) {
							state.filterRules.markerEnd = options.markerEnd;
							DOM.markerEnd.value = options.markerEnd;
						}
					}
				} catch (e) {
					console.warn("Failed to load filter options:", e);
				}
			}

			/**
			 * Escape HTML to prevent XSS
			 * @param {string} text - Text to escape
			 * @returns {string} Escaped text
			 */
			function escapeHtml(text) {
				const div = document.createElement("div");
				div.textContent = text;
				return div.innerHTML;
			}

			// Initialize prefix tags management
			DOM.addPrefixBtn.addEventListener("click", () => {
				const input = DOM.prefixInput;
				const prefix = input.value.trim();
				if (prefix) {
					addPrefixTag(prefix);
					input.value = "";
				}
			});

			DOM.prefixInput.addEventListener("keypress", (e) => {
				if (e.key === "Enter") {
					e.preventDefault();
					const prefix = e.target.value.trim();
					if (prefix) {
						addPrefixTag(prefix);
						e.target.value = "";
					}
				}
			});

			// Load saved prefix blacklist on page load
			loadPrefixBlacklist();

			// Load saved filter options on page load
			loadFilterOptions();

			// ============================================================
			// Data Layer - API Functions
			// ============================================================

			/**
			 * Extract room ID from URL or direct input
			 * Supports formats:
			 * - Pure room ID: "abc123xyz"
			 * - Full URL: "https://ccfolia.com/rooms/abc123xyz"
			 * - URL with path: "https://ccfolia.com/rooms/abc123xyz/..."
			 * @param {string} input - Room URL or ID
			 * @returns {string|null} - Extracted room ID or null if invalid
			 */
			function extractRoomId(input) {
				if (!input || typeof input !== "string") {
					return null;
				}

				const trimmed = input.trim();
				if (!trimmed) {
					return null;
				}

				// Try to match URL pattern: ccfolia.com/rooms/{roomId}
				const urlPattern = /ccfolia\.com\/rooms\/([a-zA-Z0-9_-]+)/;
				const urlMatch = trimmed.match(urlPattern);
				if (urlMatch) {
					return urlMatch[1];
				}

				// If not a URL, check if it looks like a valid room ID
				// Room IDs are alphanumeric with possible underscores/hyphens
				const roomIdPattern = /^[a-zA-Z0-9_-]+$/;
				if (roomIdPattern.test(trimmed)) {
					return trimmed;
				}

				return null;
			}

			/**
			 * Fetch room logs from CCFOLIA Firestore API
			 * @param {string} roomId - The room ID to fetch logs from
			 * @returns {Promise<Object[]>} - Raw Firestore documents
			 */
			async function fetchRoomLogs(roomId) {
				const baseUrl = `https://firestore.googleapis.com/v1/projects/ccfolia-160aa/databases/(default)/documents/rooms/${roomId}/messages`;
				let allLogs = [];
				let pageToken = "";
				let hasMore = true;

				while (hasMore) {
					let url = `${baseUrl}?pageSize=500`;
					if (pageToken) {
						url += `&pageToken=${pageToken}`;
					}

					const response = await fetch(url);

					if (!response.ok) {
						if (response.status === 404) {
							throw new Error("房间不存在，请检查房间号");
						} else if (response.status === 403) {
							throw new Error("无权访问该房间，可能需要登录 CCFOLIA");
						}
						throw new Error(`API 错误: ${response.status}`);
					}

					const data = await response.json();

					if (data.documents) {
						allLogs = allLogs.concat(data.documents);
					}

					if (data.nextPageToken) {
						pageToken = data.nextPageToken;
					} else {
						hasMore = false;
					}
				}

				return allLogs;
			}

			/**
			 * Extract value from Firestore field format
			 * @param {Object} obj - Firestore field object
			 * @returns {*} - Extracted value
			 */
			function getFirestoreValue(obj) {
				if (!obj) return null;
				return obj.stringValue ?? obj.booleanValue ?? obj.integerValue ?? obj.timestampValue ?? null;
			}

			/**
			 * Parse raw Firestore documents into Message format
			 * @param {Object[]} rawDocuments - Raw Firestore documents
			 * @returns {Message[]} - Parsed messages
			 */
			function parseLogs(rawDocuments) {
				return rawDocuments
					.map((doc) => {
						const f = doc.fields || {};

						// Extract dice info if present
						let diceInfo = null;
						if (f.extend?.mapValue?.fields?.roll) {
							const roll = f.extend.mapValue.fields.roll.mapValue?.fields;
							if (roll) {
								diceInfo = {
									result: getFirestoreValue(roll.result) || "",
									isSuccess: getFirestoreValue(roll.success) || false,
									isFailure: getFirestoreValue(roll.failure) || false,
									isCritical: getFirestoreValue(roll.critical) || false,
									isFumble: getFirestoreValue(roll.fumble) || false,
								};
							}
						}

						// Extract document ID from path
						const id = doc.name ? doc.name.split("/").pop() : generateId();

						// Parse timestamp
						const createdAtValue = getFirestoreValue(f.createdAt);
						let timestamp = Date.now();
						if (createdAtValue) {
							const parsed = new Date(createdAtValue).getTime();
							if (!isNaN(parsed)) {
								timestamp = parsed;
							}
						}

						return {
							id,
							type: "dialogue",
							text: getFirestoreValue(f.text) || "",
							name: getFirestoreValue(f.name) || "",
							channelName: getFirestoreValue(f.channelName) || "Main",
							iconUrl: getFirestoreValue(f.iconUrl) || "",
							color: getFirestoreValue(f.color) || "#888888",
							timestamp,
							diceInfo,
							isEdited: false,
							isInserted: false,
						};
					})
					.sort((a, b) => a.timestamp - b.timestamp);
			}

			// ============================================================
			// Editor Panel Toggle
			// ============================================================

			const editorOverlay = document.getElementById("editor-overlay");

			// Track if user wants the drawer closed (unified state for both mobile and desktop)
			// Default to closed
			let editorPanelClosed = true;

			function isMobile() {
				return window.innerWidth <= 768;
			}

			function updateEditorPanelState() {
				if (isMobile()) {
					// Mobile: use open class and overlay
					DOM.editorPanel.classList.remove("collapsed");
					if (editorPanelClosed) {
						DOM.editorPanel.classList.remove("open");
						editorOverlay.classList.remove("visible");
						DOM.editorToggle.textContent = "◀";
					} else {
						DOM.editorPanel.classList.add("open");
						editorOverlay.classList.add("visible");
						DOM.editorToggle.textContent = "▶";
					}
				} else {
					// Desktop: use collapsed class
					DOM.editorPanel.classList.remove("open");
					editorOverlay.classList.remove("visible");
					if (editorPanelClosed) {
						DOM.editorPanel.classList.add("collapsed");
						DOM.editorToggle.textContent = "▶";
					} else {
						DOM.editorPanel.classList.remove("collapsed");
						DOM.editorToggle.textContent = "◀";
					}
				}
			}

			function toggleEditorPanel() {
				editorPanelClosed = !editorPanelClosed;
				updateEditorPanelState();
				// Smoothly update canvas position during drawer animation
				if (state.portraitConfig.scaleMode === "canvas") {
					animateCanvasDuringDrawerTransition();
				}
			}

			/**
			 * Animate canvas position during drawer transition
			 * Uses requestAnimationFrame to smoothly update canvas position
			 * Canvas size stays fixed, only position changes
			 */
			function animateCanvasDuringDrawerTransition() {
				// Temporarily disable CSS transition for smoother RAF animation
				const canvasInner = DOM.portraitArea.querySelector(".portrait-canvas-inner");
				if (canvasInner) {
					canvasInner.style.transition = "none";
				}

				const transitionDuration = 300; // matches --transition-speed: 0.3s
				const startTime = performance.now();

				function animate(currentTime) {
					const elapsed = currentTime - startTime;
					if (elapsed < transitionDuration) {
						updateCanvasPosition();
						requestAnimationFrame(animate);
					} else {
						// Final update and restore CSS transition
						updateCanvasPosition();
						if (canvasInner) {
							canvasInner.style.transition = "";
						}
					}
				}

				requestAnimationFrame(animate);
			}

			DOM.editorToggle.addEventListener("click", toggleEditorPanel);

			// 点击遮罩层关闭面板
			editorOverlay.addEventListener("click", () => {
				editorPanelClosed = true;
				updateEditorPanelState();
				// Smoothly update canvas position during drawer animation
				if (state.portraitConfig.scaleMode === "canvas") {
					animateCanvasDuringDrawerTransition();
				}
			});

			// 窗口大小变化时更新状态
			window.addEventListener("resize", () => {
				// Only update if not in character view
				if (currentView !== "character") {
					updateEditorPanelState();
				}
			});

			// ============================================================
			// History Panel Toggle
			// ============================================================

			DOM.btnHistory.addEventListener("click", () => {
				DOM.historyPanel.classList.toggle("visible");
				if (DOM.historyPanel.classList.contains("visible")) {
					renderHistoryPanel();
				}
			});

			DOM.historyClose.addEventListener("click", () => {
				DOM.historyPanel.classList.remove("visible");
			});

			// Close history panel when clicking outside
			DOM.historyPanel.addEventListener("click", (e) => {
				if (e.target === DOM.historyPanel) {
					DOM.historyPanel.classList.remove("visible");
				}
			});

			// ============================================================
			// Placeholder Event Listeners (to be implemented in later tasks)
			// ============================================================

			// ============================================================
			// Data Fetch UI Handler
			// ============================================================

			/**
			 * Show loading state in the UI
			 * @param {string} message - Loading message to display
			 */
			function showLoading(message) {
				DOM.btnFetch.disabled = true;
				DOM.btnFetch.textContent = message;
			}

			/**
			 * Hide loading state
			 */
			function hideLoading() {
				DOM.btnFetch.disabled = false;
				DOM.btnFetch.textContent = "获取日志";
			}

			/**
			 * Show error message with retry button
			 * @param {string} message - Error message
			 */
			function showError(message) {
				// Create or update error element
				let errorEl = document.getElementById("fetch-error");
				if (!errorEl) {
					errorEl = document.createElement("div");
					errorEl.id = "fetch-error";
					errorEl.style.cssText = "margin-top: 8px;";
					DOM.btnFetch.parentNode.insertBefore(errorEl, DOM.btnFetch.nextSibling);
				}
				errorEl.innerHTML = `
					<div class="error-message" style="margin-bottom: 8px;">${message}</div>
					<button class="btn btn-secondary" id="btn-retry" style="width: 100%;">重试</button>
				`;
				errorEl.classList.remove("hidden");

				// Add retry handler
				document.getElementById("btn-retry").addEventListener("click", handleFetchLogs);
			}

			/**
			 * Hide error message
			 */
			function hideError() {
				const errorEl = document.getElementById("fetch-error");
				if (errorEl) {
					errorEl.classList.add("hidden");
				}
			}

			// ============================================================
			// Character View Rendering
			// ============================================================

			/** @type {string} */
			let characterFilter = "all";

			/** @type {string} */
			let characterSearchQuery = "";

			/** @type {string|null} */
			let expandedCharacter = null;

			/**
			 * Render character grid
			 */
			function renderCharacterGrid() {
				// Always reinitialize characters from messages to ensure accuracy
				if (state.editedMessages.length > 0) {
					CharacterManager.initFromMessages(state.editedMessages);
				}

				const characters = CharacterManager.getAllCharacters();

				if (characters.length === 0) {
					DOM.characterGrid.innerHTML = `
						<div class="character-empty-state">
							<p>请先获取日志数据</p>
						</div>
					`;
					return;
				}

				// Filter characters
				let filtered = characters;
				if (characterFilter !== "all") {
					// Check if it's a custom category filter
					if (characterFilter.startsWith("cat-")) {
						filtered = CategoryManager.getCharactersByCategory(characterFilter);
					} else if (characterFilter === "uncategorized") {
						// Filter uncategorized characters (no base type and no custom category)
						filtered = filtered.filter((c) => {
							const hasCustomCategory = CategoryManager.getCharacterCategory(c.name) !== null;
							const hasBaseType = ["kp", "npc", "pc", "dice"].includes(c.type);
							return !hasCustomCategory && !hasBaseType;
						});
					} else {
						// Filter by base type, but exclude characters that belong to a custom category
						filtered = filtered.filter((c) => {
							const hasCustomCategory = CategoryManager.getCharacterCategory(c.name) !== null;
							return c.type === characterFilter && !hasCustomCategory;
						});
					}
				}
				if (characterSearchQuery) {
					const query = characterSearchQuery.toLowerCase();
					filtered = filtered.filter((c) => c.name.toLowerCase().includes(query));
				}

				// Sort by message count
				filtered.sort((a, b) => b.messageCount - a.messageCount);

				DOM.characterGrid.innerHTML = filtered.map((char) => renderCharacterCard(char)).join("");

				// Update filter tab counts and render category tabs
				updateFilterCounts(characters);
				renderCategoryTabs(characters);
			}

			/**
			 * Render a single character card (Layout B style)
			 * @param {CharacterConfig} char
			 * @returns {string}
			 */
			function renderCharacterCard(char) {
				// 只要有 voiceName 就认为配置了语音
				const hasVoice = char.voice?.voiceName;
				const hasSounds = char.soundTriggers?.length > 0;

				// Get portrait thumbnails (max 3)
				const portraits = char.portraits.slice(0, 3);

				// Voice preview text
				const voicePreview = hasVoice ? `${char.voice.voiceName} · 语速 ${char.voice.rate}x` : "未配置";

				// Generate portrait HTML - one placeholder with "无立绘" if empty
				const portraitHtml =
					portraits.length > 0
						? portraits
								.map(
									(p) =>
										`<img src="${p.url}" title="${escapeHtml(p.name || "未命名")}" onerror="this.style.opacity='0.3'">`
								)
								.join("")
						: '<div class="portrait-placeholder"><span>无差分</span></div>';

				// Avatar: use first character as fallback
				const firstChar = char.name ? char.name.charAt(0) : "?";
				const hasAvatar = char.defaultPortrait && char.defaultPortrait.trim() !== "";
				const avatarHtml = hasAvatar
					? `<img class="card-avatar" src="${char.defaultPortrait}" alt="${escapeHtml(
							char.name
					  )}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'"><div class="card-avatar-fallback" style="display:none">${escapeHtml(
							firstChar
					  )}</div>`
					: `<div class="card-avatar-fallback">${escapeHtml(firstChar)}</div>`;

				// Get custom category if any
				const customCategory = CategoryManager.getCharacterCategory(char.name);

				// Type label mapping
				const typeLabels = {
					kp: "KP",
					npc: "NPC",
					pc: "PC",
					dice: "骰子",
				};

				// Only show base type if not in a custom category and has a known valid type
				const hasKnownType = char.type && typeLabels[char.type];
				const typeBadge =
					customCategory || !hasKnownType ? "" : `<span class="card-type ${char.type}">${typeLabels[char.type]}</span>`;

				const categoryBadge = customCategory
					? `<span class="card-category" style="--cat-color: ${customCategory.color}">${escapeHtml(
							customCategory.name
					  )}</span>`
					: "";

				// Batch selection checkbox
				const isSelected = BatchSelectionState.isSelected(char.name);
				const checkboxHtml = BatchSelectionState.enabled
					? `<div class="batch-checkbox ${isSelected ? "checked" : ""}" data-name="${escapeHtml(char.name)}">
						<span class="checkbox-icon">${isSelected ? "✓" : ""}</span>
					</div>`
					: "";

				// Card class with selection state
				const cardClass = `character-card${BatchSelectionState.enabled ? " batch-mode" : ""}${
					isSelected ? " selected" : ""
				}`;

				return `
					<div class="${cardClass}" data-name="${escapeHtml(char.name)}">
						${checkboxHtml}
						<div class="card-header">
							${avatarHtml}
							<div class="card-title">
								<h3>${escapeHtml(char.name)}</h3>
								<div class="card-type-row">
									${typeBadge}
									${categoryBadge}
								</div>
							</div>
							<div class="card-badges">
								${hasVoice ? '<span class="badge" title="已配置语音">🔊</span>' : ""}
								${hasSounds ? '<span class="badge" title="有音效触发">🎵</span>' : ""}
							</div>
						</div>
						<div class="card-stats">
							<div class="stat"><span class="stat-num">${char.messageCount}</span><span class="stat-label">出场</span></div>
							<div class="stat"><span class="stat-num">${char.portraits.length}</span><span class="stat-label">差分</span></div>
							<div class="stat"><span class="stat-num">${
								char.soundTriggers?.length || 0
							}</span><span class="stat-label">音效</span></div>
						</div>
						<div class="card-content">
							<div class="expand-section">
								<div class="expand-title">差分预览</div>
								<div class="mini-portraits">
									${portraitHtml}
								</div>
							</div>
							<div class="expand-section">
								<div class="expand-title">语音设置</div>
								<div class="voice-preview">${voicePreview}</div>
							</div>
							<button class="btn-edit" onclick="event.stopPropagation(); openCharacterDetail('${escapeAttr(
								char.name
							)}')">编辑详情 →</button>
						</div>
					</div>
				`;
			}

			// ============================================================
			// Character Detail Page
			// ============================================================

			/** @type {string|null} */
			let currentDetailCharacter = null;

			/** @type {boolean} */
			let isDetailPageVisible = false;

			/**
			 * Open character detail page
			 * @param {string} name - Character name
			 */
			function openCharacterDetail(name) {
				currentDetailCharacter = name;
				isDetailPageVisible = true;
				renderCharacterDetailPage();
				// Show the detail page
				DOM.characterDetailPage.classList.remove("hidden");
				DOM.characterGrid.classList.add("hidden");
				// Update button states - character button should not be active when showing detail
				DOM.btnViewCharacter.classList.remove("active");
				updateCharacterDetailButton();
			}

			/**
			 * Close character detail page (close the tab)
			 */
			function closeCharacterDetail() {
				const wasInDetailPage = isDetailPageVisible && currentView === "character";

				currentDetailCharacter = null;
				isDetailPageVisible = false;

				// If we were viewing the detail page, go back to character list
				if (wasInDetailPage) {
					DOM.characterDetailPage.classList.add("hidden");
					DOM.characterGrid.classList.remove("hidden");
					DOM.btnViewCharacter.classList.add("active");
				}
				// Otherwise stay on current view (list/replay)

				updateCharacterDetailButton();
			}

			/**
			 * Show character list (hide detail page but keep tab)
			 */
			function showCharacterList() {
				isDetailPageVisible = false;
				DOM.characterDetailPage.classList.add("hidden");
				DOM.characterGrid.classList.remove("hidden");
				DOM.btnViewCharacter.classList.add("active");
				updateCharacterDetailButton();
			}

			/**
			 * Show character detail page (from tab click)
			 */
			function showCharacterDetailFromTab() {
				if (currentDetailCharacter) {
					isDetailPageVisible = true;
					currentView = "character";

					// Hide editor panel with animation (floating mode for character view)
					DOM.editorPanel.classList.add("floating-mode");
					DOM.editorPanel.classList.add("collapsed");
					DOM.editorPanel.classList.add("hidden-in-character");
					DOM.editorToggle.classList.add("hidden");

					// Update view containers
					DOM.viewReplay.classList.remove("active");
					DOM.viewList.classList.remove("active");
					DOM.viewCharacter.classList.add("active");

					// Update view buttons - none of the main 3 should be active when detail is shown
					DOM.btnViewReplay.classList.remove("active");
					DOM.btnViewList.classList.remove("active");
					DOM.btnViewCharacter.classList.remove("active");

					DOM.characterDetailPage.classList.remove("hidden");
					DOM.characterGrid.classList.add("hidden");
					updateCharacterDetailButton();
				}
			}

			/**
			 * Update the character detail button in view switcher
			 */
			function updateCharacterDetailButton() {
				const existingBtn = document.getElementById("btn-char-detail");

				if (currentDetailCharacter) {
					if (!existingBtn) {
						const btn = document.createElement("button");
						btn.className = "view-btn char-detail-btn";
						btn.id = "btn-char-detail";
						DOM.viewSwitcher.appendChild(btn);
					}
					const btn = document.getElementById("btn-char-detail");
					btn.className = `view-btn char-detail-btn ${
						isDetailPageVisible && currentView === "character" ? "active" : ""
					}`;
					btn.innerHTML = `${escapeHtml(currentDetailCharacter)} <span class="close-detail">×</span>`;
					// Remove old listeners and add new ones
					btn.replaceWith(btn.cloneNode(true));
					const newBtn = document.getElementById("btn-char-detail");
					newBtn.addEventListener("click", (e) => {
						if (e.target.classList.contains("close-detail")) {
							e.stopPropagation();
							closeCharacterDetail();
						} else {
							showCharacterDetailFromTab();
						}
					});
				} else {
					if (existingBtn) {
						existingBtn.remove();
					}
				}
			}

			/**
			 * Render character detail page
			 */
			function renderCharacterDetailPage() {
				const char = CharacterManager.getCharacter(currentDetailCharacter);
				if (!char) {
					closeCharacterDetail();
					return;
				}

				DOM.characterDetailPage.classList.remove("hidden");

				// Get custom categories for the dropdown
				const categories = CategoryManager.getAllCategories();
				const currentCategory = CategoryManager.getCharacterCategory(char.name);
				const categoryOptions = categories
					.map(
						(cat) =>
							`<option value="cat-${cat.id}" ${currentCategory?.id === cat.id ? "selected" : ""}>${escapeHtml(
								cat.name
							)}</option>`
					)
					.join("");

				// Determine if current type is a custom category
				const isCustomCategory = currentCategory !== null;
				const baseTypeSelected = !isCustomCategory;

				// Use escapeAttr for onclick handlers to handle special characters in names
				const safeName = escapeAttr(char.name);

				DOM.characterDetailPage.innerHTML = `
					<div class="detail-header">
						<div class="detail-avatar-container" onclick="openAvatarSelector('${safeName}')" title="点击选择头像">
							<img class="detail-avatar" src="${char.defaultPortrait || "https://via.placeholder.com/80"}" alt="${escapeHtml(
					char.name
				)}" onerror="this.src='https://via.placeholder.com/80'">
							<div class="detail-avatar-overlay">
								<span>📷</span>
							</div>
						</div>
						<div class="detail-title">
							<h2>${escapeHtml(char.name)}</h2>
							<select class="type-select" onchange="updateCharacterType('${safeName}', this.value)">
								<option value="pc" ${baseTypeSelected && char.type === "pc" ? "selected" : ""}>PC (玩家)</option>
								<option value="npc" ${baseTypeSelected && char.type === "npc" ? "selected" : ""}>NPC</option>
								<option value="kp" ${baseTypeSelected && char.type === "kp" ? "selected" : ""}>KP (主持人)</option>
								<option value="dice" ${baseTypeSelected && char.type === "dice" ? "selected" : ""}>骰子</option>
								${categories.length > 0 ? "<option disabled>──────────</option>" : ""}
								${categoryOptions}
							</select>
							<button class="btn btn-secondary btn-sm" onclick="openRenameModal('${safeName}')" style="margin-left: 8px;">重命名</button>
						</div>
						<div class="detail-stats">出场 ${char.messageCount} 次</div>
					</div>

					<div class="detail-tabs">
						<button class="detail-tab active" data-panel="portraits">差分</button>
						<button class="detail-tab" data-panel="voice">语音</button>
						<button class="detail-tab" data-panel="sounds">音效</button>
						<button class="detail-tab" data-panel="card">角色卡</button>
					</div>

					<div class="detail-content">
						<div class="detail-panel active" id="detail-portraits">
							${renderDetailPortraitsPanel(char)}
						</div>
						<div class="detail-panel" id="detail-voice">
							${renderDetailVoicePanel(char)}
						</div>
						<div class="detail-panel" id="detail-sounds">
							${renderDetailSoundsPanel(char)}
						</div>
						<div class="detail-panel" id="detail-card">
							${renderDetailCardPanel(char)}
						</div>
					</div>
				`;

				// Add tab event listeners
				DOM.characterDetailPage.querySelectorAll(".detail-tab").forEach((tab) => {
					tab.addEventListener("click", () => {
						DOM.characterDetailPage.querySelectorAll(".detail-tab").forEach((t) => t.classList.remove("active"));
						DOM.characterDetailPage.querySelectorAll(".detail-panel").forEach((p) => p.classList.remove("active"));
						tab.classList.add("active");
						document.getElementById(`detail-${tab.dataset.panel}`).classList.add("active");

						// Setup voice panel events when switching to voice tab
						if (tab.dataset.panel === "voice") {
							setupVoicePanelEvents(currentDetailCharacter);
						}
					});
				});
			}

			/**
			 * Update character type
			 */
			function updateCharacterType(name, type) {
				// Check if it's a custom category selection
				if (type.startsWith("cat-")) {
					const categoryId = type.substring(4); // Remove "cat-" prefix
					CategoryManager.addCharacterToCategory(categoryId, name);
				} else {
					// It's a base type (pl, npc, kp)
					// Remove from any custom category first
					CategoryManager.removeCharacterFromAllCategories(name);
					CharacterManager.updateCharacter(name, { type });
				}
				renderCharacterGrid();
			}

			/**
			 * Render portraits panel for detail page
			 */
			function renderDetailPortraitsPanel(char) {
				const portraits = char.portraits || [];
				const safeName = escapeAttr(char.name);

				return `
					<div class="section-title">差分管理 <button class="btn-small" onclick="addPortraitToCharacter('${safeName}')">+ 导入</button></div>
					<div class="portrait-grid">
						${portraits
							.map(
								(p, idx) => `
							<div class="portrait-item ${p.url === char.defaultPortrait ? "active" : ""}" data-index="${idx}"
								oncontextmenu="showPortraitItemContextMenu(event, '${safeName}', '${escapeAttr(p.url)}', ${idx})">
								<button class="portrait-replace-btn" onclick="event.stopPropagation(); replacePortraitBatch('${safeName}', '${escapeAttr(
									p.url
								)}');">替换</button>
								<button class="portrait-avatar-btn ${p.url === char.defaultPortrait ? "active" : ""}" 
									onclick="event.stopPropagation(); setCharacterAvatar('${safeName}', '${escapeAttr(p.url)}');" 
									title="${p.url === char.defaultPortrait ? "当前头像" : "设为头像"}">
									${p.url === char.defaultPortrait ? "👤" : "📷"}
								</button>
								<span class="portrait-usage-badge">${p.usageCount}次</span>
								<img src="${p.url}" alt="${escapeHtml(
									p.name || "差分"
								)}" onerror="this.src='https://via.placeholder.com/120x160?text=Error'" onclick="openPortraitPreview('${safeName}', ${idx})">
								<div class="portrait-name-overlay">
									<input type="text" class="portrait-name-edit" value="${escapeHtml(p.name || "")}" placeholder="命名..."
										onclick="event.stopPropagation()"
										onchange="updatePortraitName('${safeName}', ${idx}, this.value)">
								</div>
							</div>
						`
							)
							.join("")}
						<div class="portrait-item add-new" onclick="addPortraitToCharacter('${safeName}')">
							<div class="add-icon">+</div>
							<div class="portrait-name">添加差分</div>
						</div>
					</div>
				`;
			}

			/**
			 * Render voice panel for detail page
			 */
			function renderDetailVoicePanel(char) {
				const voice = char.voice || CharacterManager.getDefaultVoiceConfig();
				const voices = TTSManager.getVoices();

				// 按语言分组语音（只保留中日英）
				const voiceGroups = {
					zh: voices.filter((v) => v.lang.startsWith("zh")),
					ja: voices.filter((v) => v.lang.startsWith("ja")),
					en: voices.filter((v) => v.lang.startsWith("en")),
				};

				const renderVoiceOptions = () => {
					let options = '<option value="">使用默认语音</option>';

					if (voiceGroups.zh.length > 0) {
						options += '<optgroup label="中文">';
						voiceGroups.zh.forEach((v) => {
							const selected = voice.voiceName === v.name ? "selected" : "";
							options += `<option value="${v.name}" ${selected}>${v.name}</option>`;
						});
						options += "</optgroup>";
					}

					if (voiceGroups.ja.length > 0) {
						options += '<optgroup label="日语">';
						voiceGroups.ja.forEach((v) => {
							const selected = voice.voiceName === v.name ? "selected" : "";
							options += `<option value="${v.name}" ${selected}>${v.name}</option>`;
						});
						options += "</optgroup>";
					}

					if (voiceGroups.en.length > 0) {
						options += '<optgroup label="英语">';
						voiceGroups.en.forEach((v) => {
							const selected = voice.voiceName === v.name ? "selected" : "";
							options += `<option value="${v.name}" ${selected}>${v.name}</option>`;
						});
						options += "</optgroup>";
					}

					return options;
				};

				return `
					<div class="section-title">语音设置</div>
					<div class="voice-settings-panel">
						<div class="form-group">
							<label class="form-label">选择语音</label>
							<select id="voice-select" class="form-input">
								${renderVoiceOptions()}
							</select>
						</div>

						<div class="form-group">
							<label class="form-label">语速: <span id="rate-value">${voice.rate}</span></label>
							<input type="range" id="voice-rate" class="form-range"
								min="0.5" max="2" step="0.1" value="${voice.rate}" />
						</div>

						<div class="form-group">
							<label class="form-label">音调: <span id="pitch-value">${voice.pitch}</span></label>
							<input type="range" id="voice-pitch" class="form-range"
								min="0.5" max="2" step="0.1" value="${voice.pitch}" />
						</div>

						<div class="form-group">
							<label class="form-label">音量: <span id="volume-value">${voice.volume}</span></label>
							<input type="range" id="voice-volume" class="form-range"
								min="0" max="1" step="0.1" value="${voice.volume}" />
						</div>

						<div class="voice-actions">
							<button class="btn btn-secondary" id="btn-test-voice">
								🔊 试听
							</button>
							<button class="btn btn-secondary" id="btn-reset-voice">
								🔄 重置
							</button>
						</div>
					</div>
				`;
			}

			/**
			 * Setup voice panel event listeners
			 * @param {string} characterName - 角色名称
			 */
			function setupVoicePanelEvents(characterName) {
				const char = state.characters[characterName];
				if (!char) return;

				// 语音选择
				const voiceSelect = document.getElementById("voice-select");
				if (voiceSelect) {
					voiceSelect.addEventListener("change", (e) => {
						char.voice.voiceName = e.target.value;
						// 选择语音后自动启用
						if (e.target.value) {
							char.voice.enabled = true;
						}
					});
				}

				// 语速滑块
				const rateSlider = document.getElementById("voice-rate");
				const rateValue = document.getElementById("rate-value");
				if (rateSlider && rateValue) {
					rateSlider.addEventListener("input", (e) => {
						const value = parseFloat(e.target.value);
						rateValue.textContent = value;
						char.voice.rate = value;
					});
				}

				// 音调滑块
				const pitchSlider = document.getElementById("voice-pitch");
				const pitchValue = document.getElementById("pitch-value");
				if (pitchSlider && pitchValue) {
					pitchSlider.addEventListener("input", (e) => {
						const value = parseFloat(e.target.value);
						pitchValue.textContent = value;
						char.voice.pitch = value;
					});
				}

				// 音量滑块
				const volumeSlider = document.getElementById("voice-volume");
				const volumeValue = document.getElementById("volume-value");
				if (volumeSlider && volumeValue) {
					volumeSlider.addEventListener("input", (e) => {
						const value = parseFloat(e.target.value);
						volumeValue.textContent = value;
						char.voice.volume = value;
					});
				}

				// 试听按钮
				const testBtn = document.getElementById("btn-test-voice");
				if (testBtn) {
					testBtn.addEventListener("click", () => {
						const testText = `你好，我是${characterName}。`;
						TTSManager.testVoice(char.voice, testText);
					});
				}

				// 重置按钮
				const resetBtn = document.getElementById("btn-reset-voice");
				if (resetBtn) {
					resetBtn.addEventListener("click", () => {
						char.voice = CharacterManager.getDefaultVoiceConfig();
						// 重新渲染面板
						const voicePanel = document.getElementById("panel-voice");
						if (voicePanel) {
							voicePanel.innerHTML = renderDetailVoicePanel(char);
							setupVoicePanelEvents(characterName);
						}
					});
				}
			}

			/**
			 * Render sounds panel for detail page
			 */
			function renderDetailSoundsPanel(char) {
				return `
					<div class="section-title">音效触发</div>
					<div class="placeholder-content">
						<p>音效触发功能将在后续实现</p>
					</div>
				`;
			}

			/**
			 * Render character card panel for detail page
			 */
			function renderDetailCardPanel(char) {
				return `
					<div class="section-title">角色卡</div>
					<div class="placeholder-content">
						<p>角色卡功能将在后续实现</p>
					</div>
				`;
			}

			/**
			 * Toggle character card expansion
			 * @param {string} name
			 */
			function toggleCharacterExpand(name) {
				if (expandedCharacter === name) {
					expandedCharacter = null;
				} else {
					expandedCharacter = name;
				}
				renderCharacterGrid();
			}

			/**
			 * Switch tab in expanded card (legacy, kept for compatibility)
			 * @param {HTMLElement} card
			 * @param {string} panel
			 */
			function switchExpandTab(card, panel) {
				// Update tabs
				card.querySelectorAll(".expand-tab").forEach((t) => {
					t.classList.toggle("active", t.dataset.panel === panel);
				});
				// Update panels
				card.querySelectorAll(".expand-panel").forEach((p) => {
					p.classList.toggle("active", p.id.includes(panel));
				});
			}

			/**
			 * Update filter tab counts
			 * @param {CharacterConfig[]} characters
			 */
			function updateFilterCounts(characters) {
				// Filter out characters that belong to custom categories for base type counts
				const charactersWithoutCustomCategory = characters.filter(
					(c) => CategoryManager.getCharacterCategory(c.name) === null
				);

				// Count uncategorized (no base type and no custom category)
				const baseTypes = ["kp", "npc", "pc", "dice"];
				const uncategorizedCount = charactersWithoutCustomCategory.filter((c) => !baseTypes.includes(c.type)).length;

				const counts = {
					all: characters.length,
					uncategorized: uncategorizedCount,
					kp: charactersWithoutCustomCategory.filter((c) => c.type === "kp").length,
					npc: charactersWithoutCustomCategory.filter((c) => c.type === "npc").length,
					pc: charactersWithoutCustomCategory.filter((c) => c.type === "pc").length,
					dice: charactersWithoutCustomCategory.filter((c) => c.type === "dice").length,
				};

				// Label mapping
				const labels = {
					all: "全部",
					uncategorized: "未归类",
					kp: "KP",
					npc: "NPC",
					pc: "PC",
					dice: "骰子",
				};

				// Update base filter tabs
				DOM.characterFilterTabs.querySelectorAll(".filter-tab:not(.custom-category)").forEach((tab) => {
					const filter = tab.dataset.filter;
					const count = counts[filter] || 0;
					const label = labels[filter] || filter.toUpperCase();
					tab.textContent = `${label} (${count})`;
				});
			}

			/**
			 * Render category tabs with dynamic overflow detection for ALL tabs
			 * @param {CharacterConfig[]} characters
			 */
			function renderCategoryTabs(characters) {
				const categories = CategoryManager.getAllCategories();

				// Remove existing custom category tabs
				DOM.characterFilterTabs.querySelectorAll(".filter-tab.custom-category").forEach((tab) => tab.remove());

				// Calculate counts for each category
				const categoryCounts = {};
				categories.forEach((cat) => {
					categoryCounts[cat.id] = cat.characterNames.filter((name) => state.characters[name]).length;
				});

				// Add custom category tabs
				categories.forEach((cat) => {
					const tab = document.createElement("button");
					tab.className = `filter-tab custom-category ${characterFilter === cat.id ? "active" : ""}`;
					tab.dataset.filter = cat.id;
					tab.dataset.categoryId = cat.id;

					const textSpan = document.createElement("span");
					textSpan.textContent = `${cat.name} (${categoryCounts[cat.id]})`;

					const deleteSpan = document.createElement("span");
					deleteSpan.className = "category-tab-delete";
					deleteSpan.textContent = "×";
					deleteSpan.dataset.deleteId = cat.id;
					deleteSpan.addEventListener("click", (e) => {
						e.stopPropagation();
						openDeleteCategoryModal(cat.id);
					});

					tab.appendChild(textSpan);
					tab.appendChild(deleteSpan);
					tab.addEventListener("click", () => selectCategoryFilter(cat.id));
					DOM.characterFilterTabs.appendChild(tab);
				});

				// Now check overflow for ALL tabs (base + custom)
				updateTabsOverflow();
			}

			/**
			 * Update tabs overflow - hide overflowing tabs and show in dropdown
			 */
			function updateTabsOverflow() {
				const headerLeft = DOM.characterFilterTabs.closest(".header-section-left");
				if (!headerLeft) return;

				// Get all tabs
				const allTabs = Array.from(DOM.characterFilterTabs.querySelectorAll(".filter-tab"));

				// First show all tabs and hide more dropdown to get accurate measurements
				allTabs.forEach((tab) => (tab.style.display = ""));
				DOM.filterMoreDropdown.style.display = "none";

				// Force reflow before measuring to ensure accurate widths
				void headerLeft.offsetWidth;

				// Constants matching CSS
				const TABS_GAP = 6; // .character-filter-tabs { gap: 6px }
				const PARENT_GAP = 8; // .header-section-left { gap: 8px }
				const addBtnWidth = DOM.btnAddCategory?.offsetWidth || 20;
				const moreDropdownWidth = 10;
				const availableWidth = headerLeft.offsetWidth - addBtnWidth - moreDropdownWidth - PARENT_GAP * 1;

				// Calculate which tabs fit - with overflow flag to prevent "jumping"
				let currentWidth = 0;
				const overflowTabs = [];
				let isOverflowing = false;

				allTabs.forEach((tab) => {
					const tabSpace = tab.offsetWidth + TABS_GAP;

					// Once overflow starts, ALL subsequent tabs go to overflow
					if (isOverflowing || currentWidth + tabSpace > availableWidth) {
						isOverflowing = true;
						overflowTabs.push(tab);
						tab.style.display = "none";
					} else {
						currentWidth += tabSpace;
					}
				});

				// Update overflow dropdown
				if (overflowTabs.length > 0) {
					DOM.filterMoreDropdown.style.display = "block";

					// Check if active filter is in overflow
					const isOverflowActive = overflowTabs.some((tab) => tab.classList.contains("active"));
					DOM.filterMoreBtn.classList.toggle("has-active", isOverflowActive);

					// Render overflow menu
					DOM.filterMoreMenu.innerHTML = overflowTabs
						.map((tab) => {
							const filter = tab.dataset.filter;
							const isCustom = tab.classList.contains("custom-category");
							const categoryId = tab.dataset.categoryId;
							const isActive = tab.classList.contains("active");
							const text = tab.textContent.replace("×", "").trim();

							if (isCustom) {
								return `
									<div class="filter-more-item ${isActive ? "active" : ""}" data-category-id="${categoryId}" data-filter="${filter}">
										<span>${escapeHtml(text)}</span>
										<span class="category-delete" data-delete-id="${categoryId}" title="删除类别">×</span>
									</div>
								`;
							} else {
								return `
									<div class="filter-more-item ${isActive ? "active" : ""}" data-filter="${filter}">
										<span>${escapeHtml(text)}</span>
									</div>
								`;
							}
						})
						.join("");
				} else {
					DOM.filterMoreDropdown.style.display = "none";
				}
			}

			/**
			 * Select a category filter
			 * @param {string} categoryId
			 */
			function selectCategoryFilter(categoryId) {
				// Remove active from all tabs
				DOM.characterFilterTabs.querySelectorAll(".filter-tab").forEach((t) => t.classList.remove("active"));
				DOM.filterMoreMenu.querySelectorAll(".filter-more-item").forEach((t) => t.classList.remove("active"));

				// Set active on the selected tab
				const tab = DOM.characterFilterTabs.querySelector(`[data-filter="${categoryId}"]`);
				if (tab) {
					tab.classList.add("active");
				} else {
					// It's in the overflow menu
					const menuItem = DOM.filterMoreMenu.querySelector(`[data-category-id="${categoryId}"]`);
					if (menuItem) {
						menuItem.classList.add("active");
					}
				}

				characterFilter = categoryId;
				renderCharacterGrid();

				// Close dropdown
				DOM.filterMoreMenu.classList.remove("visible");
			}

			/**
			 * Initialize character view event listeners
			 */
			function initCharacterView() {
				// Base filter tabs (all, kp, npc, pl)
				DOM.characterFilterTabs.querySelectorAll(".filter-tab:not(.custom-category)").forEach((tab) => {
					tab.addEventListener("click", () => {
						DOM.characterFilterTabs.querySelectorAll(".filter-tab").forEach((t) => t.classList.remove("active"));
						DOM.filterMoreMenu.querySelectorAll(".filter-more-item").forEach((t) => t.classList.remove("active"));
						DOM.filterMoreBtn.classList.remove("has-active");
						tab.classList.add("active");
						characterFilter = tab.dataset.filter;
						renderCharacterGrid();
					});
				});

				// Search input
				if (DOM.characterSearch) {
					DOM.characterSearch.addEventListener("input", (e) => {
						characterSearchQuery = e.target.value;
						renderCharacterGrid();
					});
				}

				// More dropdown toggle
				if (DOM.filterMoreBtn) {
					DOM.filterMoreBtn.addEventListener("click", (e) => {
						e.stopPropagation();
						DOM.filterMoreMenu.classList.toggle("visible");
					});
				}

				// Close dropdown when clicking outside
				document.addEventListener("click", () => {
					DOM.filterMoreMenu.classList.remove("visible");
				});

				// Overflow menu item click
				DOM.filterMoreMenu.addEventListener("click", (e) => {
					const deleteBtn = e.target.closest(".category-delete");
					if (deleteBtn) {
						e.stopPropagation();
						const categoryId = deleteBtn.dataset.deleteId;
						openDeleteCategoryModal(categoryId);
						return;
					}

					const item = e.target.closest(".filter-more-item");
					if (item) {
						e.stopPropagation();
						const filter = item.dataset.filter;
						const categoryId = item.dataset.categoryId;

						// Handle both base filters and custom categories
						if (categoryId) {
							selectCategoryFilter(categoryId);
						} else if (filter) {
							// Base filter (all, kp, npc, pc, dice, uncategorized)
							selectCategoryFilter(filter);
						}
						DOM.filterMoreMenu.classList.remove("visible");
					}
				});

				// Add category button
				DOM.btnAddCategory.addEventListener("click", openAddCategoryModal);

				// Category modal events
				initCategoryModals();

				// Re-render category tabs on window resize (debounced)
				let resizeTimeout;
				window.addEventListener("resize", () => {
					clearTimeout(resizeTimeout);
					resizeTimeout = setTimeout(() => {
						if (currentView === "character") {
							updateTabsOverflow();
						}
					}, 150);
				});
			}

			/**
			 * Initialize category modal event listeners
			 */
			function initCategoryModals() {
				// Add category modal
				DOM.modalCategoryClose.addEventListener("click", closeAddCategoryModal);
				DOM.modalCategoryCancel.addEventListener("click", closeAddCategoryModal);
				DOM.modalCategorySave.addEventListener("click", saveNewCategory);
				setupModalOverlayClose(DOM.modalAddCategory, closeAddCategoryModal);
				DOM.categoryNameInput.addEventListener("keydown", (e) => {
					if (e.key === "Enter") saveNewCategory();
					if (e.key === "Escape") closeAddCategoryModal();
				});

				// Delete category modal
				DOM.modalDeleteCategoryClose.addEventListener("click", closeDeleteCategoryModal);
				DOM.modalDeleteCategoryCancel.addEventListener("click", closeDeleteCategoryModal);
				DOM.modalDeleteCategoryConfirm.addEventListener("click", confirmDeleteCategory);
				setupModalOverlayClose(DOM.modalDeleteCategory, closeDeleteCategoryModal);
			}

			/** @type {string|null} Category ID pending deletion */
			let pendingDeleteCategoryId = null;

			/**
			 * Open add category modal
			 */
			function openAddCategoryModal() {
				DOM.categoryNameInput.value = "";
				DOM.modalAddCategory.classList.add("visible");
				DOM.categoryNameInput.focus();
			}

			/**
			 * Close add category modal
			 */
			function closeAddCategoryModal() {
				DOM.modalAddCategory.classList.remove("visible");
			}

			/**
			 * Save new category
			 */
			function saveNewCategory() {
				const name = DOM.categoryNameInput.value.trim();
				if (!name) {
					DOM.categoryNameInput.focus();
					return;
				}

				// Check for duplicate name
				const existing = CategoryManager.getAllCategories().find((c) => c.name === name);
				if (existing) {
					alert("类别名称已存在");
					return;
				}

				CategoryManager.createCategory(name);
				closeAddCategoryModal();
				renderCharacterGrid();
			}

			/**
			 * Open delete category confirmation modal
			 * @param {string} categoryId
			 */
			function openDeleteCategoryModal(categoryId) {
				const category = CategoryManager.getCategory(categoryId);
				if (!category) return;

				pendingDeleteCategoryId = categoryId;
				DOM.deleteCategoryName.textContent = category.name;
				DOM.modalDeleteCategory.classList.add("visible");
				DOM.filterMoreMenu.classList.remove("visible");
			}

			/**
			 * Close delete category modal
			 */
			function closeDeleteCategoryModal() {
				DOM.modalDeleteCategory.classList.remove("visible");
				pendingDeleteCategoryId = null;
			}

			/**
			 * Confirm category deletion
			 */
			function confirmDeleteCategory() {
				if (pendingDeleteCategoryId) {
					// If currently filtering by this category, reset to "all"
					if (characterFilter === pendingDeleteCategoryId) {
						characterFilter = "all";
						DOM.characterFilterTabs.querySelector('[data-filter="all"]').classList.add("active");
					}

					CategoryManager.deleteCategory(pendingDeleteCategoryId);
					closeDeleteCategoryModal();
					renderCharacterGrid();
				}
			}

			// ============================================================
			// Batch Selection Functions
			// ============================================================

			/**
			 * Update batch selection UI
			 */
			function updateBatchSelectionUI() {
				const toolbar = document.getElementById("batch-toolbar");
				const toggleBtn = document.getElementById("btn-batch-select");

				if (BatchSelectionState.enabled) {
					// Show toolbar
					if (toolbar) {
						toolbar.classList.add("visible");
						const countSpan = toolbar.querySelector(".batch-count");
						if (countSpan) {
							countSpan.textContent = `已选择 ${BatchSelectionState.getSelectedCount()} 个角色`;
						}
					}
					// Update toggle button
					if (toggleBtn) {
						toggleBtn.classList.add("active");
					}
				} else {
					// Hide toolbar
					if (toolbar) {
						toolbar.classList.remove("visible");
					}
					// Update toggle button
					if (toggleBtn) {
						toggleBtn.classList.remove("active");
					}
				}

				// Update card selection states without re-rendering entire grid
				updateCardSelectionStates();
			}

			/**
			 * Update message batch selection UI
			 */
			function updateMessageBatchSelectionUI() {
				const toolbar = DOM.messageBatchToolbar;
				const toggleBtn = DOM.btnMessageBatchMode;

				if (MessageBatchSelectionState.enabled) {
					// Show toolbar
					if (toolbar) {
						toolbar.classList.add("visible");
						const countSpan = toolbar.querySelector(".message-batch-count");
						if (countSpan) {
							countSpan.textContent = `已选择 ${MessageBatchSelectionState.getSelectedCount()} 条消息`;
						}
					}
					// Update toggle button
					if (toggleBtn) {
						toggleBtn.classList.add("active");
					}
				} else {
					// Hide toolbar
					if (toolbar) {
						toolbar.classList.remove("visible");
					}
					// Update toggle button
					if (toggleBtn) {
						toggleBtn.classList.remove("active");
					}
				}
			}

			/**
			 * Update card selection states without re-rendering
			 */
			function updateCardSelectionStates() {
				const cards = DOM.characterGrid.querySelectorAll(".character-card");
				cards.forEach((card) => {
					const name = card.dataset.name;
					const isSelected = BatchSelectionState.selectedCharacters.has(name);
					const checkbox = card.querySelector(".batch-checkbox");

					// Update card selected state
					if (isSelected) {
						card.classList.add("selected");
					} else {
						card.classList.remove("selected");
					}

					// Update checkbox state
					if (checkbox) {
						if (isSelected) {
							checkbox.classList.add("checked");
							checkbox.innerHTML = '<span class="checkbox-icon">✓</span>';
						} else {
							checkbox.classList.remove("checked");
							checkbox.innerHTML = "";
						}
					}
				});
			}

			/**
			 * Toggle batch selection mode
			 */
			function toggleBatchMode() {
				if (BatchSelectionState.enabled) {
					BatchSelectionState.exitBatchMode();
				} else {
					BatchSelectionState.enterBatchMode();
				}
			}

			/**
			 * Handle character card click in batch mode
			 * @param {string} name - Character name
			 */
			function handleBatchCardClick(name) {
				if (BatchSelectionState.enabled) {
					BatchSelectionState.toggleCharacter(name);
				}
			}

			/**
			 * Select all visible characters
			 */
			function batchSelectAll() {
				const visibleCards = DOM.characterGrid.querySelectorAll(".character-card");
				const visibleNames = Array.from(visibleCards).map((card) => card.dataset.name);
				BatchSelectionState.selectAll(visibleNames);
			}

			/**
			 * Deselect all characters
			 */
			function batchDeselectAll() {
				BatchSelectionState.deselectAll();
			}

			/**
			 * Open batch add to category modal
			 */
			function openBatchCategoryModal() {
				if (BatchSelectionState.getSelectedCount() === 0) {
					alert("请先选择角色");
					return;
				}

				DOM.modalBatchCategory.classList.add("visible");
				renderBatchCategoryList();
			}

			/**
			 * Close batch add to category modal
			 */
			function closeBatchCategoryModal() {
				DOM.modalBatchCategory.classList.remove("visible");
			}

			/**
			 * Render category list in batch modal
			 */
			function renderBatchCategoryList() {
				const categories = CategoryManager.getAllCategories();
				const listContainer = document.getElementById("batch-category-list");

				if (!listContainer) return;

				// Base types
				const baseTypes = [
					{ id: "kp", name: "KP (主持人)", color: "#bf616a" },
					{ id: "npc", name: "NPC", color: "#ebcb8b" },
					{ id: "pc", name: "PC (玩家)", color: "#88c0d0" },
					{ id: "dice", name: "骰子", color: "#b48ead" },
				];

				// Count characters for each base type (excluding those in custom categories)
				const baseTypeCounts = {};
				const allCharacters = CharacterManager.getAllCharacters();
				baseTypes.forEach((type) => {
					baseTypeCounts[type.id] = allCharacters.filter(
						(c) => c.type === type.id && CategoryManager.getCharacterCategory(c.name) === null
					).length;
				});

				// Render base types
				const baseTypeHtml = baseTypes
					.map(
						(type) => `
					<div class="batch-category-item" data-base-type="${type.id}">
						<span class="category-dot" style="background: ${type.color}"></span>
						<span>${type.name}</span>
						<span class="category-count">(${baseTypeCounts[type.id]})</span>
					</div>
				`
					)
					.join("");

				// Render custom categories
				const customCategoryHtml =
					categories.length > 0
						? `<div class="batch-category-divider">自定义类别</div>` +
						  categories
								.map(
									(cat) => `
					<div class="batch-category-item" data-category-id="${cat.id}">
						<span class="category-dot" style="background: ${cat.color}"></span>
						<span>${escapeHtml(cat.name)}</span>
						<span class="category-count">(${cat.characterNames.length})</span>
					</div>
				`
								)
								.join("")
						: "";

				listContainer.innerHTML = baseTypeHtml + customCategoryHtml;
			}

			/**
			 * Confirm batch add to category
			 * @param {string} categoryId - Category ID or base type
			 * @param {boolean} isBaseType - Whether it's a base type
			 */
			function confirmBatchAddToCategory(categoryId, isBaseType = false) {
				if (isBaseType) {
					// Set base type for all selected characters
					BatchSelectionState.getSelectedNames().forEach((name) => {
						// Remove from any custom category first
						CategoryManager.removeCharacterFromAllCategories(name);
						// Update the character type
						CharacterManager.updateCharacter(name, { type: categoryId });
					});
				} else {
					// Add to custom category
					BatchSelectionState.batchAddToCategory(categoryId);
				}
				closeBatchCategoryModal();
				BatchSelectionState.exitBatchMode();
				renderCharacterGrid();
			}

			/**
			 * Open batch delete confirmation modal
			 */
			function openBatchDeleteModal() {
				if (BatchSelectionState.getSelectedCount() === 0) {
					alert("请先选择角色");
					return;
				}

				// Calculate total messages to be deleted
				const selectedNames = BatchSelectionState.getSelectedNames();
				let totalMessages = 0;
				selectedNames.forEach((name) => {
					const char = state.characters[name];
					if (char) {
						totalMessages += char.messageCount;
					}
				});

				DOM.batchDeleteCharCount.textContent = selectedNames.length;
				DOM.batchDeleteMsgCount.textContent = totalMessages;
				DOM.modalBatchDelete.classList.add("visible");
			}

			/**
			 * Close batch delete modal
			 */
			function closeBatchDeleteModal() {
				DOM.modalBatchDelete.classList.remove("visible");
			}

			/**
			 * Confirm batch delete
			 */
			function confirmBatchDelete() {
				const result = BatchSelectionState.batchDelete();
				closeBatchDeleteModal();
				BatchSelectionState.exitBatchMode();

				// Update message list and timeline
				renderMessageList();
				updateProgress();
				renderCharacterGrid();

				alert(`已删除 ${result.deletedCharacters.length} 个角色和 ${result.deletedMessageCount} 条消息`);
			}

			/**
			 * Initialize batch selection event listeners
			 */
			function initBatchSelection() {
				// Toggle button
				const toggleBtn = document.getElementById("btn-batch-select");
				if (toggleBtn) {
					toggleBtn.addEventListener("click", toggleBatchMode);
				}

				// Select all button
				const selectAllBtn = document.getElementById("btn-batch-select-all");
				if (selectAllBtn) {
					selectAllBtn.addEventListener("click", batchSelectAll);
				}

				// Deselect all button
				const deselectAllBtn = document.getElementById("btn-batch-deselect");
				if (deselectAllBtn) {
					deselectAllBtn.addEventListener("click", batchDeselectAll);
				}

				// Add to category button
				const addToCategoryBtn = document.getElementById("btn-batch-add-category");
				if (addToCategoryBtn) {
					addToCategoryBtn.addEventListener("click", openBatchCategoryModal);
				}

				// Delete button
				const deleteBtn = document.getElementById("btn-batch-delete");
				if (deleteBtn) {
					deleteBtn.addEventListener("click", openBatchDeleteModal);
				}

				// Close batch mode button
				const closeBatchBtn = document.getElementById("btn-batch-close");
				if (closeBatchBtn) {
					closeBatchBtn.addEventListener("click", () => {
						BatchSelectionState.exitBatchMode();
					});
				}

				// Batch category modal events
				if (DOM.modalBatchCategory) {
					DOM.modalBatchCategoryClose.addEventListener("click", closeBatchCategoryModal);
					DOM.modalBatchCategoryCancel.addEventListener("click", closeBatchCategoryModal);
					setupModalOverlayClose(DOM.modalBatchCategory, closeBatchCategoryModal);

					// Category item click
					const listContainer = document.getElementById("batch-category-list");
					if (listContainer) {
						listContainer.addEventListener("click", (e) => {
							const item = e.target.closest(".batch-category-item");
							if (item) {
								// Check if it's a base type or custom category
								if (item.dataset.baseType) {
									confirmBatchAddToCategory(item.dataset.baseType, true);
								} else if (item.dataset.categoryId) {
									confirmBatchAddToCategory(item.dataset.categoryId, false);
								}
							}
						});
					}
				}

				// Batch delete modal events
				if (DOM.modalBatchDelete) {
					DOM.modalBatchDeleteClose.addEventListener("click", closeBatchDeleteModal);
					DOM.modalBatchDeleteCancel.addEventListener("click", closeBatchDeleteModal);
					DOM.modalBatchDeleteConfirm.addEventListener("click", confirmBatchDelete);
					setupModalOverlayClose(DOM.modalBatchDelete, closeBatchDeleteModal);
				}

				// Character card click handler for batch mode
				DOM.characterGrid.addEventListener("click", (e) => {
					const checkbox = e.target.closest(".batch-checkbox");
					if (checkbox) {
						e.stopPropagation();
						handleBatchCardClick(checkbox.dataset.name);
						return;
					}

					const card = e.target.closest(".character-card");
					if (card && BatchSelectionState.enabled) {
						// In batch mode, clicking the card toggles selection
						if (!e.target.closest(".btn-edit")) {
							e.stopPropagation();
							handleBatchCardClick(card.dataset.name);
						}
					}
				});
			}

			// ============================================================
			// Portrait Management Functions
			// ============================================================

			/**
			 * Update portrait name
			 * @param {string} charName - Character name
			 * @param {number} idx - Portrait index
			 * @param {string} newName - New name for the portrait
			 */
			function updatePortraitName(charName, idx, newName) {
				const char = CharacterManager.getCharacter(charName);
				if (char && char.portraits[idx]) {
					char.portraits[idx].name = newName;
					CharacterManager.updateCharacter(charName, { portraits: char.portraits });
				}
			}

			/**
			 * Set character avatar from portrait
			 * @param {string} charName - Character name
			 * @param {string} portraitUrl - Portrait URL to set as avatar
			 */
			function setCharacterAvatar(charName, portraitUrl) {
				const char = CharacterManager.getCharacter(charName);
				if (!char) {
					console.warn(`Character "${charName}" not found`);
					return;
				}

				// Update the character's default portrait
				CharacterManager.updateCharacter(charName, {
					defaultPortrait: portraitUrl,
				});

				// Update the character grid to reflect the change
				renderCharacterGrid();

				// If currently viewing this character's detail page, refresh it
				if (currentDetailCharacter === charName && isDetailPageVisible) {
					renderCharacterDetailPage();
				}

				console.log(`Set avatar for "${charName}" to: ${portraitUrl}`);
			}

			// ============================================================
			// Avatar Selector Modal Functions
			// ============================================================

			/** @type {string|null} */
			let avatarSelectingCharacter = null;

			/**
			 * Open avatar selector modal
			 * @param {string} characterName - Character name
			 */
			function openAvatarSelector(characterName) {
				const char = CharacterManager.getCharacter(characterName);
				if (!char) {
					alert("角色不存在");
					return;
				}

				if (char.portraits.length === 0) {
					alert("该角色没有可用的差分图片");
					return;
				}

				avatarSelectingCharacter = characterName;
				renderAvatarSelectorGrid(char);
				DOM.modalAvatarSelector.classList.add("visible");
			}

			/**
			 * Close avatar selector modal
			 */
			function closeAvatarSelector() {
				DOM.modalAvatarSelector.classList.remove("visible");
				avatarSelectingCharacter = null;
			}

			/**
			 * Render avatar selector grid
			 * @param {CharacterConfig} char - Character configuration
			 */
			function renderAvatarSelectorGrid(char) {
				const grid = DOM.avatarSelectorGrid;
				if (!grid) return;

				grid.innerHTML = char.portraits
					.map(
						(portrait) => `
					<div class="avatar-option ${portrait.url === char.defaultPortrait ? "current" : ""}" 
						 onclick="selectAvatar('${escapeAttr(portrait.url)}')">
						<img src="${portrait.url}" alt="${escapeHtml(portrait.name || "差分")}" 
							 onerror="this.src='https://via.placeholder.com/120x160?text=Error'">
						<div class="avatar-option-overlay">
							${escapeHtml(portrait.name || "差分")}
							${portrait.url === char.defaultPortrait ? " (当前)" : ""}
						</div>
					</div>
				`
					)
					.join("");
			}

			/**
			 * Select avatar from selector
			 * @param {string} portraitUrl - Selected portrait URL
			 */
			function selectAvatar(portraitUrl) {
				if (!avatarSelectingCharacter) return;

				setCharacterAvatar(avatarSelectingCharacter, portraitUrl);
				closeAvatarSelector();

				// Refresh detail page if currently viewing this character
				if (currentDetailCharacter === avatarSelectingCharacter) {
					renderCharacterDetailPage();
				}
			}

			// ============================================================
			// Message Batch Delete Modal Functions
			// ============================================================

			/**
			 * Open message batch delete confirmation modal
			 */
			function openMessageBatchDeleteModal() {
				const selectedCount = MessageBatchSelectionState.getSelectedCount();
				if (selectedCount === 0) {
					alert("请先选择要删除的消息");
					return;
				}

				DOM.messageBatchDeleteCount.textContent = selectedCount;
				DOM.modalMessageBatchDelete.classList.add("visible");
			}

			/**
			 * Close message batch delete modal
			 */
			function closeMessageBatchDeleteModal() {
				DOM.modalMessageBatchDelete.classList.remove("visible");
			}

			/**
			 * Confirm message batch delete
			 */
			function confirmMessageBatchDelete() {
				const deletedCount = MessageBatchSelectionState.batchDeleteMessages();

				// Exit batch mode
				MessageBatchSelectionState.exitBatchMode();

				// Close modal
				closeMessageBatchDeleteModal();

				// Refresh UI
				renderMessageListFull();
				renderBackgroundSwitchList();
				renderBgmSwitchList();
				updateProgress();

				alert(`已删除 ${deletedCount} 条消息`);
			}

			// ============================================================
			// Quick Portrait Edit Modal Functions
			// ============================================================

			/** @type {number} */
			let quickEditMessageIndex = -1;

			/**
			 * Open quick portrait edit modal
			 * @param {number} messageIndex - Message index to edit
			 * @param {string} source - Source of the edit request ('replay' or 'list')
			 */
			function openQuickPortraitEdit(messageIndex, source = "list") {
				const messages = state.editedMessages;
				if (messageIndex < 0 || messageIndex >= messages.length) {
					alert("消息不存在");
					return;
				}

				const msg = messages[messageIndex];
				if (!msg.name) {
					alert("旁白消息无法编辑差分");
					return;
				}

				// In replay mode, only allow editing the currently speaking character
				if (source === "replay" && messageIndex !== currentMessageIndex) {
					alert("只能编辑当前正在发言的角色差分");
					return;
				}

				const char = CharacterManager.getCharacter(msg.name);
				if (!char || char.portraits.length === 0) {
					// If character has no portraits, offer to add one
					const shouldAddPortrait = confirm(`角色 "${msg.name}" 还没有差分图片。\n是否要为该角色添加差分？`);
					if (shouldAddPortrait) {
						const url = prompt("请输入差分图片URL:");
						if (url && url.trim()) {
							// Add portrait to character
							if (!char) {
								// Character doesn't exist, create it
								state.characters[msg.name] = {
									name: msg.name,
									type: "",
									messageCount: 1,
									portraits: [],
									defaultPortrait: "",
									voice: CharacterManager.getDefaultVoiceConfig(),
									soundTriggers: [],
									card: null,
								};
							}

							const newPortrait = {
								id: `portrait-${state.characters[msg.name].portraits.length}`,
								url: url.trim(),
								name: `差分${state.characters[msg.name].portraits.length + 1}`,
								usageCount: 1,
							};

							state.characters[msg.name].portraits.push(newPortrait);

							// Set as message icon and character default if it's the first one
							msg.iconUrl = url.trim();
							msg.isEdited = true;
							if (!state.characters[msg.name].defaultPortrait) {
								state.characters[msg.name].defaultPortrait = url.trim();
							}

							state.meta.lastModified = Date.now();

							// Refresh UI
							renderMessageListFull();
							renderCharacterGrid();

							// If editing current message in replay, update display immediately
							if (messageIndex === currentMessageIndex) {
								displayMessage(currentMessageIndex, true);
							}

							console.log(`Added first portrait for "${msg.name}": ${url.trim()}`);
						}
					}
					return;
				}

				quickEditMessageIndex = messageIndex;

				// Update modal content
				DOM.quickPortraitCharacterName.textContent = msg.name;
				DOM.quickPortraitMessageText.textContent = msg.text || "(空消息)";

				renderQuickPortraitSelectorGrid(char, msg.iconUrl);
				DOM.modalQuickPortraitEdit.classList.add("visible");
			}

			/**
			 * Close quick portrait edit modal
			 */
			function closeQuickPortraitEdit() {
				DOM.modalQuickPortraitEdit.classList.remove("visible");
				quickEditMessageIndex = -1;
			}

			/**
			 * Render quick portrait selector grid
			 * @param {CharacterConfig} char - Character configuration
			/**
			 * Render quick portrait selector grid
			 * @param {CharacterConfig} char - Character config
			 * @param {string} currentIconUrl - Currently selected icon URL
			 */
			function renderQuickPortraitSelectorGrid(char, currentIconUrl) {
				const grid = DOM.quickPortraitSelectorGrid;
				if (!grid) return;

				grid.innerHTML = char.portraits
					.map(
						(portrait) => `
					<div class="quick-portrait-option ${portrait.url === currentIconUrl ? "current" : ""}" 
						 onclick="selectQuickPortrait('${escapeAttr(portrait.url)}')">
						<img src="${portrait.url}" alt="${escapeHtml(portrait.name || "差分")}" 
							 onerror="this.src='https://via.placeholder.com/120x160?text=Error'">
						<div class="quick-portrait-option-overlay">
							${escapeHtml(portrait.name || "差分")}
							${portrait.url === currentIconUrl ? " (当前)" : ""}
						</div>
					</div>
				`
					)
					.join("");
			}

			/**
			 * Select portrait from quick selector
			 * @param {string} portraitUrl - Selected portrait URL
			 */
			function selectQuickPortrait(portraitUrl) {
				if (quickEditMessageIndex === -1) return;

				const messages = state.editedMessages;
				const msg = messages[quickEditMessageIndex];
				const editingIndex = quickEditMessageIndex; // 保存索引，因为 closeQuickPortraitEdit 会重置它

				// Update message icon
				msg.iconUrl = portraitUrl;
				msg.isEdited = true;
				state.meta.lastModified = Date.now();

				// Close modal
				closeQuickPortraitEdit();

				// Refresh UI
				renderMessageListFull();

				// Update display immediately - always refresh current message display
				console.log(`selectQuickPortrait: editingIndex=${editingIndex}, currentMessageIndex=${currentMessageIndex}`);
				if (editingIndex === currentMessageIndex) {
					// Force update the portrait display
					const wrapper = portraitWrappers.get(msg.name);
					if (wrapper) {
						const img = wrapper.querySelector(".portrait-image");
						if (img) {
							img.src = portraitUrl;
							console.log(`selectQuickPortrait: Updated portrait image directly to ${portraitUrl}`);
						}
					}
					// Also call displayMessage to update everything
					displayMessage(currentMessageIndex, true);
				}

				console.log(`Updated portrait for message ${editingIndex} to: ${portraitUrl}`);
			}

			/**
			 * Preview portrait in fullscreen modal (legacy - simple version)
			 * @param {string} url - Portrait URL
			 */
			function previewPortrait(url) {
				const modal = document.createElement("div");
				modal.className = "portrait-preview-modal";
				modal.innerHTML = `
					<div class="portrait-preview-overlay"></div>
					<div class="portrait-preview-content">
						<button class="portrait-preview-close">&times;</button>
						<img src="${url}" alt="差分预览">
					</div>
				`;
				modal.querySelector(".portrait-preview-overlay").addEventListener("click", () => modal.remove());
				modal.querySelector(".portrait-preview-close").addEventListener("click", () => modal.remove());
				document.body.appendChild(modal);
			}

			/**
			 * Open portrait preview with navigation
			 * @param {string} charName - Character name
			 * @param {number} index - Portrait index
			 */
			function openPortraitPreview(charName, index) {
				console.log("openPortraitPreview called:", charName, index);
				const char = CharacterManager.getCharacter(charName);
				if (!char || !char.portraits || char.portraits.length === 0) {
					console.log("openPortraitPreview: char not found or no portraits", char);
					return;
				}

				// 确保 index 在有效范围内
				let currentIndex = Math.min(Math.max(0, index), char.portraits.length - 1);
				const portraits = char.portraits;
				console.log("openPortraitPreview: portraits count =", portraits.length, "currentIndex =", currentIndex);

				function render() {
					const p = portraits[currentIndex];
					const isFirst = currentIndex === 0;
					const isLast = currentIndex === portraits.length - 1;

					modal.innerHTML = `
						<div class="portrait-preview-overlay"></div>
						<div class="portrait-preview-content">
							<button class="portrait-preview-close">&times;</button>
							<button class="portrait-preview-nav portrait-preview-prev" ${isFirst ? "disabled" : ""}>‹</button>
							<img src="${p.url}" alt="${escapeHtml(p.name || "差分")}">
							<button class="portrait-preview-nav portrait-preview-next" ${isLast ? "disabled" : ""}>›</button>
							<div class="portrait-preview-name">${escapeHtml(p.name || `差分${currentIndex + 1}`)}</div>
						</div>
					`;

					// Event listeners
					modal.querySelector(".portrait-preview-overlay").addEventListener("click", closeModal);
					modal.querySelector(".portrait-preview-close").addEventListener("click", closeModal);

					const prevBtn = modal.querySelector(".portrait-preview-prev");
					const nextBtn = modal.querySelector(".portrait-preview-next");

					if (!isFirst) {
						prevBtn.addEventListener("click", (e) => {
							e.stopPropagation();
							currentIndex--;
							render();
						});
					}

					if (!isLast) {
						nextBtn.addEventListener("click", (e) => {
							e.stopPropagation();
							currentIndex++;
							render();
						});
					}
				}

				function closeModal() {
					modal.remove();
				}

				// Handle keyboard navigation
				function handleKeydown(e) {
					if (e.key === "Escape") {
						closeModal();
						document.removeEventListener("keydown", handleKeydown);
					} else if (e.key === "ArrowLeft" && currentIndex > 0) {
						currentIndex--;
						render();
					} else if (e.key === "ArrowRight" && currentIndex < portraits.length - 1) {
						currentIndex++;
						render();
					}
				}

				const modal = document.createElement("div");
				modal.className = "portrait-preview-modal";
				document.body.appendChild(modal);
				document.addEventListener("keydown", handleKeydown);

				render();
			}

			/**
			 * Add new portrait to character
			 * @param {string} charName - Character name
			 */
			function addPortraitToCharacter(charName) {
				console.log("addPortraitToCharacter called with:", charName);

				const url = prompt("请输入差分图片URL:");
				if (!url || !url.trim()) {
					console.log("addPortraitToCharacter: URL is empty or cancelled");
					return false;
				}

				const char = CharacterManager.getCharacter(charName);
				console.log("addPortraitToCharacter: char =", char);

				if (!char) {
					console.error(`addPortraitToCharacter: Character "${charName}" not found in state.characters`);
					console.log("state.characters keys:", Object.keys(state.characters));
					alert(`角色 "${charName}" 不存在，无法添加差分`);
					return false;
				}

				const trimmedUrl = url.trim();
				const portraitIndex = char.portraits.length + 1;
				const newPortrait = {
					id: `portrait-${char.portraits.length}`,
					url: trimmedUrl,
					name: `差分${portraitIndex}`,
					usageCount: 0,
				};
				char.portraits.push(newPortrait);

				// 如果这是角色的第一个差分，设置为默认头像
				if (char.portraits.length === 1) {
					CharacterManager.updateCharacter(charName, {
						portraits: char.portraits,
						defaultPortrait: trimmedUrl,
					});
				} else {
					CharacterManager.updateCharacter(charName, { portraits: char.portraits });
				}
				console.log(`addPortraitToCharacter: Added portrait to "${charName}"`, newPortrait);

				// 如果角色之前没有 portrait wrapper，需要重新初始化
				if (!portraitWrappers.has(charName)) {
					console.log(`addPortraitToCharacter: Creating new portrait wrapper for "${charName}"`);
					initMultiModePortraits();
				}

				// 刷新角色详情页面以显示新添加的差分
				renderCharacterDetailPage();
				renderCharacterGrid();

				return true;
			}

			/**
			 * Replace all messages using a specific portrait with a new one
			 * @param {string} charName - Character name
			 * @param {string} oldUrl - Old portrait URL to replace
			 */
			function replacePortraitBatch(charName, oldUrl) {
				const newUrl = prompt("请输入新的差分URL来替换所有使用此差分的消息:");
				if (!newUrl) return;

				let replacedCount = 0;
				state.editedMessages.forEach((msg) => {
					if (msg.name === charName && msg.iconUrl === oldUrl) {
						msg.iconUrl = newUrl;
						msg.isEdited = true;
						replacedCount++;
					}
				});

				if (replacedCount > 0) {
					// Reinitialize character data to update portrait statistics
					CharacterManager.initFromMessages(state.editedMessages);
					renderCharacterDetailPage();
					renderCharacterGrid();
					alert(`已替换 ${replacedCount} 条消息的差分`);
				} else {
					alert("没有找到使用此差分的消息");
				}
			}

			/**
			 * Delete a portrait from character
			 * If the portrait is used in messages, those messages will have their iconUrl cleared
			 * @param {string} charName - Character name
			 * @param {string} portraitUrl - Portrait URL to delete
			 */
			function deletePortrait(charName, portraitUrl) {
				const char = CharacterManager.getCharacter(charName);
				if (!char) {
					console.error(`deletePortrait: Character "${charName}" not found`);
					return;
				}

				// Find the portrait
				const portraitIndex = char.portraits.findIndex((p) => p.url === portraitUrl);
				if (portraitIndex === -1) {
					console.error(`deletePortrait: Portrait not found for "${charName}"`);
					return;
				}

				const portrait = char.portraits[portraitIndex];

				// Check if this portrait is used in any messages
				let usedCount = 0;
				state.editedMessages.forEach((msg) => {
					if (msg.name === charName && msg.iconUrl === portraitUrl) {
						usedCount++;
					}
				});

				// Confirm deletion
				let confirmMsg = `确定要删除差分 "${portrait.name || "未命名"}" 吗？`;
				if (usedCount > 0) {
					confirmMsg += `\n\n⚠️ 该差分在 ${usedCount} 条消息中使用，删除后这些消息将变为无差分状态。`;
				}

				if (!confirm(confirmMsg)) {
					return;
				}

				// Clear iconUrl for messages using this portrait
				if (usedCount > 0) {
					state.editedMessages.forEach((msg) => {
						if (msg.name === charName && msg.iconUrl === portraitUrl) {
							msg.iconUrl = "";
							msg.isEdited = true;
						}
					});
				}

				// Remove portrait from character
				char.portraits.splice(portraitIndex, 1);
				CharacterManager.updateCharacter(charName, { portraits: char.portraits });

				// If deleted portrait was the default, clear default or set to first available
				if (char.defaultPortrait === portraitUrl) {
					const newDefault = char.portraits.length > 0 ? char.portraits[0].url : "";
					CharacterManager.updateCharacter(charName, { defaultPortrait: newDefault });
				}

				// Refresh UI
				renderCharacterDetailPage();
				renderCharacterGrid();

				console.log(`deletePortrait: Deleted portrait from "${charName}", cleared ${usedCount} messages`);
			}

			// Portrait item context menu state
			let portraitItemContextTarget = {
				charName: "",
				portraitUrl: "",
				portraitIndex: -1,
			};

			/**
			 * Show portrait item context menu
			 * @param {MouseEvent} e - Right click event
			 * @param {string} charName - Character name
			 * @param {string} portraitUrl - Portrait URL
			 * @param {number} portraitIndex - Portrait index
			 */
			function showPortraitItemContextMenu(e, charName, portraitUrl, portraitIndex) {
				e.preventDefault();
				e.stopPropagation();

				portraitItemContextTarget = { charName, portraitUrl, portraitIndex };

				const menu = DOM.portraitItemContextMenu;
				menu.style.left = `${e.clientX}px`;
				menu.style.top = `${e.clientY}px`;
				menu.classList.add("visible");

				// Close menu when clicking elsewhere
				setTimeout(() => {
					document.addEventListener("click", hidePortraitItemContextMenu, { once: true });
				}, 0);
			}

			/**
			 * Hide portrait item context menu
			 */
			function hidePortraitItemContextMenu() {
				DOM.portraitItemContextMenu.classList.remove("visible");
			}

			/**
			 * Handle portrait item context menu action
			 * @param {Event} e - Click event
			 */
			function handlePortraitItemMenuAction(e) {
				const item = e.target.closest(".context-menu-item");
				if (!item) return;

				const action = item.dataset.action;
				const { charName, portraitUrl, portraitIndex } = portraitItemContextTarget;

				hidePortraitItemContextMenu();

				switch (action) {
					case "set-avatar":
						setCharacterAvatar(charName, portraitUrl);
						renderCharacterDetailPage();
						break;
					case "preview":
						openPortraitPreview(charName, portraitIndex);
						break;
					case "replace":
						replacePortraitBatch(charName, portraitUrl);
						break;
					case "delete":
						deletePortrait(charName, portraitUrl);
						break;
				}
			}

			// Initialize portrait item context menu event listener
			DOM.portraitItemContextMenu.addEventListener("click", handlePortraitItemMenuAction);

			/**
			 * Replace portrait for a single message
			 * @param {string} msgId - Message ID
			 * @param {string} newUrl - New portrait URL
			 */
			function replacePortraitSingle(msgId, newUrl) {
				const msg = state.editedMessages.find((m) => m.id === msgId);
				if (msg) {
					msg.iconUrl = newUrl;
					msg.isEdited = true;
					CharacterManager.initFromMessages(state.editedMessages);
				}
			}

			// ============================================================
			// Message List Rendering
			// ============================================================

			/**
			 * Update message list display (full view with pagination)
			 */
			function renderMessageListFull() {
				const messages = state.editedMessages;
				const totalPages = Math.ceil(messages.length / pageSize) || 1;

				// Ensure current page is valid
				if (currentPage > totalPages) currentPage = totalPages;
				if (currentPage < 1) currentPage = 1;

				const startIndex = (currentPage - 1) * pageSize;
				const endIndex = Math.min(startIndex + pageSize, messages.length);
				const pageMessages = messages.slice(startIndex, endIndex);

				DOM.messageListFull.innerHTML = "";

				if (messages.length === 0) {
					DOM.messageListFull.innerHTML =
						'<li class="message-item" style="color: var(--text-secondary); text-align: center; padding: 40px;">暂无消息，请先获取日志数据</li>';
					DOM.paginationInfo.textContent = "/ 共 0 页";
					DOM.paginationInput.value = 0;
					return;
				}

				// Add insert indicator at the beginning of the page
				if (startIndex === 0) {
					const insertFirst = document.createElement("div");
					insertFirst.className = "insert-indicator";
					insertFirst.textContent = "➕ 点击在开头插入消息";
					insertFirst.addEventListener("click", () => openInsertModal(0));
					DOM.messageListFull.appendChild(insertFirst);
				}

				pageMessages.forEach((msg, index) => {
					const globalIndex = startIndex + index;
					const li = document.createElement("li");
					li.className = "message-item";
					li.dataset.id = msg.id;
					li.dataset.index = globalIndex;

					// Badge for edited/inserted
					let badge = "";
					if (msg.isInserted) {
						badge = '<span class="message-item-badge inserted">新增</span>';
					} else if (msg.isEdited) {
						badge = '<span class="message-item-badge edited">已编辑</span>';
					}

					// Dice badge - 只对CC检定显示成功/失败徽章
					let diceBadge = "";
					if (msg.diceInfo && msg.diceInfo.result) {
						// 只有CC检定才显示成功/失败徽章
						if (isCCDiceRoll(msg.diceInfo.result)) {
							if (msg.diceInfo.isCritical) {
								diceBadge = '<span class="message-item-badge dice-critical">大成功</span>';
							} else if (msg.diceInfo.isFumble) {
								diceBadge = '<span class="message-item-badge dice-fumble">大失败</span>';
							} else if (msg.diceInfo.isSuccess) {
								diceBadge = '<span class="message-item-badge dice-success">成功</span>';
							} else if (msg.diceInfo.isFailure) {
								diceBadge = '<span class="message-item-badge dice-failure">失败</span>';
							}
						} else {
							// 非CC检定只显示骰子图标
							diceBadge = '<span class="message-item-badge" style="background: #d08770; color: #000;">🎲</span>';
						}
					}

					// Stage badges
					let stageBadges = "";
					if (msg.stageEnter && msg.stageEnter.length > 0) {
						stageBadges += '<span class="message-item-badge stage-enter">进场</span>';
					}
					if (msg.stageExit && msg.stageExit.length > 0) {
						stageBadges += '<span class="message-item-badge stage-exit">退场</span>';
					}

					// Background badge
					let backgroundBadge = "";
					if (msg.backgroundUrl) {
						backgroundBadge = '<span class="message-item-badge background">背景</span>';
					}

					// BGM badge
					let bgmBadge = "";
					if (msg.bgmUrl !== undefined) {
						bgmBadge = msg.bgmUrl
							? '<span class="message-item-badge bgm">BGM</span>'
							: '<span class="message-item-badge bgm" style="background: var(--error-color)">静音</span>';
					}

					// Channel badge
					const channelBadge = msg.channelName ? `<span class="message-item-channel">${msg.channelName}</span>` : "";

					// Display name
					const displayName = msg.name || (msg.type === "narration" ? "旁白" : "");

					// Stage markers display
					let stageMarkersHtml = "";
					if (
						(msg.stageEnter && msg.stageEnter.length > 0) ||
						(msg.stageExit && msg.stageExit.length > 0) ||
						msg.backgroundUrl ||
						msg.bgmUrl !== undefined
					) {
						stageMarkersHtml = '<div class="stage-markers">';
						if (msg.stageEnter) {
							msg.stageEnter.forEach((name) => {
								stageMarkersHtml += `<span class="stage-marker enter" data-name="${name}" data-type="enter">🟢 ${name} 进场 <span class="remove-marker" title="移除">×</span></span>`;
							});
						}
						if (msg.stageExit) {
							msg.stageExit.forEach((name) => {
								stageMarkersHtml += `<span class="stage-marker exit" data-name="${name}" data-type="exit">🔴 ${name} 退场 <span class="remove-marker" title="移除">×</span></span>`;
							});
						}
						if (msg.backgroundUrl) {
							const truncatedUrl =
								msg.backgroundUrl.length > 30 ? msg.backgroundUrl.substring(0, 30) + "..." : msg.backgroundUrl;
							stageMarkersHtml += `<span class="background-marker" data-type="background">🖼️ ${truncatedUrl} <span class="remove-marker" title="移除背景">×</span></span>`;
						}
						if (msg.bgmUrl !== undefined) {
							if (msg.bgmUrl) {
								// 从音乐库中查找名称
								const bgmItem = state.bgmLibrary.find((item) => item.url === msg.bgmUrl);
								const bgmName = bgmItem
									? bgmItem.name
									: msg.bgmUrl.length > 30
									? msg.bgmUrl.substring(0, 30) + "..."
									: msg.bgmUrl;
								stageMarkersHtml += `<span class="bgm-marker" data-type="bgm">🎵 ${escapeHtml(
									bgmName
								)} <span class="remove-marker" title="移除BGM">×</span></span>`;
							} else {
								stageMarkersHtml += `<span class="bgm-marker stop-bgm" data-type="bgm">🔇 停止BGM <span class="remove-marker" title="移除设置">×</span></span>`;
							}
						}
						stageMarkersHtml += "</div>";
					}

					li.innerHTML = `
						<span class="drag-handle" draggable="true" title="拖拽排序">⋮⋮</span>
						${
							msg.iconUrl
								? `<img class="message-item-icon" src="${msg.iconUrl}" alt="" onerror="this.style.display='none'" title="点击编辑差分">`
								: `<div class="message-item-icon" style="background: var(--bg-secondary); cursor: pointer;" title="点击设置差分">
									<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-secondary); font-size: 1.2rem;">📷</div>
								   </div>`
						}
						<div class="message-item-content">
							<div class="message-item-header">
								<span class="message-item-name">${displayName || "（无名）"}</span>
								${channelBadge}
								${diceBadge}
								${badge}
								${stageBadges}
								${backgroundBadge}
								${bgmBadge}
							</div>
							<div class="message-item-text">${getMessageDisplayText(msg)}</div>
							${stageMarkersHtml}
						</div>
						<div class="message-item-actions">
							<button class="message-action-btn" data-action="portrait" title="设置差分">🖼️ 差分</button>
							<button class="message-action-btn" data-action="bgm" title="设置BGM">🎵 BGM</button>
							<button class="message-action-btn" data-action="background" title="设置背景">🎬 背景</button>
							<button class="message-action-btn" data-action="stage" title="进退场设置">🎭 进退场</button>
							<button class="message-action-btn" data-action="insert" title="在此后插入消息">➕ 插入消息</button>
							<button class="message-action-btn" data-action="insert-dice" title="在此后插入骰点">🎲 插入骰点</button>
							<button class="message-action-btn" data-action="edit" title="编辑">✏️ 编辑</button>
							${msg.isEdited ? '<button class="message-action-btn" data-action="reset" title="重置到原始状态">↩️ 重置</button>' : ""}
							<button class="message-action-btn delete" data-action="delete" title="删除">🗑️ 删除</button>
						</div>
					`;

					// Drag events on handle only (disabled in batch selection mode)
					const dragHandle = li.querySelector(".drag-handle");

					dragHandle.addEventListener("dragstart", (e) => {
						if (MessageBatchSelectionState.enabled) {
							e.preventDefault();
							return;
						}
						e.dataTransfer.effectAllowed = "move";
						e.dataTransfer.setData("text/plain", globalIndex.toString());
						// 设置拖拽时显示整个消息项
						e.dataTransfer.setDragImage(li, 20, 20);
						li.classList.add("dragging");
						dragSourceIndex = globalIndex;
					});

					dragHandle.addEventListener("dragend", () => {
						if (MessageBatchSelectionState.enabled) return;
						li.classList.remove("dragging");
						document.querySelectorAll(".message-item.drag-over-top, .message-item.drag-over-bottom").forEach((el) => {
							el.classList.remove("drag-over-top", "drag-over-bottom");
						});
						dragSourceIndex = -1;
					});

					li.addEventListener("dragover", (e) => {
						if (MessageBatchSelectionState.enabled) return;
						e.preventDefault();
						e.dataTransfer.dropEffect = "move";

						// 根据鼠标位置判断插入方向
						const rect = li.getBoundingClientRect();
						const midY = rect.top + rect.height / 2;

						li.classList.remove("drag-over-top", "drag-over-bottom");
						if (e.clientY < midY) {
							li.classList.add("drag-over-top");
						} else {
							li.classList.add("drag-over-bottom");
						}
					});

					li.addEventListener("dragleave", () => {
						if (MessageBatchSelectionState.enabled) return;
						li.classList.remove("drag-over-top", "drag-over-bottom");
					});

					li.addEventListener("drop", (e) => {
						if (MessageBatchSelectionState.enabled) return;
						e.preventDefault();

						const rect = li.getBoundingClientRect();
						const midY = rect.top + rect.height / 2;
						const insertAfter = e.clientY >= midY;

						li.classList.remove("drag-over-top", "drag-over-bottom");
						const fromIndex = parseInt(e.dataTransfer.getData("text/plain"), 10);
						let toIndex = globalIndex;

						// 如果拖到下半部分，插入到该消息之后
						if (insertAfter && fromIndex < toIndex) {
							// 从上往下拖，不需要调整
						} else if (insertAfter && fromIndex > toIndex) {
							// 从下往上拖到下半部分，插入到该消息之后
							toIndex = toIndex + 1;
						} else if (!insertAfter && fromIndex > toIndex) {
							// 从下往上拖到上半部分，不需要调整
						} else if (!insertAfter && fromIndex < toIndex) {
							// 从上往下拖到上半部分，插入到该消息之前
							toIndex = toIndex - 1;
						}

						if (fromIndex !== toIndex && fromIndex >= 0) {
							reorderMessages(fromIndex, toIndex);
						}
					});

					// Right-click context menu
					li.addEventListener("contextmenu", (e) => {
						if (MessageBatchSelectionState.enabled) return;
						showMessageContextMenu(e, msg, globalIndex);
					});

					// Click in batch selection mode
					li.addEventListener("click", (e) => {
						// In batch selection mode, allow checkbox interaction
						if (MessageBatchSelectionState.enabled) {
							// If clicked on checkbox, let it handle the event
							if (e.target.closest(".message-batch-checkbox")) {
								return;
							}
							// Otherwise, toggle selection by clicking anywhere on the item
							MessageBatchSelectionState.toggleMessage(msg.id);
							const checkbox = li.querySelector(".message-batch-checkbox");
							if (checkbox) {
								checkbox.checked = MessageBatchSelectionState.selectedMessages.has(msg.id);
							}
							return;
						}
					});

					// Double-click to jump to replay
					li.addEventListener("dblclick", (e) => {
						if (MessageBatchSelectionState.enabled) return;

						// Check for excluded elements
						if (
							e.target.closest(".message-action-btn") ||
							e.target.closest(".drag-handle") ||
							e.target.closest(".remove-marker") ||
							e.target.closest(".message-item-icon")
						)
							return;

						// 停止自动播放
						if (isAutoPlaying) {
							stopAutoPlay();
						}

						currentMessageIndex = globalIndex;
						displayMessage(globalIndex);
						updateProgress();
						switchView("replay");
					});

					// Message icon click event (portrait edit)
					const messageIcon = li.querySelector(".message-item-icon");
					if (messageIcon) {
						messageIcon.addEventListener("click", (e) => {
							e.stopPropagation(); // Prevent message item click
							openQuickPortraitEdit(globalIndex, "list");
						});
					}

					// Portrait button
					li.querySelector('[data-action="portrait"]').addEventListener("click", (e) => {
						e.stopPropagation();
						openQuickPortraitEdit(globalIndex, "list");
					});

					// Background button
					li.querySelector('[data-action="background"]').addEventListener("click", (e) => {
						e.stopPropagation();
						openBackgroundModal(msg, globalIndex);
					});

					// BGM button
					li.querySelector('[data-action="bgm"]').addEventListener("click", (e) => {
						e.stopPropagation();
						openBgmModal(msg, globalIndex);
					});

					// Stage button
					li.querySelector('[data-action="stage"]').addEventListener("click", (e) => {
						e.stopPropagation();
						openStageModal(msg, globalIndex);
					});

					// Insert button
					li.querySelector('[data-action="insert"]').addEventListener("click", (e) => {
						e.stopPropagation();
						openInsertModal(globalIndex + 1);
					});

					// Insert dice button
					li.querySelector('[data-action="insert-dice"]').addEventListener("click", (e) => {
						e.stopPropagation();
						openInsertDiceModal(globalIndex + 1);
					});

					// Edit button
					li.querySelector('[data-action="edit"]').addEventListener("click", (e) => {
						e.stopPropagation();
						openEditModal(msg, globalIndex);
					});

					// Reset button (only exists for edited messages)
					const resetBtn = li.querySelector('[data-action="reset"]');
					if (resetBtn) {
						resetBtn.addEventListener("click", (e) => {
							e.stopPropagation();
							resetSingleMessage(globalIndex);
						});
					}

					// Delete button
					li.querySelector('[data-action="delete"]').addEventListener("click", (e) => {
						e.stopPropagation();
						if (confirm("确定要删除这条消息吗？")) {
							state.editedMessages = state.editedMessages.filter((m) => m.id !== msg.id);
							state.deletedIds.add(msg.id);
							renderMessageListFull();
							renderBackgroundSwitchList();
							updateProgress();
						}
					});

					// Remove stage marker buttons
					li.querySelectorAll(".remove-marker").forEach((btn) => {
						btn.addEventListener("click", (e) => {
							e.stopPropagation();
							const marker = e.target.closest(".stage-marker");
							if (!marker) {
								// Check if it's a background marker
								const bgMarker = e.target.closest(".background-marker");
								if (bgMarker) {
									msg.backgroundUrl = undefined;
									state.meta.lastModified = Date.now();
									renderMessageListFull();
									renderBackgroundSwitchList();
									// Update background display
									if (currentMessageIndex === globalIndex) {
										updateBackground(globalIndex);
									}
									return;
								}
								// Check if it's a BGM marker
								const bgmMarker = e.target.closest(".bgm-marker");
								if (bgmMarker) {
									msg.bgmUrl = undefined;
									state.meta.lastModified = Date.now();
									renderMessageListFull();
									renderBgmSwitchList();
									// Update BGM if viewing this message
									if (currentMessageIndex === globalIndex) {
										BGMManager.updateBGM(globalIndex);
									}
									return;
								}
								return;
							}
							const name = marker.dataset.name;
							const type = marker.dataset.type;

							if (type === "enter" && msg.stageEnter) {
								msg.stageEnter = msg.stageEnter.filter((n) => n !== name);
								if (msg.stageEnter.length === 0) msg.stageEnter = undefined;
							} else if (type === "exit" && msg.stageExit) {
								msg.stageExit = msg.stageExit.filter((n) => n !== name);
								if (msg.stageExit.length === 0) msg.stageExit = undefined;
							}

							state.meta.lastModified = Date.now();
							renderMessageListFull();

							// Rebuild snapshots and update display
							buildStageSnapshots();
							applyStageSnapshot(currentMessageIndex);
						});
					});

					DOM.messageListFull.appendChild(li);
				});

				// Update pagination info
				DOM.paginationInfo.textContent = `/ 共 ${totalPages} 页`;
				DOM.paginationInput.value = currentPage;
				DOM.paginationInput.max = totalPages;

				// Update pagination buttons
				DOM.btnPageFirst.disabled = currentPage <= 1;
				DOM.btnPagePrev.disabled = currentPage <= 1;
				DOM.btnPageNext.disabled = currentPage >= totalPages;
				DOM.btnPageLast.disabled = currentPage >= totalPages;

				// Re-apply batch selection mode if enabled
				if (MessageBatchSelectionState.enabled) {
					MessageBatchSelectionState.addCheckboxesToMessages();
					// Restore selection states
					const items = DOM.messageListFull.querySelectorAll(".message-item");
					items.forEach((item) => {
						const messageId = item.dataset.id;
						const checkbox = item.querySelector(".message-batch-checkbox");
						if (checkbox && MessageBatchSelectionState.selectedMessages.has(messageId)) {
							checkbox.checked = true;
						}
					});
				}
			}

			// ============================================================
			// Reorder Messages (Drag & Drop)
			// ============================================================

			/**
			 * Reorder messages by moving one message to a new position
			 * @param {number} fromIndex - Original index
			 * @param {number} toIndex - Target index
			 */
			function reorderMessages(fromIndex, toIndex) {
				if (fromIndex === toIndex) return;
				if (fromIndex < 0 || fromIndex >= state.editedMessages.length) return;
				if (toIndex < 0 || toIndex >= state.editedMessages.length) return;

				const messages = state.editedMessages;
				const [movedMessage] = messages.splice(fromIndex, 1);

				// Adjust toIndex if needed after removal
				const adjustedToIndex = fromIndex < toIndex ? toIndex : toIndex;
				messages.splice(adjustedToIndex, 0, movedMessage);

				state.meta.lastModified = Date.now();

				// Update current message index if affected
				if (currentMessageIndex === fromIndex) {
					currentMessageIndex = adjustedToIndex;
				} else if (fromIndex < currentMessageIndex && adjustedToIndex >= currentMessageIndex) {
					currentMessageIndex--;
				} else if (fromIndex > currentMessageIndex && adjustedToIndex <= currentMessageIndex) {
					currentMessageIndex++;
				}

				renderMessageListFull();
				updateProgress();
			}

			// ============================================================
			// Modal Functions
			// ============================================================

			/** @type {Message|null} */
			let editingMessage = null;

			/** @type {number} */
			let editingIndex = -1;

			/** @type {number} */
			let insertAtIndex = -1;

			/**
			 * Find the last used icon URL for a character name
			 * @param {string} name - Character name
			 * @param {number} beforeIndex - Search before this index
			 * @returns {string} - Icon URL or empty string
			 */
			function findLastIconForName(name, beforeIndex) {
				if (!name) return "";
				for (let i = beforeIndex - 1; i >= 0; i--) {
					const msg = state.editedMessages[i];
					if (msg.name === name && msg.iconUrl) {
						return msg.iconUrl;
					}
				}
				return "";
			}

			/**
			 * Update portrait selector dropdown with character's portraits
			 * @param {string} prefix - "edit" or "insert"
			 * @param {string} charName - Character name
			 * @param {string} currentUrl - Currently selected URL
			 */
			function updatePortraitSelector(prefix, charName, currentUrl) {
				const dropdown = document.getElementById(`${prefix}-portrait-dropdown`);
				const preview = document.getElementById(`${prefix}-portrait-preview`);
				const text = document.getElementById(`${prefix}-portrait-text`);
				const hiddenInput = document.getElementById(`${prefix}-icon`);

				if (!dropdown || !preview || !text) return;

				// Get character's portraits
				const char = charName ? CharacterManager.getCharacter(charName) : null;
				const portraits = char?.portraits || [];

				// Build options HTML
				let optionsHtml = `
					<div class="portrait-selector-option ${!currentUrl ? "selected" : ""}" data-url="">
						<div class="portrait-selector-preview no-portrait" style="width:32px;height:40px;display:flex;align-items:center;justify-content:center;background:var(--bg-secondary);border-radius:4px;font-size:0.7rem;color:var(--text-secondary);">无</div>
						<span class="option-name">无差分</span>
						<span class="option-check">✓</span>
					</div>
				`;

				portraits.forEach((p, idx) => {
					const isSelected = currentUrl === p.url;
					const displayName = p.name || `差分${idx + 1}`;
					optionsHtml += `
						<div class="portrait-selector-option ${isSelected ? "selected" : ""}" data-url="${escapeHtml(p.url)}">
							<img src="${p.url}" alt="${escapeHtml(displayName)}" onerror="this.style.display='none'">
							<span class="option-name">${escapeHtml(displayName)}</span>
							<span class="option-check">✓</span>
						</div>
					`;
				});

				dropdown.innerHTML = optionsHtml;

				// Update current selection display
				if (currentUrl && portraits.length > 0) {
					const selectedPortrait = portraits.find((p) => p.url === currentUrl);
					if (selectedPortrait) {
						preview.innerHTML = `<img src="${currentUrl}" style="width:32px;height:40px;object-fit:cover;border-radius:4px;">`;
						preview.classList.remove("no-portrait");
						text.textContent = selectedPortrait.name || "差分";
					} else {
						preview.innerHTML = "无";
						preview.classList.add("no-portrait");
						text.textContent = "无差分";
					}
				} else {
					preview.innerHTML = "无";
					preview.classList.add("no-portrait");
					text.textContent = "无差分";
				}

				// Add click handlers to options
				dropdown.querySelectorAll(".portrait-selector-option").forEach((option) => {
					option.addEventListener("click", () => {
						const url = option.dataset.url;
						hiddenInput.value = url;

						// Update display
						if (url) {
							const p = portraits.find((p) => p.url === url);
							preview.innerHTML = `<img src="${url}" style="width:32px;height:40px;object-fit:cover;border-radius:4px;">`;
							preview.classList.remove("no-portrait");
							text.textContent = p?.name || "差分";
						} else {
							preview.innerHTML = "无";
							preview.classList.add("no-portrait");
							text.textContent = "无差分";
						}

						// Update selected state
						dropdown.querySelectorAll(".portrait-selector-option").forEach((o) => o.classList.remove("selected"));
						option.classList.add("selected");

						// Close dropdown
						closePortraitDropdown(prefix);
					});
				});
			}

			/**
			 * Toggle portrait selector dropdown
			 * @param {string} prefix - "edit" or "insert"
			 */
			function togglePortraitDropdown(prefix) {
				const trigger = document.getElementById(`${prefix}-portrait-trigger`);
				const dropdown = document.getElementById(`${prefix}-portrait-dropdown`);

				if (!trigger || !dropdown) return;

				const isOpen = dropdown.classList.contains("open");
				if (isOpen) {
					closePortraitDropdown(prefix);
				} else {
					trigger.classList.add("open");
					dropdown.classList.add("open");
				}
			}

			/**
			 * Close portrait selector dropdown
			 * @param {string} prefix - "edit" or "insert"
			 */
			function closePortraitDropdown(prefix) {
				const trigger = document.getElementById(`${prefix}-portrait-trigger`);
				const dropdown = document.getElementById(`${prefix}-portrait-dropdown`);

				if (trigger) trigger.classList.remove("open");
				if (dropdown) dropdown.classList.remove("open");
			}

			/**
			 * Parse CC dice result to extract target, roll value and skill name
			 * @param {string} result - Dice result like "(1D100<=70) ＞ 69 ＞ 成功"
			 * @returns {{target: number, roll: number, skillName: string}|null}
			 */
			function parseCCDiceResult(result) {
				if (!result) return null;
				// 匹配 1D100<=数字 格式
				const targetMatch = result.match(/1D100\s*<[=]?\s*(\d+)/i);
				if (!targetMatch) return null;

				const target = parseInt(targetMatch[1], 10);

				// 提取骰点结果 - 取第一个箭头后的数字
				const rollMatch = result.match(/[→＞]\s*(\d+)/);
				const roll = rollMatch ? parseInt(rollMatch[1], 10) : null;

				return { target, roll, skillName: "" };
			}

			/**
			 * Parse normal dice result to extract formula, result and description
			 * @param {string} result - Dice result like "(1D4) ＞ 3"
			 * @returns {{formula: string, roll: number, desc: string}|null}
			 */
			function parseNormalDiceResult(result) {
				if (!result) return null;

				// 匹配括号内的算式
				const formulaMatch = result.match(/\(([^)]+)\)/);
				const formula = formulaMatch ? formulaMatch[1] : "";

				// 提取结果 - 取最后一个箭头后的数字
				const rollMatches = result.match(/[→＞]\s*(\d+)/g);
				let roll = null;
				if (rollMatches && rollMatches.length > 0) {
					const lastMatch = rollMatches[rollMatches.length - 1].match(/(\d+)/);
					roll = lastMatch ? parseInt(lastMatch[1], 10) : null;
				}

				return { formula, roll, desc: "" };
			}

			/**
			 * Calculate CC dice result level based on roll and target
			 * @param {number} roll - Rolled value
			 * @param {number} target - Target value
			 * @returns {{level: string, isCritical: boolean, isFumble: boolean, isSuccess: boolean, isFailure: boolean}}
			 */
			function calculateCCResult(roll, target) {
				const rules = state.houseRules;

				// 技能值为0时，不论骰点是多少都是失败
				if (target <= 0) {
					const isFumble = roll >= rules.fumbleMin && roll <= rules.fumbleMax;
					return {
						level: isFumble ? "大失败" : "失败",
						isCritical: false,
						isFumble: isFumble,
						isSuccess: false,
						isFailure: true,
					};
				}

				// 使用村规判定大成功/大失败
				const isCritical = roll >= rules.criticalMin && roll <= rules.criticalMax;
				const isFumble = roll >= rules.fumbleMin && roll <= rules.fumbleMax;

				// 计算成功等级
				let level = "";
				let isSuccess = roll <= target;
				let isFailure = !isSuccess;

				if (isCritical) {
					level = "大成功";
					isSuccess = true;
					isFailure = false;
				} else if (isFumble) {
					level = "大失败";
					isSuccess = false;
					isFailure = true;
				} else if (roll <= target / 5) {
					level = "極限成功";
				} else if (roll <= target / 2) {
					level = "困難成功";
				} else if (roll <= target) {
					level = "一般成功";
				} else {
					level = "失败";
				}

				return { level, isCritical, isFumble, isSuccess, isFailure };
			}

			/**
			 * Build CC dice result string
			 * @param {number} target - Target value
			 * @param {number} roll - Rolled value
			 * @param {string} level - Result level
			 * @returns {string}
			 */
			function buildCCDiceResult(target, roll, level) {
				return `(1D100<=${target}) ＞ ${roll} ＞ ${level}`;
			}

			/**
			 * Parse dice formula and extract dice terms and constants
			 * @param {string} formula - Dice formula like "2D4+1D6+3" or "1d6-2"
			 * @returns {{dice: Array<{count: number, sides: number}>, constant: number}|null}
			 */
			function parseDiceFormula(formula) {
				if (!formula) return null;

				const normalized = formula.toUpperCase().replace(/\s/g, "");
				const dice = [];
				let constant = 0;

				// Match dice terms (2D4, 1D6, D20) and constants (+3, -2)
				// Split by + or - while keeping the sign
				const terms = normalized.split(/(?=[+-])/);

				for (const term of terms) {
					if (!term) continue;

					// Check if it's a dice term
					const diceMatch = term.match(/^([+-])?(\d*)D(\d+)$/i);
					if (diceMatch) {
						const sign = diceMatch[1] === "-" ? -1 : 1;
						const count = parseInt(diceMatch[2] || "1", 10) * sign;
						const sides = parseInt(diceMatch[3], 10);
						if (sides > 0 && count !== 0) {
							dice.push({ count, sides });
						}
					} else {
						// It's a constant
						const num = parseInt(term, 10);
						if (!isNaN(num)) {
							constant += num;
						}
					}
				}

				if (dice.length === 0) return null;
				return { dice, constant };
			}

			/**
			 * Calculate min and max possible values for a dice formula
			 * @param {string} formula - Dice formula
			 * @returns {{min: number, max: number}|null}
			 */
			function calculateDiceRange(formula) {
				const parsed = parseDiceFormula(formula);
				if (!parsed) return null;

				let min = parsed.constant;
				let max = parsed.constant;

				for (const d of parsed.dice) {
					if (d.count > 0) {
						// Positive dice: min is count*1, max is count*sides
						min += d.count * 1;
						max += d.count * d.sides;
					} else {
						// Negative dice: min is count*sides (most negative), max is count*1
						min += d.count * d.sides;
						max += d.count * 1;
					}
				}

				return { min, max };
			}

			/**
			 * Distribute a target result across dice with randomness
			 * @param {string} formula - Dice formula
			 * @param {number} target - Target total result
			 * @returns {{distribution: Array<{count: number, sides: number, values: number[]}>, constant: number, total: number}|null}
			 */
			function distributeDiceResult(formula, target) {
				const parsed = parseDiceFormula(formula);
				if (!parsed) return null;

				const range = calculateDiceRange(formula);
				if (!range || target < range.min || target > range.max) return null;

				// Expand dice into individual dice
				const allDice = [];
				for (const d of parsed.dice) {
					const absCount = Math.abs(d.count);
					const sign = d.count > 0 ? 1 : -1;
					for (let i = 0; i < absCount; i++) {
						allDice.push({ sides: d.sides, sign });
					}
				}

				// Shuffle dice order for randomness
				for (let i = allDice.length - 1; i > 0; i--) {
					const j = Math.floor(Math.random() * (i + 1));
					[allDice[i], allDice[j]] = [allDice[j], allDice[i]];
				}

				// Distribute values
				let remaining = target - parsed.constant;
				const values = [];

				for (let i = 0; i < allDice.length; i++) {
					const die = allDice[i];
					const dieMin = die.sign > 0 ? 1 : -die.sides;
					const dieMax = die.sign > 0 ? die.sides : -1;

					// Calculate what remaining dice can contribute
					let restMin = 0,
						restMax = 0;
					for (let j = i + 1; j < allDice.length; j++) {
						const rd = allDice[j];
						if (rd.sign > 0) {
							restMin += 1;
							restMax += rd.sides;
						} else {
							restMin += -rd.sides;
							restMax += -1;
						}
					}

					// This die's valid range given remaining constraint
					const validMin = Math.max(dieMin, remaining - restMax);
					const validMax = Math.min(dieMax, remaining - restMin);

					// Random value within valid range
					const value = Math.floor(Math.random() * (validMax - validMin + 1)) + validMin;
					values.push({ ...die, value: Math.abs(value) }); // Store absolute value
					remaining -= value;
				}

				// Regroup values back to original dice structure
				const distribution = [];
				let valueIndex = 0;

				for (const d of parsed.dice) {
					const absCount = Math.abs(d.count);
					const diceValues = [];
					for (let i = 0; i < absCount; i++) {
						// Find the corresponding value (order was shuffled, so we need to collect by sides)
						diceValues.push(values[valueIndex].value);
						valueIndex++;
					}
					distribution.push({
						count: d.count,
						sides: d.sides,
						values: diceValues,
					});
				}

				return { distribution, constant: parsed.constant, total: target };
			}

			/**
			 * Build detailed normal dice result string with expansion
			 * @param {string} formula - Original formula
			 * @param {number} target - Target result
			 * @returns {string}
			 */
			function buildNormalDiceResultDetailed(formula, target) {
				const dist = distributeDiceResult(formula, target);
				if (!dist) {
					// Fallback to simple format
					return `(${formula}) ＞ ${target}`;
				}

				// Build expansion string like "4[2,2]+3[3]+3"
				const parts = [];
				for (const d of dist.distribution) {
					const sum = d.values.reduce((a, b) => a + b, 0);
					const valuesStr = d.values.length > 1 ? `[${d.values.join(",")}]` : `[${d.values[0]}]`;
					const sign = d.count < 0 ? "-" : parts.length > 0 ? "+" : "";
					parts.push(`${sign}${sum}${valuesStr}`);
				}

				if (dist.constant !== 0) {
					const sign = dist.constant > 0 ? "+" : "";
					parts.push(`${sign}${dist.constant}`);
				}

				const expansion = parts.join("");
				return `(${formula}) ＞ ${expansion} ＞ ${target}`;
			}

			/**
			 * Build normal dice result string (simple version for backward compatibility)
			 * @param {string} formula - Dice formula
			 * @param {number} roll - Result value
			 * @returns {string}
			 */
			function buildNormalDiceResult(formula, roll) {
				return buildNormalDiceResultDetailed(formula, roll);
			}

			/**
			 * Update CC dice preview in edit modal
			 */
			function updateCCDicePreview() {
				const target = parseInt(DOM.editDiceCcTarget.value, 10);
				const roll = parseInt(DOM.editDiceCcRoll.value, 10);

				if (isNaN(target) || isNaN(roll)) {
					DOM.editDiceCcPreview.textContent = "--";
					DOM.editDiceCcPreview.style.color = "";
					return;
				}

				const result = calculateCCResult(roll, target);
				DOM.editDiceCcPreview.textContent = result.level;

				// 设置颜色
				if (result.isCritical) {
					DOM.editDiceCcPreview.style.color = "var(--critical-color)";
				} else if (result.isFumble) {
					DOM.editDiceCcPreview.style.color = "var(--fumble-color)";
				} else if (result.isSuccess) {
					DOM.editDiceCcPreview.style.color = "var(--success-color)";
				} else {
					DOM.editDiceCcPreview.style.color = "var(--text-secondary)";
				}
			}

			/**
			 * Open edit modal for a message
			 * @param {Message} msg - Message to edit
			 * @param {number} index - Message index
			 */
			function openEditModal(msg, index) {
				editingMessage = msg;
				editingIndex = index;

				DOM.modalEditTitle.textContent = "编辑消息";
				DOM.editName.value = msg.name || "";
				DOM.editIcon.value = msg.iconUrl || "";
				DOM.editText.value = msg.text || "";

				// 显示骰点编辑（如果有骰点信息）
				if (msg.diceInfo && msg.diceInfo.result) {
					DOM.editDiceGroup.style.display = "block";
					DOM.editTextGroup.style.display = "none"; // 隐藏消息内容输入框

					if (isCCDiceRoll(msg.diceInfo.result)) {
						// CC检定类型
						DOM.editDiceCc.style.display = "block";
						DOM.editDiceNormal.style.display = "none";

						const parsed = parseCCDiceResult(msg.diceInfo.result);
						if (parsed) {
							DOM.editDiceCcTarget.value = parsed.target || "";
							DOM.editDiceCcRoll.value = parsed.roll || "";
							DOM.editDiceCcName.value = parsed.skillName || "";
							updateCCDicePreview();
						}
					} else {
						// 普通骰点类型
						DOM.editDiceCc.style.display = "none";
						DOM.editDiceNormal.style.display = "block";

						const parsed = parseNormalDiceResult(msg.diceInfo.result);
						if (parsed) {
							DOM.editDiceFormula.value = parsed.formula || "";
							DOM.editDiceResult.value = parsed.roll || "";
							DOM.editDiceDesc.value = parsed.desc || "";
							// 更新范围提示
							const range = calculateDiceRange(parsed.formula);
							if (range) {
								DOM.editDiceRangeHint.textContent = `有效范围: ${range.min} ~ ${range.max}`;
							} else {
								DOM.editDiceRangeHint.textContent = "有效范围: --";
							}
						}
					}
				} else {
					DOM.editDiceGroup.style.display = "none";
					DOM.editTextGroup.style.display = "block"; // 显示消息内容输入框
				}

				// Initialize portrait selector
				updatePortraitSelector("edit", msg.name, msg.iconUrl);

				DOM.modalEdit.classList.add("visible");
				DOM.editName.focus();
			}

			/**
			 * Close edit modal
			 */
			function closeEditModal() {
				DOM.modalEdit.classList.remove("visible");
				editingMessage = null;
				editingIndex = -1;
				closePortraitDropdown("edit");
			}

			/**
			 * Save edited message
			 */
			function saveEditedMessage() {
				if (!editingMessage || editingIndex < 0) return;

				const name = DOM.editName.value.trim();
				const iconUrl = DOM.editIcon.value.trim() || findLastIconForName(name, editingIndex);
				const text = DOM.editText.value;

				// Update message
				editingMessage.name = name;
				editingMessage.iconUrl = iconUrl;
				editingMessage.text = text;
				editingMessage.type = name ? "dialogue" : "narration";

				// 更新骰点结果（如果有）
				if (editingMessage.diceInfo) {
					if (isCCDiceRoll(editingMessage.diceInfo.result)) {
						// CC检定类型
						const target = parseInt(DOM.editDiceCcTarget.value, 10);
						const roll = parseInt(DOM.editDiceCcRoll.value, 10);

						if (!isNaN(target) && !isNaN(roll)) {
							if (roll < 1 || roll > 100) {
								alert("骰点结果必须在 1-100 之间");
								return;
							}
							const result = calculateCCResult(roll, target);
							editingMessage.diceInfo.result = buildCCDiceResult(target, roll, result.level);
							editingMessage.diceInfo.isCritical = result.isCritical;
							editingMessage.diceInfo.isFumble = result.isFumble;
							editingMessage.diceInfo.isSuccess = result.isSuccess;
							editingMessage.diceInfo.isFailure = result.isFailure;
						}
					} else {
						// 普通骰点类型
						const formula = DOM.editDiceFormula.value.trim();
						const roll = parseInt(DOM.editDiceResult.value, 10);

						if (formula && !isNaN(roll)) {
							// 验证结果是否在有效范围内
							const range = calculateDiceRange(formula);
							if (!range) {
								alert("无法解析骰点算式，请检查格式（如：2D6+3, 1D4+1D6）");
								return;
							}
							if (roll < range.min || roll > range.max) {
								alert(`结果超出有效范围！\n算式 ${formula} 的结果范围是 ${range.min} ~ ${range.max}`);
								return;
							}
							editingMessage.diceInfo.result = buildNormalDiceResult(formula, roll);
						}
					}
				}

				editingMessage.isEdited = true;

				state.meta.lastModified = Date.now();

				closeEditModal();
				renderMessageListFull();

				// Update player if viewing this message
				if (currentMessageIndex === editingIndex) {
					displayMessage(currentMessageIndex);
				}
			}

			/**
			 * Reset a single message to its original state
			 * @param {number} index - Message index
			 */
			function resetSingleMessage(index) {
				const msg = state.editedMessages[index];
				if (!msg) return;

				// 找到原始消息
				const originalMsg = state.originalMessages.find((m) => m.id === msg.id);
				if (!originalMsg) {
					alert("找不到原始消息，无法重置");
					return;
				}

				if (!confirm("确定要将此消息重置到原始状态吗？所有编辑将丢失。")) {
					return;
				}

				// 恢复原始内容
				msg.name = originalMsg.name;
				msg.text = originalMsg.text;
				msg.iconUrl = originalMsg.iconUrl;
				msg.type = originalMsg.type;
				msg.isEdited = false;

				// 恢复骰点信息
				if (originalMsg.diceInfo) {
					msg.diceInfo = JSON.parse(JSON.stringify(originalMsg.diceInfo));
				}

				state.meta.lastModified = Date.now();

				renderMessageListFull();

				// Update player if viewing this message
				if (currentMessageIndex === index) {
					displayMessage(currentMessageIndex);
				}
			}

			/**
			 * Open insert modal
			 * @param {number} index - Index to insert at
			 */
			function openInsertModal(index) {
				insertAtIndex = index;

				DOM.insertName.value = "";
				DOM.insertIcon.value = "";
				DOM.insertText.value = "";

				// Initialize portrait selector
				updatePortraitSelector("insert", "", "");

				DOM.modalInsert.classList.add("visible");
				DOM.insertName.focus();
			}

			/**
			 * Close insert modal
			 */
			function closeInsertModal() {
				DOM.modalInsert.classList.remove("visible");
				insertAtIndex = -1;
				closePortraitDropdown("insert");
			}

			// ============================================================
			// Insert Dice Modal Functions
			// ============================================================

			/** @type {number} */
			let insertDiceAtIndex = -1;

			/**
			 * Open insert dice modal
			 * @param {number} index - Index to insert at
			 */
			function openInsertDiceModal(index) {
				insertDiceAtIndex = index;

				// Reset form fields
				DOM.insertDiceName.value = "";
				DOM.insertDiceIcon.value = "";
				DOM.insertDiceType.value = "cc";
				DOM.insertDiceCcTarget.value = "";
				DOM.insertDiceCcRoll.value = "";
				DOM.insertDiceCcSkill.value = "";
				DOM.insertDiceFormula.value = "";
				DOM.insertDiceResult.value = "";
				DOM.insertDiceDesc.value = "";

				// Show CC section, hide normal section
				DOM.insertDiceCc.style.display = "block";
				DOM.insertDiceNormal.style.display = "none";

				// Reset preview
				DOM.insertDiceCcPreview.textContent = "--";
				DOM.insertDiceCcPreview.style.color = "";

				// Initialize portrait selector
				updatePortraitSelector("insert-dice", "", "");

				DOM.modalInsertDice.classList.add("visible");
				DOM.insertDiceName.focus();
			}

			/**
			 * Close insert dice modal
			 */
			function closeInsertDiceModal() {
				DOM.modalInsertDice.classList.remove("visible");
				insertDiceAtIndex = -1;
				closePortraitDropdown("insert-dice");
			}

			/**
			 * Update insert dice CC preview
			 */
			function updateInsertDiceCcPreview() {
				const target = parseInt(DOM.insertDiceCcTarget.value, 10);
				const roll = parseInt(DOM.insertDiceCcRoll.value, 10);

				if (isNaN(target) || isNaN(roll)) {
					DOM.insertDiceCcPreview.textContent = "--";
					DOM.insertDiceCcPreview.style.color = "";
					return;
				}

				const result = calculateCCResult(roll, target);
				DOM.insertDiceCcPreview.textContent = result.level;

				if (result.isCritical) {
					DOM.insertDiceCcPreview.style.color = "#22c55e";
				} else if (result.isFumble) {
					DOM.insertDiceCcPreview.style.color = "#ef4444";
				} else if (result.isSuccess) {
					DOM.insertDiceCcPreview.style.color = "#3b82f6";
				} else {
					DOM.insertDiceCcPreview.style.color = "#f59e0b";
				}
			}

			/**
			 * Save inserted dice message
			 */
			function saveInsertedDice() {
				const name = DOM.insertDiceName.value.trim();
				const iconUrl = DOM.insertDiceIcon.value.trim() || findLastIconForName(name, insertDiceAtIndex);
				const diceType = DOM.insertDiceType.value;

				let text = "";
				let diceInfo = null;

				if (diceType === "cc") {
					const target = parseInt(DOM.insertDiceCcTarget.value, 10);
					const roll = parseInt(DOM.insertDiceCcRoll.value, 10);
					const skill = DOM.insertDiceCcSkill.value.trim();

					if (isNaN(target) || isNaN(roll)) {
						alert("请输入技能值和骰点结果");
						return;
					}

					if (roll < 1 || roll > 100) {
						alert("骰点结果必须在 1-100 之间");
						return;
					}

					const result = calculateCCResult(roll, target);
					const resultText = buildCCDiceResult(target, roll, result.level);

					text = skill;
					diceInfo = {
						system: "coc",
						result: resultText,
					};
				} else {
					const formula = DOM.insertDiceFormula.value.trim();
					const rollResult = parseInt(DOM.insertDiceResult.value, 10);
					const desc = DOM.insertDiceDesc.value.trim();

					if (!formula) {
						alert("请输入骰点算式");
						return;
					}

					if (isNaN(rollResult)) {
						alert("请输入结果");
						return;
					}

					// 验证结果是否在有效范围内
					const range = calculateDiceRange(formula);
					if (!range) {
						alert("无法解析骰点算式，请检查格式（如：2D6+3, 1D4+1D6）");
						return;
					}

					if (rollResult < range.min || rollResult > range.max) {
						alert(`结果超出有效范围！\n算式 ${formula} 的结果范围是 ${range.min} ~ ${range.max}`);
						return;
					}

					const resultText = buildNormalDiceResult(formula, rollResult);

					text = desc;
					diceInfo = {
						system: "coc",
						result: resultText,
					};
				}

				const newMsg = {
					id: generateId(),
					type: "dice",
					name: name,
					text: text,
					iconUrl: iconUrl,
					color: "",
					channelName: "",
					timestamp: Date.now(),
					isInserted: true,
					diceInfo: diceInfo,
				};

				// Insert at specified index
				state.editedMessages.splice(insertDiceAtIndex, 0, newMsg);
				state.meta.lastModified = Date.now();

				closeInsertDiceModal();

				// Navigate to the page containing the new message
				currentPage = Math.floor(insertDiceAtIndex / pageSize) + 1;
				renderMessageListFull();
				updateProgress();
			}

			// ============================================================
			// Rename Modal Functions
			// ============================================================

			/** @type {string|null} */
			let renamingCharacter = null;

			/**
			 * Open rename modal for a character
			 * @param {string} characterName - Character name to rename
			 */
			function openRenameModal(characterName) {
				const char = CharacterManager.getCharacter(characterName);
				if (!char) {
					alert("角色不存在");
					return;
				}

				renamingCharacter = characterName;
				DOM.renameCharacterName.value = characterName;
				DOM.modalRename.classList.add("visible");
				DOM.renameCharacterName.focus();
				DOM.renameCharacterName.select(); // Select all text for easy editing
			}

			/**
			 * Close rename modal
			 */
			function closeRenameModal() {
				DOM.modalRename.classList.remove("visible");
				renamingCharacter = null;
			}

			/**
			 * Confirm character rename
			 */
			function confirmRename() {
				if (!renamingCharacter) return;

				const newName = DOM.renameCharacterName.value.trim();
				if (!newName) {
					alert("请输入角色名称");
					return;
				}

				// Check if the name is the same as the original
				if (newName === renamingCharacter) {
					alert("名称没有变化");
					return;
				}

				try {
					const result = CharacterManager.renameCharacter(renamingCharacter, newName);

					let message = "";
					if (result.type === "renamed") {
						message = `角色 "${result.oldName}" 已重命名为 "${result.newName}"\n更新了 ${result.updatedMessageCount} 条消息`;
					} else if (result.type === "merged") {
						message =
							`角色 "${result.oldName}" 已合并到 "${result.newName}"\n` +
							`更新了 ${result.updatedMessageCount} 条消息\n` +
							`合并了 ${result.mergedPortraits} 个新立绘，总计 ${result.totalPortraits} 个立绘`;
					}

					alert(message);

					// 关闭模态框
					closeRenameModal();

					// 刷新UI
					renderCharacterGrid();

					// 如果当前在详情页面，跳转到新角色（无论是重命名还是合并）
					if (isDetailPageVisible) {
						currentDetailCharacter = newName;
						renderCharacterDetailPage();
						updateCharacterDetailButton(); // 更新标签按钮显示的角色名
					}

					// 刷新消息列表
					renderMessageListFull();
				} catch (error) {
					alert("重命名失败：" + error.message);
				}
			}

			/**
			 * Insert new message
			 */
			function insertNewMessage() {
				const name = DOM.insertName.value.trim();
				const iconUrl = DOM.insertIcon.value.trim() || findLastIconForName(name, insertAtIndex);
				const text = DOM.insertText.value;

				const newMsg = {
					id: generateId(),
					type: name ? "dialogue" : "narration",
					name: name,
					text: text,
					iconUrl: iconUrl,
					color: "",
					channelName: "",
					timestamp: Date.now(),
					isInserted: true,
				};

				// Insert at specified index
				state.editedMessages.splice(insertAtIndex, 0, newMsg);
				state.meta.lastModified = Date.now();

				closeInsertModal();

				// Navigate to the page containing the new message
				currentPage = Math.floor(insertAtIndex / pageSize) + 1;
				renderMessageListFull();
				updateProgress();
			}

			// ============================================================
			// Stage Modal Functions
			// ============================================================

			/** @type {Message|null} */
			let stagingMessage = null;

			/** @type {number} */
			let stagingIndex = -1;

			/**
			 * Open stage modal for a message
			 * @param {Message} msg - Message to configure
			 * @param {number} index - Message index
			 */
			function openStageModal(msg, index) {
				stagingMessage = msg;
				stagingIndex = index;

				const characters = extractCharacters(state.editedMessages);
				const currentEnter = msg.stageEnter || [];
				const currentExit = msg.stageExit || [];

				// Calculate which characters are on stage BEFORE this message
				// (not including this message's enter/exit)
				const onStageBeforeThis = new Set();
				for (let i = 0; i < index; i++) {
					const m = state.editedMessages[i];
					if (m.stageEnter) {
						m.stageEnter.forEach((name) => onStageBeforeThis.add(name));
					}
					if (m.stageExit) {
						m.stageExit.forEach((name) => onStageBeforeThis.delete(name));
					}
				}

				// Render enter list - only show characters NOT currently on stage
				// (plus those already marked for enter in this message)
				if (characters.size === 0) {
					DOM.stageEnterList.innerHTML =
						'<span style="color: var(--text-secondary); font-size: 0.8rem;">没有找到角色</span>';
					DOM.stageExitList.innerHTML =
						'<span style="color: var(--text-secondary); font-size: 0.8rem;">没有找到角色</span>';
				} else {
					// For enter: show characters not on stage (or already checked for enter)
					const enterCandidates = Array.from(characters.entries()).filter(([name]) => {
						return !onStageBeforeThis.has(name) || currentEnter.includes(name);
					});

					if (enterCandidates.length === 0) {
						DOM.stageEnterList.innerHTML =
							'<span style="color: var(--text-secondary); font-size: 0.8rem;">所有角色都已在场</span>';
					} else {
						DOM.stageEnterList.innerHTML = enterCandidates
							.map(([name, iconUrl]) => {
								const isChecked = currentEnter.includes(name);
								return `
									<label class="flex items-center gap-2" style="margin-bottom: 4px; cursor: pointer;">
										<input type="checkbox" class="stage-enter-checkbox" value="${name}" ${isChecked ? "checked" : ""} />
										<img src="${iconUrl}" style="width: 24px; height: 24px; border-radius: 4px; object-fit: cover;" onerror="this.style.display='none'" />
										<span style="font-size: 0.85rem;">${name}</span>
									</label>
								`;
							})
							.join("");
					}

					// For exit: show characters on stage (or already checked for exit)
					const exitCandidates = Array.from(characters.entries()).filter(([name]) => {
						return onStageBeforeThis.has(name) || currentExit.includes(name);
					});

					if (exitCandidates.length === 0) {
						DOM.stageExitList.innerHTML =
							'<span style="color: var(--text-secondary); font-size: 0.8rem;">没有角色在场</span>';
					} else {
						DOM.stageExitList.innerHTML = exitCandidates
							.map(([name, iconUrl]) => {
								const isChecked = currentExit.includes(name);
								return `
									<label class="flex items-center gap-2" style="margin-bottom: 4px; cursor: pointer;">
										<input type="checkbox" class="stage-exit-checkbox" value="${name}" ${isChecked ? "checked" : ""} />
										<img src="${iconUrl}" style="width: 24px; height: 24px; border-radius: 4px; object-fit: cover;" onerror="this.style.display='none'" />
										<span style="font-size: 0.85rem;">${name}</span>
									</label>
								`;
							})
							.join("");
					}
				}

				DOM.modalStage.classList.add("visible");
			}

			/**
			 * Close stage modal
			 */
			function closeStageModal() {
				DOM.modalStage.classList.remove("visible");
				stagingMessage = null;
				stagingIndex = -1;
			}

			/**
			 * Save stage configuration
			 */
			function saveStageConfig() {
				if (!stagingMessage) return;

				// Get selected enter characters
				const enterCheckboxes = DOM.stageEnterList.querySelectorAll(".stage-enter-checkbox:checked");
				const enterNames = Array.from(enterCheckboxes).map((cb) => cb.value);

				// Get selected exit characters
				const exitCheckboxes = DOM.stageExitList.querySelectorAll(".stage-exit-checkbox:checked");
				const exitNames = Array.from(exitCheckboxes).map((cb) => cb.value);

				// Update message
				stagingMessage.stageEnter = enterNames.length > 0 ? enterNames : undefined;
				stagingMessage.stageExit = exitNames.length > 0 ? exitNames : undefined;

				state.meta.lastModified = Date.now();

				closeStageModal();
				renderMessageListFull();

				// Rebuild stage snapshots after editing
				buildStageSnapshots();

				// Apply snapshot for current message
				applyStageSnapshot(currentMessageIndex);
				displayMessage(currentMessageIndex, true);
			}

			// ============================================================
			// Background Modal Functions
			// ============================================================

			/** @type {Message|null} */
			let backgroundMessage = null;

			/** @type {number} */
			let backgroundIndex = -1;

			/** @type {string|null} - Current background URL being displayed */
			let currentBackgroundUrl = null;

			/**
			 * Open background modal for a message
			 * @param {Message} msg - Message to configure
			 * @param {number} index - Message index
			 */
			function openBackgroundModal(msg, index) {
				backgroundMessage = msg;
				backgroundIndex = index;

				// Set current value
				DOM.backgroundUrlInput.value = msg.backgroundUrl || "";
				updateBackgroundPreview(msg.backgroundUrl || "");

				DOM.modalBackground.classList.add("visible");
				DOM.backgroundUrlInput.focus();
			}

			/**
			 * Close background modal
			 */
			function closeBackgroundModal() {
				DOM.modalBackground.classList.remove("visible");
				backgroundMessage = null;
				backgroundIndex = -1;
			}

			/**
			 * Update background preview
			 * @param {string} url - Background URL
			 */
			function updateBackgroundPreview(url) {
				if (url && url.trim()) {
					DOM.backgroundPreview.style.backgroundImage = `url(${url})`;
					DOM.backgroundPreview.textContent = "";
				} else {
					DOM.backgroundPreview.style.backgroundImage = "none";
					DOM.backgroundPreview.textContent = "无背景";
				}
			}

			/**
			 * Save background configuration
			 */
			function saveBackgroundConfig() {
				if (!backgroundMessage) return;

				const url = DOM.backgroundUrlInput.value.trim();
				backgroundMessage.backgroundUrl = url || undefined;

				state.meta.lastModified = Date.now();

				closeBackgroundModal();
				renderMessageListFull();
				renderBackgroundSwitchList();

				// Update background display if viewing this message
				updateBackground(currentMessageIndex);
			}

			/**
			 * Remove background from message
			 */
			function removeBackgroundConfig() {
				if (!backgroundMessage) return;

				backgroundMessage.backgroundUrl = undefined;

				state.meta.lastModified = Date.now();

				closeBackgroundModal();
				renderMessageListFull();
				renderBackgroundSwitchList();

				// Update background display
				updateBackground(currentMessageIndex);
			}

			// ============================================================
			// BGM Modal Functions
			// ============================================================

			/** @type {Message|null} */
			let bgmMessage = null;

			/** @type {number} */
			let bgmIndex = -1;

			/** @type {HTMLAudioElement|null} */
			let bgmPreviewAudio = null;

			/**
			 * Open BGM modal for a message
			 * @param {Message} msg - Message to configure
			 * @param {number} index - Message index
			 */
			function openBgmModal(msg, index) {
				bgmMessage = msg;
				bgmIndex = index;

				// Set current value
				CustomSelect.setValue(DOM.bgmModalSelect, msg.bgmUrl || "");
				updateBgmPreviewStatus("选择 BGM 后点击播放预览");
				DOM.bgmPreviewBtn.textContent = "▶️";
				DOM.bgmPreviewVolume.value = state.bgmSettings.volume * 100;

				// Stop any previous preview
				stopBgmPreview();

				DOM.modalBgm.classList.add("visible");
			}

			/**
			 * Close BGM modal
			 */
			function closeBgmModal() {
				stopBgmPreview();
				DOM.modalBgm.classList.remove("visible");
				bgmMessage = null;
				bgmIndex = -1;
			}

			/**
			 * Update BGM preview status text
			 * @param {string} text - Status text
			 */
			function updateBgmPreviewStatus(text) {
				DOM.bgmPreviewStatus.textContent = text;
			}

			/**
			 * Toggle BGM preview playback
			 */
			function toggleBgmPreview() {
				const url = CustomSelect.getValue(DOM.bgmModalSelect);
				if (!url) {
					updateBgmPreviewStatus("请先选择 BGM");
					return;
				}

				if (bgmPreviewAudio && !bgmPreviewAudio.paused) {
					// Pause
					bgmPreviewAudio.pause();
					DOM.bgmPreviewBtn.textContent = "▶️";
					updateBgmPreviewStatus("已暂停");
				} else {
					// Play
					if (!bgmPreviewAudio || bgmPreviewAudio.src !== url) {
						bgmPreviewAudio = new Audio(url);
						bgmPreviewAudio.volume = DOM.bgmPreviewVolume.value / 100;
						bgmPreviewAudio.loop = true;

						bgmPreviewAudio.addEventListener("loadstart", () => {
							updateBgmPreviewStatus("加载中...");
						});

						bgmPreviewAudio.addEventListener("canplay", () => {
							updateBgmPreviewStatus("正在播放");
						});

						bgmPreviewAudio.addEventListener("error", () => {
							updateBgmPreviewStatus("⚠️ 无法加载音频");
							DOM.bgmPreviewBtn.textContent = "▶️";
						});
					}

					bgmPreviewAudio.play().catch((e) => {
						updateBgmPreviewStatus("⚠️ 播放失败: " + e.message);
					});
					DOM.bgmPreviewBtn.textContent = "⏸️";
				}
			}

			/**
			 * Stop BGM preview
			 */
			function stopBgmPreview() {
				if (bgmPreviewAudio) {
					bgmPreviewAudio.pause();
					bgmPreviewAudio.currentTime = 0;
					bgmPreviewAudio = null;
				}
				DOM.bgmPreviewBtn.textContent = "▶️";
			}

			/**
			 * Save BGM configuration
			 */
			function saveBgmConfig() {
				if (!bgmMessage) return;

				const url = CustomSelect.getValue(DOM.bgmModalSelect);
				bgmMessage.bgmUrl = url || undefined;

				state.meta.lastModified = Date.now();

				closeBgmModal();
				renderMessageListFull();
				renderBgmSwitchList();

				// Update BGM if viewing this message
				BGMManager.updateBGM(currentMessageIndex);
			}

			/**
			 * Set BGM to stop (empty string means stop BGM)
			 */
			function setBgmStop() {
				if (!bgmMessage) return;

				bgmMessage.bgmUrl = ""; // Empty string means stop BGM

				state.meta.lastModified = Date.now();

				closeBgmModal();
				renderMessageListFull();
				renderBgmSwitchList();

				// Update BGM
				BGMManager.updateBGM(currentMessageIndex);
			}

			/**
			 * Remove BGM setting from message
			 */
			function removeBgmConfig() {
				if (!bgmMessage) return;

				bgmMessage.bgmUrl = undefined;

				state.meta.lastModified = Date.now();

				closeBgmModal();
				renderMessageListFull();
				renderBgmSwitchList();

				// Update BGM
				BGMManager.updateBGM(currentMessageIndex);
			}

			/**
			 * Render BGM switch point list
			 */
			function renderBgmSwitchList() {
				// Find all messages with BGM settings
				const switchPoints = [];
				state.editedMessages.forEach((msg, index) => {
					if (msg.bgmUrl !== undefined) {
						switchPoints.push({ msg, index });
					}
				});

				if (switchPoints.length === 0) {
					DOM.bgmSwitchList.innerHTML =
						'<span style="color: var(--text-secondary); font-size: 0.8rem;">暂无 BGM 切换点</span>';
					return;
				}

				DOM.bgmSwitchList.innerHTML = switchPoints
					.map(({ msg, index }) => {
						const displayName = msg.name || (msg.type === "narration" ? "旁白" : "");
						const truncatedText = msg.text ? (msg.text.length > 20 ? msg.text.substring(0, 20) + "..." : msg.text) : "";
						const isStop = !msg.bgmUrl;
						const bgmDisplay = isStop
							? '<span style="color: var(--error-color)">🔇 停止</span>'
							: `🎵 ${msg.bgmUrl.length > 25 ? msg.bgmUrl.substring(0, 25) + "..." : msg.bgmUrl}`;

						return `
						<div class="bgm-switch-item" data-index="${index}">
							<div class="bgm-icon" style="font-size: 1.2rem; flex-shrink: 0">${isStop ? "🔇" : "🎵"}</div>
							<div class="bgm-info" style="flex: 1; min-width: 0">
								<div class="bgm-message" style="font-size: 0.8rem; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
									${displayName ? displayName + ": " : ""}${truncatedText}
								</div>
								<div class="bgm-url" style="font-size: 0.7rem; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
									#${index + 1} - ${isStop ? "停止播放" : msg.bgmUrl}
								</div>
							</div>
							<button class="bgm-remove" data-index="${index}" title="移除设置" style="
								padding: 4px 8px;
								border: none;
								border-radius: var(--radius-sm);
								background: transparent;
								color: var(--text-secondary);
								cursor: pointer;
								transition: all 0.2s;
							">🗑️</button>
						</div>
					`;
					})
					.join("");

				// Add click handlers for remove buttons
				DOM.bgmSwitchList.querySelectorAll(".bgm-remove").forEach((btn) => {
					btn.addEventListener("click", (e) => {
						e.stopPropagation();
						const index = parseInt(btn.dataset.index, 10);
						const msg = state.editedMessages[index];
						if (msg) {
							msg.bgmUrl = undefined;
							state.meta.lastModified = Date.now();
							renderMessageListFull();
							renderBgmSwitchList();
							BGMManager.updateBGM(currentMessageIndex);
						}
					});
				});

				// Add click handlers for items to jump to message
				DOM.bgmSwitchList.querySelectorAll(".bgm-switch-item").forEach((item) => {
					item.addEventListener("click", (e) => {
						if (e.target.closest(".bgm-remove")) return;
						const index = parseInt(item.dataset.index, 10);
						currentMessageIndex = index;
						displayMessage(index);
						updateProgress();
						switchView("list");
						// Scroll to the message in list
						const pageNum = Math.floor(index / pageSize) + 1;
						if (pageNum !== currentPage) {
							currentPage = pageNum;
							renderMessageListFull();
						}
					});
				});
			}

			/**
			 * Render BGM library list
			 */
			function renderBgmLibraryList() {
				if (state.bgmLibrary.length === 0) {
					DOM.bgmLibraryList.innerHTML =
						'<span style="color: var(--text-secondary); font-size: 0.8rem;">暂无 BGM，点击上方按钮添加</span>';
					updateBgmSelectOptions();
					return;
				}

				DOM.bgmLibraryList.innerHTML = state.bgmLibrary
					.map(
						(item) => `
					<div class="bgm-library-item" data-id="${item.id}" style="
						display: flex;
						align-items: center;
						gap: 8px;
						padding: 8px;
						border-bottom: 1px solid var(--border-color);
						cursor: pointer;
						transition: background 0.2s;
					">
						<div style="flex: 1; min-width: 0;">
							<div style="font-size: 0.85rem; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
								${escapeHtml(item.name)}
							</div>
							<div style="font-size: 0.7rem; color: var(--text-secondary); display: flex; align-items: center; gap: 4px;">
								<span style="
									padding: 1px 4px;
									border-radius: 2px;
									background: ${
										item.source === "ccfolia"
											? "var(--primary-color)"
											: item.source === "account"
											? "#9b59b6"
											: "var(--success-color)"
									};
									color: #fff;
									font-size: 0.65rem;
								">${item.source === "ccfolia" ? "房间" : item.source === "account" ? "账号" : "自定义"}</span>
								${item.sceneName ? `<span>场景: ${escapeHtml(item.sceneName)}</span>` : ""}
							</div>
						</div>
						<button class="bgm-library-use" data-url="${escapeHtml(item.url)}" title="使用此 BGM" style="
							padding: 4px 8px;
							border: none;
							border-radius: var(--radius-sm);
							background: var(--primary-color);
							color: #fff;
							cursor: pointer;
							font-size: 0.75rem;
						">使用</button>
						<button class="bgm-library-remove" data-id="${item.id}" title="删除" style="
							padding: 4px 8px;
							border: none;
							border-radius: var(--radius-sm);
							background: transparent;
							color: var(--text-secondary);
							cursor: pointer;
						">🗑️</button>
					</div>
				`
					)
					.join("");

				// Add click handlers for use buttons
				DOM.bgmLibraryList.querySelectorAll(".bgm-library-use").forEach((btn) => {
					btn.addEventListener("click", (e) => {
						e.stopPropagation();
						const url = btn.dataset.url;
						state.bgmSettings.defaultBgmUrl = url;
						CustomSelect.setValue(DOM.defaultBgmSelect, url);
						state.meta.lastModified = Date.now();
						BGMManager.updateBGM(currentMessageIndex);
						showSuccess("已设置为默认 BGM");
					});
				});

				// Add click handlers for remove buttons
				DOM.bgmLibraryList.querySelectorAll(".bgm-library-remove").forEach((btn) => {
					btn.addEventListener("click", (e) => {
						e.stopPropagation();
						const id = btn.dataset.id;
						removeBgmFromLibrary(id);
						renderBgmLibraryList();
					});
				});

				updateBgmSelectOptions();
			}

			/**
			 * Custom Select Component Helper
			 */
			const CustomSelect = {
				/**
				 * Initialize a custom select
				 * @param {HTMLElement} container - The .custom-select container
				 * @param {Array<{value: string, label: string}>} options - Options array
				 * @param {string} placeholder - Placeholder text
				 * @param {Function} onChange - Callback when value changes
				 */
				init(container, options, placeholder, onChange) {
					const trigger = container.querySelector(".custom-select-trigger");
					const dropdown = container.querySelector(".custom-select-dropdown");

					// Store data
					container._options = options;
					container._value = "";
					container._placeholder = placeholder;
					container._onChange = onChange;

					// Render options
					this.renderOptions(container);

					// Toggle dropdown on trigger click
					trigger.addEventListener("click", (e) => {
						e.stopPropagation();
						// Close other open selects
						document.querySelectorAll(".custom-select.open").forEach((el) => {
							if (el !== container) el.classList.remove("open");
						});
						container.classList.toggle("open");
					});

					// Close on outside click
					document.addEventListener("click", () => {
						container.classList.remove("open");
					});

					// Prevent dropdown clicks from closing
					dropdown.addEventListener("click", (e) => {
						e.stopPropagation();
					});
				},

				/**
				 * Render options in dropdown
				 */
				renderOptions(container) {
					const dropdown = container.querySelector(".custom-select-dropdown");
					const options = container._options || [];

					if (options.length === 0) {
						dropdown.innerHTML = '<div class="custom-select-option empty">暂无可选项</div>';
						return;
					}

					dropdown.innerHTML = options
						.map(
							(opt) => `
						<div class="custom-select-option${opt.value === container._value ? " selected" : ""}"
							 data-value="${escapeHtml(opt.value)}"
							 title="${escapeHtml(opt.label)}">
							${escapeHtml(opt.label)}
						</div>
					`
						)
						.join("");

					// Add click handlers
					dropdown.querySelectorAll(".custom-select-option:not(.empty)").forEach((opt) => {
						opt.addEventListener("click", () => {
							this.setValue(container, opt.dataset.value);
							container.classList.remove("open");
						});
					});
				},

				/**
				 * Set value
				 */
				setValue(container, value) {
					const trigger = container.querySelector(".custom-select-trigger");
					const options = container._options || [];
					const option = options.find((o) => o.value === value);

					container._value = value;

					if (option && option.value) {
						trigger.textContent = option.label;
						trigger.classList.remove("placeholder");
					} else {
						trigger.textContent = container._placeholder;
						trigger.classList.add("placeholder");
					}

					// Update selected state
					this.renderOptions(container);

					// Trigger callback
					if (container._onChange) {
						container._onChange(value);
					}
				},

				/**
				 * Get current value
				 */
				getValue(container) {
					return container._value || "";
				},

				/**
				 * Update options
				 */
				setOptions(container, options) {
					container._options = options;
					this.renderOptions(container);

					// If current value is not in new options, reset
					if (container._value && !options.find((o) => o.value === container._value)) {
						this.setValue(container, "");
					}
				},
			};

			/**
			 * Update BGM select dropdown options
			 */
			function updateBgmSelectOptions() {
				// 构建选项数组
				const defaultOptions = [{ value: "", label: "无（不播放背景音乐）" }];
				const modalOptions = [{ value: "", label: "请选择..." }];

				state.bgmLibrary.forEach((item) => {
					const opt = { value: item.url, label: item.name };
					defaultOptions.push(opt);
					modalOptions.push(opt);
				});

				// 更新默认 BGM 下拉框
				CustomSelect.setOptions(DOM.defaultBgmSelect, defaultOptions);
				// 更新模态框下拉框
				CustomSelect.setOptions(DOM.bgmModalSelect, modalOptions);

				// 恢复当前选中的默认 BGM
				if (state.bgmSettings.defaultBgmUrl) {
					CustomSelect.setValue(DOM.defaultBgmSelect, state.bgmSettings.defaultBgmUrl);
				}
			}

			/**
			 * Initialize custom selects
			 */
			function initBgmSelects() {
				// 默认 BGM 选择器
				CustomSelect.init(
					DOM.defaultBgmSelect,
					[{ value: "", label: "无（不播放背景音乐）" }],
					"无（不播放背景音乐）",
					(value) => {
						state.bgmSettings.defaultBgmUrl = value;
						state.meta.lastModified = Date.now();
						BGMManager.updateBGM(currentMessageIndex);
					}
				);

				// 模态框 BGM 选择器
				CustomSelect.init(DOM.bgmModalSelect, [{ value: "", label: "请选择..." }], "请选择...", (value) => {
					stopBgmPreview();
					if (value) {
						updateBgmPreviewStatus("已选择，点击播放预览");
					} else {
						updateBgmPreviewStatus("请选择 BGM");
					}
				});
			}

			/**
			 * Get the effective background URL for a message index
			 * Looks backwards to find the most recent background setting
			 * @param {number} index - Message index
			 * @returns {string} Background URL or default background
			 */
			function getEffectiveBackground(index) {
				// Look backwards from current index to find the most recent background setting
				for (let i = index; i >= 0; i--) {
					const msg = state.editedMessages[i];
					if (msg.backgroundUrl) {
						return msg.backgroundUrl;
					}
				}
				// Return default background if no switch point found
				return state.settings.defaultBackground || "";
			}

			/**
			 * Update background display with transition animation
			 * @param {number} index - Current message index
			 */
			function updateBackground(index) {
				const newBgUrl = getEffectiveBackground(index);

				// Skip if background hasn't changed
				if (newBgUrl === currentBackgroundUrl) return;

				const portraitArea = DOM.portraitArea;

				if (newBgUrl) {
					// If there's a current background, do crossfade transition
					if (currentBackgroundUrl) {
						// Set the new background on the ::before pseudo-element via CSS variable
						portraitArea.style.setProperty("--new-bg", `url(${newBgUrl})`);
						portraitArea.classList.add("bg-transitioning");

						// After transition, update main background and remove transition class
						setTimeout(() => {
							portraitArea.style.backgroundImage = `url(${newBgUrl})`;
							portraitArea.classList.remove("bg-transitioning");
						}, 500);
					} else {
						// No current background, just set it directly with fade in
						portraitArea.style.backgroundImage = `url(${newBgUrl})`;
					}
				} else {
					// Remove background
					portraitArea.style.backgroundImage = "none";
				}

				currentBackgroundUrl = newBgUrl;

				// Also update canvas inner background if in canvas mode
				if (state.portraitConfig.scaleMode === "canvas") {
					const canvasInner = portraitArea.querySelector(".portrait-canvas-inner");
					if (canvasInner) {
						if (newBgUrl) {
							canvasInner.style.backgroundImage = `url(${newBgUrl})`;
							canvasInner.style.backgroundSize = "cover";
							canvasInner.style.backgroundPosition = "center";
						} else {
							canvasInner.style.backgroundImage = "none";
						}
					}
				}
			}

			/**
			 * Render background switch list in editor panel
			 */
			function renderBackgroundSwitchList() {
				const switchPoints = [];

				// Find all messages with background settings
				state.editedMessages.forEach((msg, index) => {
					if (msg.backgroundUrl) {
						switchPoints.push({ msg, index });
					}
				});

				if (switchPoints.length === 0) {
					DOM.backgroundSwitchList.innerHTML =
						'<span style="color: var(--text-secondary); font-size: 0.8rem;">暂无背景切换点</span>';
					return;
				}

				DOM.backgroundSwitchList.innerHTML = switchPoints
					.map(({ msg, index }) => {
						const displayName = msg.name || (msg.type === "narration" ? "旁白" : "");
						const truncatedText = msg.text && msg.text.length > 20 ? msg.text.substring(0, 20) + "..." : msg.text || "";
						return `
						<div class="background-switch-item" data-index="${index}">
							<div class="bg-thumbnail" style="background-image: url(${msg.backgroundUrl})"></div>
							<div class="bg-info">
								<div class="bg-message">${displayName ? displayName + ": " : ""}${truncatedText}</div>
								<div class="bg-index">#${index + 1}</div>
							</div>
							<button class="bg-remove" data-index="${index}" title="移除背景">🗑️</button>
						</div>
					`;
					})
					.join("");

				// Add click handlers
				DOM.backgroundSwitchList.querySelectorAll(".background-switch-item").forEach((item) => {
					item.addEventListener("click", (e) => {
						if (e.target.closest(".bg-remove")) return;
						const index = parseInt(item.dataset.index, 10);
						jumpToMessage(index);
						switchView("replay");
					});
				});

				// Add remove handlers
				DOM.backgroundSwitchList.querySelectorAll(".bg-remove").forEach((btn) => {
					btn.addEventListener("click", (e) => {
						e.stopPropagation();
						const index = parseInt(btn.dataset.index, 10);
						const msg = state.editedMessages[index];
						if (msg) {
							msg.backgroundUrl = undefined;
							state.meta.lastModified = Date.now();
							renderMessageListFull();
							renderBackgroundSwitchList();
							updateBackground(currentMessageIndex);
						}
					});
				});
			}

			// Background modal event listeners
			DOM.modalBackgroundClose.addEventListener("click", closeBackgroundModal);
			DOM.modalBackgroundCancel.addEventListener("click", closeBackgroundModal);
			DOM.modalBackgroundSave.addEventListener("click", saveBackgroundConfig);
			DOM.modalBackgroundRemove.addEventListener("click", removeBackgroundConfig);

			setupModalOverlayClose(DOM.modalBackground, closeBackgroundModal);

			// Update preview when URL input changes
			DOM.backgroundUrlInput.addEventListener("input", (e) => {
				updateBackgroundPreview(e.target.value);
			});

			// BGM modal event listeners
			DOM.modalBgmClose.addEventListener("click", closeBgmModal);
			DOM.modalBgmCancel.addEventListener("click", closeBgmModal);
			DOM.modalBgmSave.addEventListener("click", saveBgmConfig);
			DOM.modalBgmStop.addEventListener("click", setBgmStop);
			DOM.modalBgmRemove.addEventListener("click", removeBgmConfig);
			DOM.bgmPreviewBtn.addEventListener("click", toggleBgmPreview);

			setupModalOverlayClose(DOM.modalBgm, closeBgmModal);

			// Update preview volume when slider changes
			DOM.bgmPreviewVolume.addEventListener("input", (e) => {
				if (bgmPreviewAudio) {
					bgmPreviewAudio.volume = e.target.value / 100;
				}
			});

			// Default background input handler
			DOM.defaultBg.addEventListener("change", (e) => {
				state.settings.defaultBackground = e.target.value.trim();
				state.meta.lastModified = Date.now();
				// Update background if no switch point is active
				updateBackground(currentMessageIndex);
			});

			// BGM volume slider handler
			DOM.bgmVolumeSlider.addEventListener("input", (e) => {
				const volume = parseInt(e.target.value, 10) / 100;
				DOM.bgmVolumeValue.textContent = `${e.target.value}%`;
				BGMManager.setVolume(volume);
			});

			// BGM mute button handler
			DOM.bgmMuteBtn.addEventListener("click", () => {
				BGMManager.toggleMute();
				DOM.bgmMuteBtn.textContent = state.bgmSettings.muted ? "🔇" : "🔊";
			});

			// BGM loop checkbox handler
			DOM.bgmLoopCheckbox.addEventListener("change", (e) => {
				BGMManager.setLoop(e.target.checked);
			});

			// ============================================================
			// BGM Import Modal Handlers
			// ============================================================

			/** @type {Array<{sceneName: string, mediaName: string, mediaUrl: string, selected: boolean}>} */
			let bgmImportScenes = [];

			function openBgmImportModal() {
				bgmImportScenes = [];
				DOM.bgmImportRoomId.value = state.meta.roomId || "";
				DOM.bgmImportList.innerHTML =
					'<span style="color: var(--text-secondary); font-size: 0.85rem">输入房间 ID 后点击获取</span>';
				DOM.bgmImportStatus.textContent = "";
				DOM.modalBgmImportConfirm.disabled = true;
				DOM.modalBgmImport.classList.add("visible");
			}

			function closeBgmImportModal() {
				DOM.modalBgmImport.classList.remove("visible");
				bgmImportScenes = [];
			}

			async function fetchBgmFromRoom() {
				const roomId = DOM.bgmImportRoomId.value.trim();
				if (!roomId) {
					DOM.bgmImportStatus.textContent = "请输入房间 ID";
					DOM.bgmImportStatus.style.color = "var(--error-color)";
					return;
				}

				DOM.bgmImportFetchBtn.disabled = true;
				DOM.bgmImportFetchBtn.textContent = "获取中...";
				DOM.bgmImportStatus.textContent = "";
				DOM.bgmImportList.innerHTML =
					'<span style="color: var(--text-secondary); font-size: 0.85rem">正在获取...</span>';

				const { scenes, error } = await fetchCcfoliaScenes(roomId);

				DOM.bgmImportFetchBtn.disabled = false;
				DOM.bgmImportFetchBtn.textContent = "获取";

				if (error) {
					DOM.bgmImportStatus.textContent = error;
					DOM.bgmImportStatus.style.color = "var(--error-color)";
					DOM.bgmImportList.innerHTML =
						'<span style="color: var(--text-secondary); font-size: 0.85rem">获取失败</span>';
					return;
				}

				if (scenes.length === 0) {
					DOM.bgmImportStatus.textContent = "该房间没有包含 BGM 的场景";
					DOM.bgmImportStatus.style.color = "var(--warning-color)";
					DOM.bgmImportList.innerHTML =
						'<span style="color: var(--text-secondary); font-size: 0.85rem">无可用 BGM</span>';
					return;
				}

				// 标记已存在的 URL
				bgmImportScenes = scenes.map((scene) => ({
					...scene,
					selected: false,
					exists: state.bgmLibrary.some((item) => item.url === scene.mediaUrl),
				}));

				renderBgmImportList();
				DOM.bgmImportStatus.textContent = `找到 ${scenes.length} 个场景 BGM`;
				DOM.bgmImportStatus.style.color = "var(--success-color)";
			}

			function renderBgmImportList() {
				if (bgmImportScenes.length === 0) {
					DOM.bgmImportList.innerHTML =
						'<span style="color: var(--text-secondary); font-size: 0.85rem">无可用 BGM</span>';
					return;
				}

				DOM.bgmImportList.innerHTML = bgmImportScenes
					.map(
						(scene, index) => `
					<div class="bgm-import-item" style="
						display: flex;
						align-items: center;
						gap: 8px;
						padding: 8px;
						border-bottom: 1px solid var(--border-color);
						${scene.exists ? "opacity: 0.5;" : ""}
					">
						<input type="checkbox"
							id="bgm-import-${index}"
							${scene.selected ? "checked" : ""}
							${scene.exists ? "disabled" : ""}
							onchange="toggleBgmImportItem(${index})"
						/>
						<div style="flex: 1; min-width: 0;">
							<div style="font-size: 0.85rem; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
								${escapeHtml(scene.mediaName || "未命名")}
							</div>
							<div style="font-size: 0.75rem; color: var(--text-secondary);">
								场景: ${escapeHtml(scene.sceneName)}
								${scene.exists ? '<span style="color: var(--warning-color);">(已存在)</span>' : ""}
							</div>
						</div>
					</div>
				`
					)
					.join("");

				updateBgmImportConfirmBtn();
			}

			function toggleBgmImportItem(index) {
				if (bgmImportScenes[index]) {
					bgmImportScenes[index].selected = !bgmImportScenes[index].selected;
					updateBgmImportConfirmBtn();
				}
			}

			function updateBgmImportConfirmBtn() {
				const selectedCount = bgmImportScenes.filter((s) => s.selected && !s.exists).length;
				DOM.modalBgmImportConfirm.disabled = selectedCount === 0;
				DOM.modalBgmImportConfirm.textContent = selectedCount > 0 ? `导入选中 (${selectedCount})` : "导入选中";
			}

			function confirmBgmImport() {
				const toImport = bgmImportScenes.filter((s) => s.selected && !s.exists);
				if (toImport.length === 0) return;

				addScenesToBgmLibrary(toImport);
				renderBgmLibraryList();
				closeBgmImportModal();
				showSuccess(`已导入 ${toImport.length} 个 BGM`);
			}

			// BGM Import Modal Event Listeners
			DOM.modalBgmImportClose.addEventListener("click", closeBgmImportModal);
			DOM.modalBgmImportCancel.addEventListener("click", closeBgmImportModal);
			setupModalOverlayClose(DOM.modalBgmImport, closeBgmImportModal);
			DOM.bgmImportFetchBtn.addEventListener("click", fetchBgmFromRoom);
			DOM.modalBgmImportConfirm.addEventListener("click", confirmBgmImport);

			// ============================================================
			// Account BGM Import Modal Handlers
			// ============================================================

			const FIREBASE_API_KEY = "AIzaSyAMlcPs4ekVSBdzpRdEloqQ8lIgP9lEnRI";

			/** @type {Array<{id: string, name: string, url: string, selected: boolean, exists: boolean}>} */
			let accountMediaItems = [];
			let accountUserId = null;
			let accountToken = null;

			function openBgmAccountModal() {
				// 重置状态
				accountMediaItems = [];
				accountUserId = null;
				accountToken = null;
				DOM.accountEmail.value = "";
				DOM.accountPassword.value = "";
				DOM.accountLoginStatus.textContent = "";
				DOM.accountLoginStatus.style.color = "";
				DOM.accountLoginForm.style.display = "block";
				DOM.accountMediaSection.style.display = "none";
				DOM.modalBgmAccountConfirm.disabled = true;
				DOM.modalBgmAccount.classList.add("visible");
			}

			function closeBgmAccountModal() {
				DOM.modalBgmAccount.classList.remove("visible");
				// 清除敏感信息
				DOM.accountPassword.value = "";
				accountToken = null;
			}

			async function loginAndFetchAccountMedia() {
				const email = DOM.accountEmail.value.trim();
				const password = DOM.accountPassword.value;

				if (!email || !password) {
					DOM.accountLoginStatus.textContent = "请输入邮箱和密码";
					DOM.accountLoginStatus.style.color = "var(--error-color)";
					return;
				}

				DOM.accountLoginBtn.disabled = true;
				DOM.accountLoginBtn.textContent = "登录中...";
				DOM.accountLoginStatus.textContent = "";

				try {
					// 1. Firebase Auth 登录
					const authUrl = `https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${FIREBASE_API_KEY}`;
					const authRes = await fetch(authUrl, {
						method: "POST",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({ email, password, returnSecureToken: true }),
					});

					const authData = await authRes.json();

					if (!authData.idToken) {
						const errorMsg = authData.error?.message || "登录失败";
						const friendlyMsg =
							{
								EMAIL_NOT_FOUND: "邮箱不存在",
								INVALID_PASSWORD: "密码错误",
								INVALID_EMAIL: "邮箱格式无效",
								USER_DISABLED: "账号已被禁用",
								TOO_MANY_ATTEMPTS_TRY_LATER: "尝试次数过多，请稍后再试",
								INVALID_LOGIN_CREDENTIALS: "邮箱或密码错误",
							}[errorMsg] || errorMsg;

						DOM.accountLoginStatus.textContent = friendlyMsg;
						DOM.accountLoginStatus.style.color = "var(--error-color)";
						DOM.accountLoginBtn.disabled = false;
						DOM.accountLoginBtn.textContent = "登录并获取音乐库";
						return;
					}

					accountToken = authData.idToken;
					accountUserId = authData.localId;

					DOM.accountLoginStatus.textContent = "登录成功，正在获取音乐库...";
					DOM.accountLoginStatus.style.color = "var(--success-color)";

					// 2. 获取音乐列表
					const mediaUrl = `https://firestore.googleapis.com/v1/projects/ccfolia-160aa/databases/(default)/documents/users/${accountUserId}/media`;
					const mediaRes = await fetch(mediaUrl, {
						headers: { Authorization: `Bearer ${accountToken}` },
					});

					const mediaData = await mediaRes.json();

					if (!mediaData.documents || mediaData.documents.length === 0) {
						DOM.accountLoginStatus.textContent = "账号中没有音乐文件";
						DOM.accountLoginStatus.style.color = "var(--warning-color)";
						DOM.accountLoginBtn.disabled = false;
						DOM.accountLoginBtn.textContent = "登录并获取音乐库";
						return;
					}

					// 3. 处理音乐数据
					accountMediaItems = mediaData.documents.map((doc) => {
						const f = doc.fields;
						const url = f.url?.stringValue || "";
						return {
							id: doc.name.split("/").pop(),
							name: f.name?.stringValue || "未命名",
							url: url,
							selected: false,
							exists: state.bgmLibrary.some((item) => item.url === url),
						};
					});

					// 4. 显示音乐列表
					DOM.accountLoginForm.style.display = "none";
					DOM.accountMediaSection.style.display = "block";
					renderAccountMediaList();
					DOM.accountMediaStatus.textContent = `找到 ${accountMediaItems.length} 个音乐文件`;
					DOM.accountMediaStatus.style.color = "var(--success-color)";
				} catch (err) {
					console.error("Account login error:", err);
					DOM.accountLoginStatus.textContent = "网络错误，请检查网络连接";
					DOM.accountLoginStatus.style.color = "var(--error-color)";
				} finally {
					DOM.accountLoginBtn.disabled = false;
					DOM.accountLoginBtn.textContent = "登录并获取音乐库";
				}
			}

			function renderAccountMediaList() {
				if (accountMediaItems.length === 0) {
					DOM.accountMediaList.innerHTML =
						'<span style="color: var(--text-secondary); font-size: 0.85rem">无可用音乐</span>';
					return;
				}

				DOM.accountMediaList.innerHTML = accountMediaItems
					.map(
						(item, index) => `
					<div class="account-media-item" style="
						display: flex;
						align-items: center;
						gap: 8px;
						padding: 8px;
						border-bottom: 1px solid var(--border-color);
						${item.exists ? "opacity: 0.5;" : ""}
					">
						<input type="checkbox"
							id="account-media-${index}"
							${item.selected ? "checked" : ""}
							${item.exists ? "disabled" : ""}
							onchange="toggleAccountMediaItem(${index})"
						/>
						<div style="flex: 1; min-width: 0;">
							<div style="font-size: 0.85rem; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
								${escapeHtml(item.name)}
							</div>
							${item.exists ? '<div style="font-size: 0.7rem; color: var(--warning-color);">(已存在)</div>' : ""}
						</div>
					</div>
				`
					)
					.join("");

				updateAccountMediaConfirmBtn();
			}

			function toggleAccountMediaItem(index) {
				if (accountMediaItems[index] && !accountMediaItems[index].exists) {
					accountMediaItems[index].selected = !accountMediaItems[index].selected;
					updateAccountMediaConfirmBtn();
				}
			}

			function toggleAccountMediaSelectAll() {
				const availableItems = accountMediaItems.filter((item) => !item.exists);
				const allSelected = availableItems.every((item) => item.selected);

				availableItems.forEach((item) => {
					item.selected = !allSelected;
				});

				renderAccountMediaList();
			}

			function updateAccountMediaConfirmBtn() {
				const selectedCount = accountMediaItems.filter((item) => item.selected && !item.exists).length;
				DOM.modalBgmAccountConfirm.disabled = selectedCount === 0;
				DOM.modalBgmAccountConfirm.textContent = selectedCount > 0 ? `导入选中 (${selectedCount})` : "导入选中";
			}

			function confirmAccountMediaImport() {
				const toImport = accountMediaItems.filter((item) => item.selected && !item.exists);
				if (toImport.length === 0) return;

				// 添加到 BGM 库（使用与 addScenesToBgmLibrary 一致的格式）
				toImport.forEach((item) => {
					if (!state.bgmLibrary.some((bgm) => bgm.url === item.url)) {
						state.bgmLibrary.push({
							id: `account_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
							name: item.name,
							url: item.url,
							source: "account", // 标记为账号导入
						});
					}
				});

				state.meta.lastModified = Date.now();
				renderBgmLibraryList();
				closeBgmAccountModal();
				showSuccess(`已导入 ${toImport.length} 个 BGM`);
			}

			// Account BGM Import Modal Event Listeners
			DOM.modalBgmAccountClose.addEventListener("click", closeBgmAccountModal);
			DOM.modalBgmAccountCancel.addEventListener("click", closeBgmAccountModal);
			setupModalOverlayClose(DOM.modalBgmAccount, closeBgmAccountModal);
			DOM.accountLoginBtn.addEventListener("click", loginAndFetchAccountMedia);
			DOM.accountSelectAllBtn.addEventListener("click", toggleAccountMediaSelectAll);
			DOM.modalBgmAccountConfirm.addEventListener("click", confirmAccountMediaImport);

			// 支持回车键登录
			DOM.accountPassword.addEventListener("keypress", (e) => {
				if (e.key === "Enter") loginAndFetchAccountMedia();
			});

			// ============================================================
			// Custom BGM Modal Handlers
			// ============================================================

			function openBgmCustomModal() {
				DOM.bgmCustomName.value = "";
				DOM.bgmCustomUrl.value = "";
				DOM.modalBgmCustom.classList.add("visible");
			}

			function closeBgmCustomModal() {
				DOM.modalBgmCustom.classList.remove("visible");
			}

			function saveBgmCustom() {
				const name = DOM.bgmCustomName.value.trim();
				const url = DOM.bgmCustomUrl.value.trim();

				if (!url) {
					showError("请输入 BGM URL");
					return;
				}

				if (!addCustomBgmToLibrary(name || "自定义 BGM", url)) {
					showError("该 URL 已存在于音乐库中");
					return;
				}

				renderBgmLibraryList();
				closeBgmCustomModal();
				showSuccess("已添加自定义 BGM");
			}

			// Custom BGM Modal Event Listeners
			DOM.modalBgmCustomClose.addEventListener("click", closeBgmCustomModal);
			DOM.modalBgmCustomCancel.addEventListener("click", closeBgmCustomModal);
			setupModalOverlayClose(DOM.modalBgmCustom, closeBgmCustomModal);
			DOM.modalBgmCustomSave.addEventListener("click", saveBgmCustom);

			// BGM Library buttons
			DOM.btnBgmImport.addEventListener("click", openBgmImportModal);
			DOM.btnBgmAccount.addEventListener("click", openBgmAccountModal);
			DOM.btnBgmCustom.addEventListener("click", openBgmCustomModal);

			// ============================================================
			// Import Plugin Rules Modal
			// ============================================================

			let parsedPluginRules = null;

			function openImportRulesModal() {
				DOM.modalImportRules.classList.add("visible");
				DOM.importRulesJson.value = "";
				DOM.importRulesPreview.style.display = "none";
				DOM.importRulesList.innerHTML = "";
				DOM.importRulesStatus.textContent = "";
				DOM.importRulesStatus.style.color = "";
				DOM.modalImportRulesConfirm.disabled = true;
				parsedPluginRules = null;
			}

			function closeImportRulesModal() {
				DOM.modalImportRules.classList.remove("visible");
				parsedPluginRules = null;
			}

			function parsePluginRulesJson() {
				const jsonText = DOM.importRulesJson.value.trim();
				if (!jsonText) {
					DOM.importRulesPreview.style.display = "none";
					DOM.importRulesStatus.textContent = "";
					DOM.modalImportRulesConfirm.disabled = true;
					parsedPluginRules = null;
					return;
				}

				try {
					const data = JSON.parse(jsonText);

					// 检查是否有 rules 对象
					const rules = data.rules || data;
					if (!rules || typeof rules !== "object") {
						throw new Error("未找到有效的规则配置");
					}

					// 提取语音配置
					const voiceConfigs = [];
					Object.entries(rules).forEach(([name, rule]) => {
						if (rule && rule.voiceName) {
							voiceConfigs.push({
								name,
								voiceName: rule.voiceName,
								rate: parseFloat(rule.rate) || 1,
								pitch: parseFloat(rule.pitch) || 1,
								volume: parseFloat(rule.volume) || 1,
								isDefault: name === "默认",
							});
						}
					});

					if (voiceConfigs.length === 0) {
						throw new Error("未找到任何语音配置");
					}

					parsedPluginRules = rules;

					// 显示预览
					DOM.importRulesPreview.style.display = "block";

					// 获取当前角色列表用于匹配检查
					const existingChars = new Set(Object.keys(state.characters));

					DOM.importRulesList.innerHTML = voiceConfigs
						.map((config) => {
							const isMatched = config.isDefault || existingChars.has(config.name);
							const matchStatus = config.isDefault
								? '<span style="color: var(--primary-color);">默认配置</span>'
								: isMatched
								? '<span style="color: var(--success-color);">✓ 已匹配</span>'
								: '<span style="color: var(--text-secondary);">未匹配角色</span>';

							return `
							<div style="display: flex; align-items: center; justify-content: space-between; padding: 8px; border-bottom: 1px solid var(--border-color);">
								<div style="flex: 1; min-width: 0;">
									<div style="font-weight: 600; color: var(--text-primary);">${escapeHtml(config.name)}</div>
									<div style="font-size: 0.75rem; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
										${escapeHtml(config.voiceName)} · 语速 ${config.rate}x · 音调 ${config.pitch}x
									</div>
								</div>
								<div style="font-size: 0.75rem; margin-left: 8px; flex-shrink: 0;">
									${matchStatus}
								</div>
							</div>
						`;
						})
						.join("");

					const matchedCount = voiceConfigs.filter((c) => c.isDefault || existingChars.has(c.name)).length;
					DOM.importRulesStatus.textContent = `找到 ${voiceConfigs.length} 个语音配置，${matchedCount} 个可匹配`;
					DOM.importRulesStatus.style.color = "var(--success-color)";
					DOM.modalImportRulesConfirm.disabled = false;
				} catch (e) {
					DOM.importRulesPreview.style.display = "none";
					DOM.importRulesStatus.textContent = "解析失败: " + e.message;
					DOM.importRulesStatus.style.color = "var(--error-color)";
					DOM.modalImportRulesConfirm.disabled = true;
					parsedPluginRules = null;
				}
			}

			function confirmImportRules() {
				if (!parsedPluginRules) return;

				CharacterManager.importPluginRules(parsedPluginRules);
				state.meta.lastModified = Date.now();

				// 刷新角色列表显示
				renderCharacterGrid();

				closeImportRulesModal();

				// 统计导入结果
				const importedCount = Object.entries(parsedPluginRules).filter(([name, rule]) => {
					return rule.voiceName && (name === "默认" || state.characters[name]);
				}).length;

				alert(`成功导入 ${importedCount} 个语音配置！`);
			}

			// Import Rules Modal Event Listeners
			DOM.modalImportRulesClose.addEventListener("click", closeImportRulesModal);
			DOM.modalImportRulesCancel.addEventListener("click", closeImportRulesModal);
			setupModalOverlayClose(DOM.modalImportRules, closeImportRulesModal);
			DOM.modalImportRulesConfirm.addEventListener("click", confirmImportRules);

			// JSON 输入框变化时解析
			DOM.importRulesJson.addEventListener("input", parsePluginRulesJson);

			// 文件选择
			DOM.importRulesFile.addEventListener("change", (e) => {
				const file = e.target.files[0];
				if (!file) return;

				const reader = new FileReader();
				reader.onload = (event) => {
					DOM.importRulesJson.value = event.target.result;
					parsePluginRulesJson();
				};
				reader.onerror = () => {
					DOM.importRulesStatus.textContent = "文件读取失败";
					DOM.importRulesStatus.style.color = "var(--error-color)";
				};
				reader.readAsText(file);

				// 重置 file input 以便可以再次选择同一文件
				e.target.value = "";
			});

			// 导入规则按钮
			DOM.btnImportRules.addEventListener("click", openImportRulesModal);

			// 导出语音配置
			DOM.btnExportVoiceConfig.addEventListener("click", () => {
				const voiceConfigs = {};

				// 添加默认配置
				if (state.ttsSettings.defaultVoice.voiceName) {
					voiceConfigs["默认"] = {
						voiceName: state.ttsSettings.defaultVoice.voiceName,
						rate: String(state.ttsSettings.defaultVoice.rate || 1),
						pitch: String(state.ttsSettings.defaultVoice.pitch || 1),
						volume: String(state.ttsSettings.defaultVoice.volume || 1),
					};
				}

				// 添加角色配置
				Object.entries(state.characters).forEach(([name, char]) => {
					if (char.voice?.voiceName) {
						voiceConfigs[name] = {
							voiceName: char.voice.voiceName,
							rate: String(char.voice.rate || 1),
							pitch: String(char.voice.pitch || 1),
							volume: String(char.voice.volume || 1),
						};
					}
				});

				if (Object.keys(voiceConfigs).length === 0) {
					alert("当前没有任何语音配置可导出");
					return;
				}

				// 生成 JSON 并复制到剪贴板
				const jsonStr = JSON.stringify({ rules: voiceConfigs }, null, 2);
				navigator.clipboard
					.writeText(jsonStr)
					.then(() => {
						DOM.importRulesStatus.textContent = "✓ 已复制到剪贴板";
						DOM.importRulesStatus.style.color = "var(--success-color)";
					})
					.catch(() => {
						// 如果剪贴板不可用，显示在文本框中
						DOM.importRulesJson.value = jsonStr;
						DOM.importRulesStatus.textContent = "已生成配置，请手动复制";
						DOM.importRulesStatus.style.color = "var(--warning-color)";
					});
			});

			// 重置所有语音配置
			DOM.btnResetVoiceConfig.addEventListener("click", () => {
				const hasConfig =
					state.ttsSettings.defaultVoice.voiceName || Object.values(state.characters).some((c) => c.voice?.voiceName);

				if (!hasConfig) {
					alert("当前没有任何语音配置");
					return;
				}

				if (!confirm("确定要重置所有角色的语音配置吗？此操作不可撤销。")) {
					return;
				}

				// 重置默认语音
				state.ttsSettings.defaultVoice = {
					enabled: true,
					voiceName: "",
					rate: 1,
					pitch: 1,
					volume: 1,
				};

				// 重置所有角色语音
				Object.values(state.characters).forEach((char) => {
					char.voice = {
						enabled: false,
						voiceName: "",
						rate: 1,
						pitch: 1,
						volume: 1,
					};
				});

				state.meta.lastModified = Date.now();
				renderCharacterGrid();

				DOM.importRulesStatus.textContent = "✓ 已重置所有语音配置";
				DOM.importRulesStatus.style.color = "var(--success-color)";
			});

			// Initialize custom BGM selects
			initBgmSelects();

			/**
			 * Recalculate active characters based on stage markers up to given index
			 * @param {number} upToIndex - Calculate up to this message index
			 */
			function recalculateActiveCharacters(upToIndex) {
				activeCharacters.clear();

				for (let i = 0; i <= upToIndex && i < state.editedMessages.length; i++) {
					const msg = state.editedMessages[i];

					// Process enter markers
					if (msg.stageEnter) {
						msg.stageEnter.forEach((name) => activeCharacters.add(name));
					}

					// Process exit markers
					if (msg.stageExit) {
						msg.stageExit.forEach((name) => activeCharacters.delete(name));
					}
				}

				// Update portrait wrappers visibility - offstage = not in activeCharacters
				portraitWrappers.forEach((wrapper, name) => {
					const isOnStage = activeCharacters.has(name);
					wrapper.classList.toggle("offstage", !isOnStage);
					wrapper.classList.toggle("inactive", isOnStage); // 在场但非发言者默认半透明
					wrapper.classList.remove("speaking"); // 清除发言状态
				});

				renderCharacterStyleList();
			}

			// Stage modal event listeners
			DOM.modalStageClose.addEventListener("click", closeStageModal);
			DOM.modalStageCancel.addEventListener("click", closeStageModal);
			DOM.modalStageSave.addEventListener("click", saveStageConfig);

			setupModalOverlayClose(DOM.modalStage, closeStageModal);

			// Modal event listeners
			DOM.modalEditClose.addEventListener("click", closeEditModal);
			DOM.modalEditCancel.addEventListener("click", closeEditModal);
			DOM.modalEditSave.addEventListener("click", saveEditedMessage);

			// CC dice edit preview update
			DOM.editDiceCcTarget.addEventListener("input", updateCCDicePreview);
			DOM.editDiceCcRoll.addEventListener("input", updateCCDicePreview);

			// Normal dice range hint update
			DOM.editDiceFormula.addEventListener("input", updateEditDiceRangeHint);

			/**
			 * Update dice range hint in edit modal
			 */
			function updateEditDiceRangeHint() {
				const formula = DOM.editDiceFormula.value.trim();
				const range = calculateDiceRange(formula);
				if (range) {
					DOM.editDiceRangeHint.textContent = `有效范围: ${range.min} ~ ${range.max}`;
					DOM.editDiceRangeHint.style.color = "var(--text-secondary)";
				} else {
					DOM.editDiceRangeHint.textContent = "有效范围: --";
					DOM.editDiceRangeHint.style.color = "var(--text-secondary)";
				}
			}

			// Rename modal event listeners
			DOM.modalRenameClose.addEventListener("click", closeRenameModal);
			DOM.modalRenameCancel.addEventListener("click", closeRenameModal);
			DOM.modalRenameSave.addEventListener("click", confirmRename);
			setupModalOverlayClose(DOM.modalRename, closeRenameModal);

			// Support Enter key in rename input
			DOM.renameCharacterName.addEventListener("keypress", (e) => {
				if (e.key === "Enter") {
					e.preventDefault();
					confirmRename();
				}
			});

			// Avatar selector modal event listeners
			DOM.modalAvatarSelectorClose.addEventListener("click", closeAvatarSelector);
			DOM.modalAvatarSelectorCancel.addEventListener("click", closeAvatarSelector);
			setupModalOverlayClose(DOM.modalAvatarSelector, closeAvatarSelector);

			// Quick portrait edit modal event listeners
			DOM.modalQuickPortraitEditClose.addEventListener("click", closeQuickPortraitEdit);
			DOM.modalQuickPortraitEditCancel.addEventListener("click", closeQuickPortraitEdit);
			setupModalOverlayClose(DOM.modalQuickPortraitEdit, closeQuickPortraitEdit);

			// Portrait right-click context menu for replay mode
			DOM.portraitImg.addEventListener("contextmenu", (e) => {
				e.preventDefault();
				e.stopPropagation();
				// Only allow if there's a current message with a character
				const currentMsg = state.editedMessages[currentMessageIndex];
				if (currentMsg && currentMsg.name) {
					hideAllContextMenus();
					DOM.portraitContextMenu.style.left = e.clientX + "px";
					DOM.portraitContextMenu.style.top = e.clientY + "px";
					DOM.portraitContextMenu.classList.add("visible");
				}
			});

			DOM.modalInsertClose.addEventListener("click", closeInsertModal);
			DOM.modalInsertCancel.addEventListener("click", closeInsertModal);
			DOM.modalInsertSave.addEventListener("click", insertNewMessage);

			// Insert dice modal event listeners
			DOM.modalInsertDiceClose.addEventListener("click", closeInsertDiceModal);
			DOM.modalInsertDiceCancel.addEventListener("click", closeInsertDiceModal);
			DOM.modalInsertDiceSave.addEventListener("click", saveInsertedDice);

			// Insert dice type selector
			DOM.insertDiceType.addEventListener("change", () => {
				const type = DOM.insertDiceType.value;
				DOM.insertDiceCc.style.display = type === "cc" ? "block" : "none";
				DOM.insertDiceNormal.style.display = type === "normal" ? "block" : "none";
			});

			// Insert dice CC preview update
			DOM.insertDiceCcTarget.addEventListener("input", updateInsertDiceCcPreview);
			DOM.insertDiceCcRoll.addEventListener("input", updateInsertDiceCcPreview);

			// Insert dice normal range hint update
			DOM.insertDiceFormula.addEventListener("input", updateInsertDiceRangeHint);

			/**
			 * Update dice range hint in insert dice modal
			 */
			function updateInsertDiceRangeHint() {
				const formula = DOM.insertDiceFormula.value.trim();
				const range = calculateDiceRange(formula);
				if (range) {
					DOM.insertDiceRangeHint.textContent = `有效范围: ${range.min} ~ ${range.max}`;
					DOM.insertDiceRangeHint.style.color = "var(--text-secondary)";
				} else {
					DOM.insertDiceRangeHint.textContent = "有效范围: --";
					DOM.insertDiceRangeHint.style.color = "var(--text-secondary)";
				}
			}

			setupModalOverlayClose(DOM.modalInsertDice, closeInsertDiceModal);

			// Portrait selector event listeners
			const editPortraitTrigger = document.getElementById("edit-portrait-trigger");
			const insertPortraitTrigger = document.getElementById("insert-portrait-trigger");
			const insertDicePortraitTrigger = document.getElementById("insert-dice-portrait-trigger");

			if (editPortraitTrigger) {
				editPortraitTrigger.addEventListener("click", () => togglePortraitDropdown("edit"));
			}
			if (insertPortraitTrigger) {
				insertPortraitTrigger.addEventListener("click", () => togglePortraitDropdown("insert"));
			}
			if (insertDicePortraitTrigger) {
				insertDicePortraitTrigger.addEventListener("click", () => togglePortraitDropdown("insert-dice"));
			}

			// Name change listeners for portrait selector update
			DOM.editName.addEventListener(
				"input",
				debounce(() => {
					const name = DOM.editName.value.trim();
					const currentUrl = DOM.editIcon.value;
					updatePortraitSelector("edit", name, currentUrl);
				}, 300)
			);

			DOM.insertName.addEventListener(
				"input",
				debounce(() => {
					const name = DOM.insertName.value.trim();
					const currentUrl = DOM.insertIcon.value;
					updatePortraitSelector("insert", name, currentUrl);
				}, 300)
			);

			DOM.insertDiceName.addEventListener(
				"input",
				debounce(() => {
					const name = DOM.insertDiceName.value.trim();
					const currentUrl = DOM.insertDiceIcon.value;
					updatePortraitSelector("insert-dice", name, currentUrl);
				}, 300)
			);

			// Close modal on overlay click (with drag protection)
			setupModalOverlayClose(DOM.modalEdit, closeEditModal);

			setupModalOverlayClose(DOM.modalInsert, closeInsertModal);

			// Close modal on Escape key
			document.addEventListener("keydown", (e) => {
				if (e.key === "Escape") {
					closeEditModal();
					closeInsertModal();
					closeInsertDiceModal();
					closeStageModal();
					closeBackgroundModal();
				}
			});

			/**
			 * Switch between replay, list and character views
			 * @param {string} view - "replay", "list" or "character"
			 */
			function switchView(view) {
				currentView = view;

				// Handle editor panel visibility - with animation
				if (view === "character") {
					// In character view, drawer floats above content and animates to hidden
					DOM.editorPanel.classList.add("floating-mode");
					DOM.editorPanel.classList.add("collapsed");
					DOM.editorPanel.classList.add("hidden-in-character");
					DOM.editorPanel.classList.remove("open");
					DOM.editorToggle.classList.add("hidden");
					editorOverlay.classList.remove("visible");
				} else {
					// In other views, drawer is part of flex layout
					DOM.editorPanel.classList.remove("floating-mode");
					DOM.editorPanel.classList.remove("hidden-in-character");
					DOM.editorToggle.classList.remove("hidden");

					// Apply the current editor panel state
					updateEditorPanelState();
				}

				// Update view containers
				DOM.viewReplay.classList.toggle("active", view === "replay");
				DOM.viewList.classList.toggle("active", view === "list");
				DOM.viewCharacter.classList.toggle("active", view === "character");

				// Update view buttons
				DOM.btnViewReplay.classList.toggle("active", view === "replay");
				DOM.btnViewList.classList.toggle("active", view === "list");

				// Render list if switching to list view
				if (view === "list") {
					renderMessageListFull();
					// When switching to list, detail page is not visible
					isDetailPageVisible = false;
					updateCharacterDetailButton();
				}

				// Handle replay view
				if (view === "replay") {
					// When switching to replay, detail page is not visible
					isDetailPageVisible = false;
					updateCharacterDetailButton();
				}

				// Handle character view - always show list when clicking "角色" button
				if (view === "character") {
					renderCharacterGrid();
					// Show character list, hide detail page
					DOM.characterGrid.classList.remove("hidden");
					DOM.characterDetailPage.classList.add("hidden");
					isDetailPageVisible = false;
					// Character button should be active
					DOM.btnViewCharacter.classList.add("active");
					updateCharacterDetailButton();
				} else {
					// Not in character view, character button not active
					DOM.btnViewCharacter.classList.remove("active");
				}
			}

			// ============================================================
			// Typing Effect
			// ============================================================

			/** @type {string} */
			let fullText = "";

			/** @type {number} */
			let charIndex = 0;

			/**
			 * Start typing effect for text
			 * @param {string} text - Text to type
			 * @param {number} speed - Milliseconds per character
			 */
			function startTyping(text, speed = 30) {
				// Cancel any existing typing
				if (typingTimeout) {
					clearTimeout(typingTimeout);
					typingTimeout = null;
				}

				fullText = text;
				charIndex = 0;
				isTyping = true;
				DOM.dialogueText.textContent = "";
				DOM.dialogueText.classList.add("typing");
				DOM.dialogueBox.classList.add("typing");

				typeNextChar(speed);
			}

			/**
			 * Type the next character
			 * @param {number} speed - Milliseconds per character
			 */
			function typeNextChar(speed) {
				if (charIndex < fullText.length) {
					const currentText = fullText.substring(0, charIndex + 1);
					DOM.dialogueText.textContent = currentText;

					// Also update canvas dialogue if in canvas mode
					if (state.portraitConfig.scaleMode === "canvas") {
						const canvasTextEl = DOM.portraitArea.querySelector(".canvas-dialogue-text");
						if (canvasTextEl) canvasTextEl.textContent = currentText;
					}

					charIndex++;
					typingTimeout = setTimeout(() => typeNextChar(speed), speed);
				} else {
					finishTyping();
				}
			}

			/**
			 * Skip typing and show full text immediately
			 */
			function skipTyping() {
				if (typingTimeout) {
					clearTimeout(typingTimeout);
					typingTimeout = null;
				}
				DOM.dialogueText.textContent = fullText;

				// Also update canvas dialogue if in canvas mode
				if (state.portraitConfig.scaleMode === "canvas") {
					const canvasTextEl = DOM.portraitArea.querySelector(".canvas-dialogue-text");
					if (canvasTextEl) canvasTextEl.textContent = fullText;
				}

				finishTyping();
			}

			/**
			 * Finish typing effect
			 */
			function finishTyping() {
				isTyping = false;
				DOM.dialogueText.classList.remove("typing");
				DOM.dialogueBox.classList.remove("typing");
			}

			// ============================================================
			// Player Display Functions
			// ============================================================

			/**
			 * Get dice result CSS class
			 * @param {DiceInfo} diceInfo - Dice information
			 * @returns {string} CSS class name
			 */
			function getDiceClass(diceInfo) {
				if (!diceInfo) return "";
				if (diceInfo.isCritical) return "dice-critical";
				if (diceInfo.isFumble) return "dice-fumble";
				if (diceInfo.isSuccess) return "dice-success";
				if (diceInfo.isFailure) return "dice-failure";
				return "";
			}

			/**
			 * Format dice result text - just return the result as-is
			 * @param {DiceInfo} diceInfo - Dice information
			 * @returns {string} Formatted dice result
			 */
			function formatDiceResult(diceInfo) {
				if (!diceInfo || !diceInfo.result) return "";
				return diceInfo.result;
			}

			/**
			 * Get display text for message (including dice result)
			 * @param {Message} msg - Message object
			 * @returns {string} Display text with dice result (HTML escaped)
			 */
			function getMessageDisplayText(msg) {
				let displayText = msg.text || "";

				// Add dice result if present
				if (msg.diceInfo && msg.diceInfo.result) {
					const diceText = formatDiceResult(msg.diceInfo);
					if (diceText) {
						displayText = displayText ? `${displayText}\n${diceText}` : diceText;
					}
				}

				if (!displayText) return "(空消息)";

				// Escape HTML and convert newlines to <br>
				return escapeHtml(displayText).replace(/\n/g, "<br>");
			}

			// ============================================================
			// Portrait Management (Multi-mode)
			// ============================================================

			/** @type {Map<string, HTMLElement>} */
			const portraitWrappers = new Map();

			/** @type {Set<string>} */
			let activeCharacters = new Set();

			/** @type {Array<string[]>} - 每条消息对应的在场角色快照 */
			let stageSnapshots = [];

			/**
			 * Build stage snapshots for all messages
			 * Call this after loading data or editing stage markers
			 */
			function buildStageSnapshots() {
				stageSnapshots = [];
				const currentActive = new Set();

				for (let i = 0; i < state.editedMessages.length; i++) {
					const msg = state.editedMessages[i];

					// Process enter/exit for this message
					if (msg.stageEnter) {
						msg.stageEnter.forEach((name) => currentActive.add(name));
					}
					if (msg.stageExit) {
						msg.stageExit.forEach((name) => currentActive.delete(name));
					}

					// Store snapshot (as array for memory efficiency)
					stageSnapshots[i] = Array.from(currentActive);
				}
			}

			/**
			 * Apply stage snapshot at given message index
			 * @param {number} index - Message index
			 */
			function applyStageSnapshot(index) {
				if (index < 0 || index >= stageSnapshots.length) {
					activeCharacters.clear();
					return;
				}

				const snapshot = stageSnapshots[index] || [];
				activeCharacters = new Set(snapshot);

				// Update all portrait visibility
				portraitWrappers.forEach((wrapper, name) => {
					if (activeCharacters.has(name)) {
						wrapper.classList.remove("offstage");
					} else {
						wrapper.classList.add("offstage");
						wrapper.classList.remove("inactive", "speaking");
					}
				});
			}

			/** @type {string|null} */
			let currentSpeaker = null;

			/** @type {Object|null} - Drag state for portrait */
			let portraitDragState = null;

			/**
			 * Extract unique characters with their icon URLs from messages
			 * Also includes characters that have portraits in state.characters
			 * @param {Message[]} messages - Array of messages
			 * @returns {Map<string, string>} Map of character name to icon URL
			 */
			function extractCharacters(messages) {
				const characters = new Map();

				// First, extract from messages
				messages.forEach((msg) => {
					if (msg.name && !characters.has(msg.name)) {
						// Use iconUrl from message, or try to get default portrait from character config
						const iconUrl = msg.iconUrl || state.characters[msg.name]?.defaultPortrait || "";
						if (iconUrl) {
							characters.set(msg.name, iconUrl);
						}
					}
				});

				// Also add characters that have portraits but might not have iconUrl in messages
				Object.entries(state.characters || {}).forEach(([name, char]) => {
					if (!characters.has(name) && char.portraits && char.portraits.length > 0) {
						// Use default portrait or first portrait
						const iconUrl = char.defaultPortrait || char.portraits[0].url;
						if (iconUrl) {
							characters.set(name, iconUrl);
						}
					}
				});

				return characters;
			}

			// ============================================================
			// Character Manager
			// ============================================================

			/**
			 * Character Manager - 角色数据管理核心模块
			 */
			const CharacterManager = {
				/**
				 * 从消息中提取所有角色的详细信息
				 * @param {Message[]} messages - 消息数组
				 * @returns {Map<string, CharacterConfig>} 角色配置Map
				 */
				extractCharactersDetailed(messages) {
					const characters = new Map();

					messages.forEach((msg) => {
						if (!msg.name) return;

						if (!characters.has(msg.name)) {
							// 创建新角色配置
							characters.set(msg.name, {
								name: msg.name,
								type: "", // 默认未归类
								messageCount: 0,
								portraits: [],
								defaultPortrait: msg.iconUrl || "",
								voice: this.getDefaultVoiceConfig(),
								soundTriggers: [],
								card: null,
							});
						}

						const char = characters.get(msg.name);
						char.messageCount++;

						// 收集立绘变体
						if (msg.iconUrl) {
							const existingPortrait = char.portraits.find((p) => p.url === msg.iconUrl);
							if (existingPortrait) {
								existingPortrait.usageCount++;
							} else {
								const portraitIndex = char.portraits.length + 1;
								char.portraits.push({
									id: `portrait-${char.portraits.length}`,
									url: msg.iconUrl,
									name: `差分${portraitIndex}`,
									usageCount: 1,
								});
							}
						}
					});

					return characters;
				},

				/**
				 * 获取默认语音配置
				 * @returns {VoiceConfig}
				 */
				getDefaultVoiceConfig() {
					return {
						enabled: false,
						voiceName: "",
						rate: 1,
						pitch: 1,
						volume: 1,
						delimiterEnabled: false,
						delimiterStart: "「",
						delimiterEnd: "」",
					};
				},

				/**
				 * 初始化角色数据（从消息中提取并合并已有配置）
				 * @param {Message[]} messages - 消息数组
				 */
				initFromMessages(messages) {
					const extracted = this.extractCharactersDetailed(messages);
					const existingConfig = state.characters || {};

					// 合并已有配置
					extracted.forEach((char, name) => {
						if (existingConfig[name]) {
							// 保留用户配置，更新统计数据
							state.characters[name] = {
								...char,
								...existingConfig[name],
								messageCount: char.messageCount,
								portraits: this.mergePortraits(char.portraits, existingConfig[name].portraits || []),
							};
						} else {
							state.characters[name] = char;
						}
					});
				},

				/**
				 * 合并立绘列表（保留用户命名和手动添加的差分）
				 * @param {PortraitVariant[]} newPortraits - 新提取的立绘（来自消息）
				 * @param {PortraitVariant[]} existingPortraits - 已有的立绘配置（包括手动添加的）
				 * @returns {PortraitVariant[]}
				 */
				mergePortraits(newPortraits, existingPortraits) {
					// 首先处理消息中出现的差分，保留用户命名
					const merged = newPortraits.map((newP) => {
						const existing = existingPortraits.find((p) => p.url === newP.url);
						if (existing) {
							return {
								...newP,
								name: existing.name || newP.name,
								id: existing.id || newP.id,
							};
						}
						return newP;
					});

					// 然后添加手动添加的差分（usageCount 为 0 且不在消息中出现的）
					existingPortraits.forEach((existingP) => {
						const inMessages = newPortraits.some((p) => p.url === existingP.url);
						if (!inMessages) {
							// 这是手动添加的差分，保留它
							merged.push({
								...existingP,
								usageCount: 0, // 确保使用次数为 0
							});
						}
					});

					return merged;
				},

				/**
				 * 获取角色配置
				 * @param {string} name - 角色名称
				 * @returns {CharacterConfig|null}
				 */
				getCharacter(name) {
					return state.characters[name] || null;
				},

				/**
				 * 更新角色配置
				 * @param {string} name - 角色名称
				 * @param {Partial<CharacterConfig>} config - 要更新的配置
				 */
				updateCharacter(name, config) {
					if (!state.characters[name]) {
						console.warn(`Character "${name}" not found`);
						return;
					}
					state.characters[name] = {
						...state.characters[name],
						...config,
					};
				},

				/**
				 * 获取所有角色列表
				 * @returns {CharacterConfig[]}
				 */
				getAllCharacters() {
					return Object.values(state.characters);
				},

				/**
				 * 按类型筛选角色
				 * @param {string} type - 角色类型
				 * @returns {CharacterConfig[]}
				 */
				getCharactersByType(type) {
					return this.getAllCharacters().filter((c) => c.type === type);
				},

				/**
				 * 导入插件规则（CCFOLIA 插件 JSON 格式）
				 * @param {Object} rules - 插件规则对象
				 */
				importPluginRules(rules) {
					const defaultRule = rules["默认"] || {};

					Object.entries(rules).forEach(([name, rule]) => {
						if (name === "默认" || name.startsWith("__")) return;

						const char = state.characters[name];
						if (char) {
							// 更新语音配置
							if (rule.voiceName) {
								char.voice = {
									...char.voice,
									enabled: true,
									voiceName: rule.voiceName || "",
									rate: parseFloat(rule.rate) || 1,
									pitch: parseFloat(rule.pitch) || 1,
									volume: parseFloat(rule.volume) || 1,
								};
							}
						}
					});

					// 设置默认语音配置
					if (defaultRule.voiceName) {
						state.ttsSettings.defaultVoice = {
							...state.ttsSettings.defaultVoice,
							enabled: true,
							voiceName: defaultRule.voiceName || "",
							rate: parseFloat(defaultRule.rate) || 1,
							pitch: parseFloat(defaultRule.pitch) || 1,
							volume: parseFloat(defaultRule.volume) || 1,
						};
					}
				},

				/**
				 * 导出角色配置为 JSON
				 * @returns {Object}
				 */
				exportCharacters() {
					return {
						characters: state.characters,
						ttsSettings: state.ttsSettings,
						customCategories: state.customCategories,
					};
				},

				/**
				 * 重命名角色
				 * @param {string} oldName - 原角色名
				 * @param {string} newName - 新角色名
				 * @returns {Object} 重命名结果
				 */
				renameCharacter(oldName, newName) {
					const trimmedNewName = newName.trim();

					if (!trimmedNewName) {
						throw new Error("新名称不能为空");
					}

					if (oldName === trimmedNewName) {
						throw new Error("新名称与原名称相同");
					}

					const oldChar = state.characters[oldName];
					if (!oldChar) {
						throw new Error(`角色 "${oldName}" 不存在`);
					}

					// 更新所有消息中的角色名
					let updatedMessageCount = 0;
					state.editedMessages.forEach((msg) => {
						if (msg.name === oldName) {
							msg.name = trimmedNewName;
							updatedMessageCount++;
						}
					});

					// 检查目标角色是否已存在
					const existingChar = state.characters[trimmedNewName];
					if (existingChar) {
						// 合并角色数据
						const mergeResult = this.mergeCharacters(oldChar, existingChar, trimmedNewName);

						// 删除原角色
						delete state.characters[oldName];

						// 更新自定义类别中的角色名
						state.customCategories.forEach((category) => {
							const index = category.characterNames.indexOf(oldName);
							if (index > -1) {
								category.characterNames.splice(index, 1);
								if (!category.characterNames.includes(trimmedNewName)) {
									category.characterNames.push(trimmedNewName);
								}
							}
						});

						return {
							type: "merged",
							oldName,
							newName: trimmedNewName,
							updatedMessageCount,
							mergedPortraits: mergeResult.mergedPortraits,
							totalPortraits: mergeResult.totalPortraits,
						};
					} else {
						// 简单重命名
						state.characters[trimmedNewName] = {
							...oldChar,
							name: trimmedNewName,
						};
						delete state.characters[oldName];

						// 更新自定义类别中的角色名
						state.customCategories.forEach((category) => {
							const index = category.characterNames.indexOf(oldName);
							if (index > -1) {
								category.characterNames[index] = trimmedNewName;
							}
						});

						return {
							type: "renamed",
							oldName,
							newName: trimmedNewName,
							updatedMessageCount,
						};
					}
				},

				/**
				 * 合并两个角色的数据
				 * @param {CharacterConfig} sourceChar - 源角色（被合并的）
				 * @param {CharacterConfig} targetChar - 目标角色（合并到的）
				 * @param {string} finalName - 最终角色名
				 * @returns {Object} 合并结果
				 */
				mergeCharacters(sourceChar, targetChar, finalName) {
					// 合并消息计数
					targetChar.messageCount += sourceChar.messageCount;

					// 合并立绘
					const mergedPortraits = [...targetChar.portraits];
					let addedPortraits = 0;

					sourceChar.portraits.forEach((sourcePortrait) => {
						const existingPortrait = mergedPortraits.find((p) => p.url === sourcePortrait.url);
						if (existingPortrait) {
							// 立绘已存在，合并使用次数
							existingPortrait.usageCount += sourcePortrait.usageCount;
						} else {
							// 立绘不存在，添加到列表末尾
							const newPortrait = {
								...sourcePortrait,
								id: `portrait-${mergedPortraits.length}`,
								name: sourcePortrait.name || `差分${mergedPortraits.length + 1}`,
							};
							mergedPortraits.push(newPortrait);
							addedPortraits++;
						}
					});

					targetChar.portraits = mergedPortraits;

					// 如果源角色有默认立绘且目标角色没有，使用源角色的
					if (sourceChar.defaultPortrait && !targetChar.defaultPortrait) {
						targetChar.defaultPortrait = sourceChar.defaultPortrait;
					}

					// 合并语音配置（保留目标角色的配置，除非目标角色未启用语音）
					if (!targetChar.voice.enabled && sourceChar.voice.enabled) {
						targetChar.voice = sourceChar.voice;
					}

					// 合并音效触发器
					if (sourceChar.soundTriggers && sourceChar.soundTriggers.length > 0) {
						targetChar.soundTriggers = [...(targetChar.soundTriggers || []), ...sourceChar.soundTriggers];
					}

					// 合并角色卡（保留目标角色的，除非目标角色没有）
					if (!targetChar.card && sourceChar.card) {
						targetChar.card = sourceChar.card;
					}

					return {
						mergedPortraits: addedPortraits,
						totalPortraits: mergedPortraits.length,
					};
				},
			};

			/**
			 * Category Manager - 自定义类别管理模块
			 */
			const CategoryManager = {
				/**
				 * 生成唯一 ID
				 * @returns {string}
				 */
				generateId() {
					return "cat-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9);
				},

				/**
				 * 创建新类别
				 * @param {string} name - 类别名称
				 * @returns {CustomCategory}
				 */
				createCategory(name) {
					const category = {
						id: this.generateId(),
						name: name.trim(),
						color: this.getRandomColor(),
						characterNames: [],
					};
					state.customCategories.push(category);
					return category;
				},

				/**
				 * 获取随机颜色
				 * @returns {string}
				 */
				getRandomColor() {
					const colors = ["#e57373", "#81c784", "#64b5f6", "#ffb74d", "#ba68c8", "#4dd0e1", "#aed581", "#ff8a65"];
					return colors[Math.floor(Math.random() * colors.length)];
				},

				/**
				 * 删除类别
				 * @param {string} categoryId - 类别 ID
				 */
				deleteCategory(categoryId) {
					const index = state.customCategories.findIndex((c) => c.id === categoryId);
					if (index !== -1) {
						const category = state.customCategories[index];
						// 将该类别下的角色重置为默认类型
						category.characterNames.forEach((name) => {
							if (state.characters[name]) {
								state.characters[name].customCategory = null;
							}
						});
						state.customCategories.splice(index, 1);
					}
				},

				/**
				 * 获取类别
				 * @param {string} categoryId - 类别 ID
				 * @returns {CustomCategory|null}
				 */
				getCategory(categoryId) {
					return state.customCategories.find((c) => c.id === categoryId) || null;
				},

				/**
				 * 获取所有类别
				 * @returns {CustomCategory[]}
				 */
				getAllCategories() {
					return state.customCategories;
				},

				/**
				 * 将角色添加到类别
				 * @param {string} categoryId - 类别 ID
				 * @param {string} characterName - 角色名称
				 */
				addCharacterToCategory(categoryId, characterName) {
					const category = this.getCategory(categoryId);
					if (category && !category.characterNames.includes(characterName)) {
						// 先从其他类别移除
						this.removeCharacterFromAllCategories(characterName);
						category.characterNames.push(characterName);
						// 更新角色配置
						if (state.characters[characterName]) {
							state.characters[characterName].customCategory = categoryId;
						}
					}
				},

				/**
				 * 从类别移除角色
				 * @param {string} categoryId - 类别 ID
				 * @param {string} characterName - 角色名称
				 */
				removeCharacterFromCategory(categoryId, characterName) {
					const category = this.getCategory(categoryId);
					if (category) {
						const index = category.characterNames.indexOf(characterName);
						if (index !== -1) {
							category.characterNames.splice(index, 1);
						}
					}
					// 更新角色配置
					if (state.characters[characterName]) {
						state.characters[characterName].customCategory = null;
					}
				},

				/**
				 * 从所有类别移除角色
				 * @param {string} characterName - 角色名称
				 */
				removeCharacterFromAllCategories(characterName) {
					state.customCategories.forEach((category) => {
						const index = category.characterNames.indexOf(characterName);
						if (index !== -1) {
							category.characterNames.splice(index, 1);
						}
					});
				},

				/**
				 * 获取角色所属类别
				 * @param {string} characterName - 角色名称
				 * @returns {CustomCategory|null}
				 */
				getCharacterCategory(characterName) {
					return state.customCategories.find((c) => c.characterNames.includes(characterName)) || null;
				},

				/**
				 * 按类别筛选角色
				 * @param {string} categoryId - 类别 ID
				 * @returns {CharacterConfig[]}
				 */
				getCharactersByCategory(categoryId) {
					const category = this.getCategory(categoryId);
					if (!category) return [];
					return category.characterNames.map((name) => state.characters[name]).filter((c) => c != null);
				},

				/**
				 * 重命名类别
				 * @param {string} categoryId - 类别 ID
				 * @param {string} newName - 新名称
				 */
				renameCategory(categoryId, newName) {
					const category = this.getCategory(categoryId);
					if (category) {
						category.name = newName.trim();
					}
				},
			};

			/**
			 * Batch Selection State - 批量选择状态管理模块
			 */
			const BatchSelectionState = {
				/** @type {boolean} 是否处于批量选择模式 */
				enabled: false,

				/** @type {Set<string>} 已选中的角色名称集合 */
				selectedCharacters: new Set(),

				/**
				 * 进入批量选择模式
				 */
				enterBatchMode() {
					this.enabled = true;
					this.selectedCharacters.clear();
					// Add checkboxes to existing cards without re-rendering
					this.addCheckboxesToCards();
					this.updateUI();
				},

				/**
				 * 退出批量选择模式
				 */
				exitBatchMode() {
					this.enabled = false;
					this.selectedCharacters.clear();
					// Remove checkboxes from cards without re-rendering
					this.removeCheckboxesFromCards();
					this.updateUI();
				},

				/**
				 * Add checkboxes to all character cards
				 */
				addCheckboxesToCards() {
					const cards = DOM.characterGrid.querySelectorAll(".character-card");
					cards.forEach((card) => {
						card.classList.add("batch-mode");
						// Add checkbox if not exists
						if (!card.querySelector(".batch-checkbox")) {
							const name = card.dataset.name;
							const checkbox = document.createElement("div");
							checkbox.className = "batch-checkbox";
							checkbox.dataset.name = name;
							checkbox.innerHTML = '<span class="checkbox-icon"></span>';
							card.insertBefore(checkbox, card.firstChild);
						}
					});
				},

				/**
				 * Remove checkboxes from all character cards
				 */
				removeCheckboxesFromCards() {
					const cards = DOM.characterGrid.querySelectorAll(".character-card");
					cards.forEach((card) => {
						card.classList.remove("batch-mode", "selected");
						const checkbox = card.querySelector(".batch-checkbox");
						if (checkbox) {
							checkbox.remove();
						}
					});
				},

				/**
				 * 切换角色选中状态
				 * @param {string} name - 角色名称
				 */
				toggleCharacter(name) {
					if (this.selectedCharacters.has(name)) {
						this.selectedCharacters.delete(name);
					} else {
						this.selectedCharacters.add(name);
					}
					this.updateUI();
				},

				/**
				 * 全选当前可见角色
				 * @param {string[]} visibleCharacters - 可见角色名称列表
				 */
				selectAll(visibleCharacters) {
					visibleCharacters.forEach((name) => this.selectedCharacters.add(name));
					this.updateUI();
				},

				/**
				 * 取消全部选择
				 */
				deselectAll() {
					this.selectedCharacters.clear();
					this.updateUI();
				},

				/**
				 * 获取选中数量
				 * @returns {number}
				 */
				getSelectedCount() {
					return this.selectedCharacters.size;
				},

				/**
				 * 获取选中的角色名称数组
				 * @returns {string[]}
				 */
				getSelectedNames() {
					return Array.from(this.selectedCharacters);
				},

				/**
				 * 检查角色是否被选中
				 * @param {string} name - 角色名称
				 * @returns {boolean}
				 */
				isSelected(name) {
					return this.selectedCharacters.has(name);
				},

				/**
				 * 批量加入类别
				 * @param {string} categoryId - 类别 ID
				 */
				batchAddToCategory(categoryId) {
					this.selectedCharacters.forEach((name) => {
						CategoryManager.addCharacterToCategory(categoryId, name);
					});
				},

				/**
				 * 批量删除角色及其消息
				 * @returns {{ deletedCharacters: string[], deletedMessageCount: number }}
				 */
				batchDelete() {
					const deletedCharacters = this.getSelectedNames();
					let deletedMessageCount = 0;

					// 统计并删除消息
					deletedCharacters.forEach((name) => {
						const char = state.characters[name];
						if (char) {
							deletedMessageCount += char.messageCount;
						}
					});

					// 从消息列表中删除这些角色的消息
					const namesToDelete = new Set(deletedCharacters);
					state.editedMessages = state.editedMessages.filter((msg) => !namesToDelete.has(msg.name));

					// 删除角色配置
					deletedCharacters.forEach((name) => {
						// 从所有类别中移除
						CategoryManager.removeCharacterFromAllCategories(name);
						// 删除角色配置
						delete state.characters[name];
					});

					// 清空选择
					this.selectedCharacters.clear();

					return { deletedCharacters, deletedMessageCount };
				},

				/**
				 * 更新 UI 状态
				 */
				updateUI() {
					updateBatchSelectionUI();
				},
			};

			/**
			 * Message Batch Selection State - 消息批量选择状态管理模块
			 */
			const MessageBatchSelectionState = {
				/** @type {boolean} 是否处于批量选择模式 */
				enabled: false,

				/** @type {Set<string>} 已选中的消息ID集合 */
				selectedMessages: new Set(),

				/**
				 * 进入批量选择模式
				 */
				enterBatchMode() {
					this.enabled = true;
					this.selectedMessages.clear();
					this.addCheckboxesToMessages();
					this.updateUI();
				},

				/**
				 * 退出批量选择模式
				 */
				exitBatchMode() {
					this.enabled = false;
					this.selectedMessages.clear();
					this.removeCheckboxesFromMessages();
					this.updateUI();
				},

				/**
				 * Add checkboxes to all message items
				 */
				addCheckboxesToMessages() {
					const messageList = DOM.messageListFull;
					if (messageList) {
						messageList.classList.add("message-batch-mode");
						const items = messageList.querySelectorAll(".message-item");
						items.forEach((item) => {
							const messageId = item.dataset.id;
							if (messageId && !item.querySelector(".message-batch-checkbox")) {
								// Add checkbox
								const checkbox = document.createElement("input");
								checkbox.type = "checkbox";
								checkbox.className = "message-batch-checkbox";
								checkbox.dataset.messageId = messageId;
								checkbox.addEventListener("change", (e) => {
									this.toggleMessage(messageId);
								});
								item.insertBefore(checkbox, item.firstChild);
							}
						});
					}
				},

				/**
				 * Remove checkboxes from all message items
				 */
				removeCheckboxesFromMessages() {
					const messageList = DOM.messageListFull;
					if (messageList) {
						messageList.classList.remove("message-batch-mode");
						const items = messageList.querySelectorAll(".message-item");
						items.forEach((item) => {
							// Remove checkbox
							const checkbox = item.querySelector(".message-batch-checkbox");
							if (checkbox) {
								checkbox.remove();
							}
						});
					}
				},

				/**
				 * 切换消息选中状态
				 * @param {string} messageId - 消息ID
				 */
				toggleMessage(messageId) {
					if (this.selectedMessages.has(messageId)) {
						this.selectedMessages.delete(messageId);
					} else {
						this.selectedMessages.add(messageId);
					}
					this.updateUI();
				},

				/**
				 * 全选当前页面的消息
				 */
				selectAll() {
					const items = DOM.messageListFull.querySelectorAll(".message-item");
					items.forEach((item) => {
						const messageId = item.dataset.id;
						if (messageId) {
							this.selectedMessages.add(messageId);
							const checkbox = item.querySelector(".message-batch-checkbox");
							if (checkbox) checkbox.checked = true;
						}
					});
					this.updateUI();
				},

				/**
				 * 取消全选
				 */
				deselectAll() {
					this.selectedMessages.clear();
					const checkboxes = DOM.messageListFull.querySelectorAll(".message-batch-checkbox");
					checkboxes.forEach((checkbox) => (checkbox.checked = false));
					this.updateUI();
				},

				/**
				 * 获取选中的消息数量
				 * @returns {number}
				 */
				getSelectedCount() {
					return this.selectedMessages.size;
				},

				/**
				 * 获取选中的消息ID列表
				 * @returns {string[]}
				 */
				getSelectedIds() {
					return Array.from(this.selectedMessages);
				},

				/**
				 * 批量删除选中的消息
				 * @returns {number} 删除的消息数量
				 */
				batchDeleteMessages() {
					const selectedIds = this.getSelectedIds();
					let deletedCount = 0;

					// 从编辑消息列表中删除
					state.editedMessages = state.editedMessages.filter((msg) => {
						if (selectedIds.includes(msg.id)) {
							state.deletedIds.add(msg.id);
							deletedCount++;
							return false;
						}
						return true;
					});

					// 清空选择
					this.selectedMessages.clear();

					return deletedCount;
				},

				/**
				 * 更新 UI 状态
				 */
				updateUI() {
					updateMessageBatchSelectionUI();
				},
			};

			/**
			 * TTS Manager - TTS 语音管理模块
			 */
			const TTSManager = {
				/** @type {SpeechSynthesisVoice[]} 可用语音列表 */
				voices: [],

				/** @type {boolean} 是否已初始化 */
				initialized: false,

				/** @type {SpeechSynthesisUtterance|null} 当前正在播放的语音 */
				currentUtterance: null,

				/** @type {HTMLAudioElement|null} 当前播放的 Edge TTS 音频 */
				currentAudio: null,

				/** @type {Map<string, Blob>} Edge TTS 音频缓存 (key: text+voice hash) */
				audioCache: new Map(),

				/** @type {Map<string, Promise<Blob|null>>} 正在加载中的请求 (避免重复请求) */
				pendingRequests: new Map(),

				/** @type {number} 预加载的消息数量 */
				preloadCount: 5,

				/** @type {number} 最大并发请求数 */
				maxConcurrent: 2,

				/** @type {number} 当前并发请求数 */
				currentConcurrent: 0,

				/** @type {Array<{index: number, text: string, config: Object, priority: number}>} 预加载队列 */
				preloadQueue: [],

				/** @type {boolean} 是否使用 Edge TTS */
				useEdgeTTS: true,

				/** @type {string} Edge TTS API 地址 */
				edgeTTSApi: "https://api.tts.quest/v1/tts",

				/**
				 * Web Speech API 语音名称到 Edge TTS 语音名称的映射
				 * 格式: "Microsoft XXX Online (Natural) - Language" -> "lang-Region-XXXNeural"
				 */
				voiceNameMap: {
					// 中文（简体）
					"Microsoft Xiaoxiao Online (Natural) - Chinese (Mainland)": "zh-CN-XiaoxiaoNeural",
					"Microsoft Yunxi Online (Natural) - Chinese (Mainland)": "zh-CN-YunxiNeural",
					"Microsoft Yunxia Online (Natural) - Chinese (Mainland)": "zh-CN-YunxiaNeural",
					"Microsoft Yunjian Online (Natural) - Chinese (Mainland)": "zh-CN-YunjianNeural",
					"Microsoft Xiaoyi Online (Natural) - Chinese (Mainland)": "zh-CN-XiaoyiNeural",
					"Microsoft Yunyang Online (Natural) - Chinese (Mainland)": "zh-CN-YunyangNeural",
					"Microsoft Xiaochen Online (Natural) - Chinese (Mainland)": "zh-CN-XiaochenNeural",
					"Microsoft Xiaohan Online (Natural) - Chinese (Mainland)": "zh-CN-XiaohanNeural",
					"Microsoft Xiaomeng Online (Natural) - Chinese (Mainland)": "zh-CN-XiaomengNeural",
					"Microsoft Xiaomo Online (Natural) - Chinese (Mainland)": "zh-CN-XiaomoNeural",
					"Microsoft Xiaoqiu Online (Natural) - Chinese (Mainland)": "zh-CN-XiaoqiuNeural",
					"Microsoft Xiaorui Online (Natural) - Chinese (Mainland)": "zh-CN-XiaoruiNeural",
					"Microsoft Xiaoshuang Online (Natural) - Chinese (Mainland)": "zh-CN-XiaoshuangNeural",
					"Microsoft Xiaoxuan Online (Natural) - Chinese (Mainland)": "zh-CN-XiaoxuanNeural",
					"Microsoft Xiaoyan Online (Natural) - Chinese (Mainland)": "zh-CN-XiaoyanNeural",
					"Microsoft Xiaozhen Online (Natural) - Chinese (Mainland)": "zh-CN-XiaozhenNeural",
					// 中文（台湾）
					"Microsoft HsiaoChen Online (Natural) - Chinese (Taiwan)": "zh-TW-HsiaoChenNeural",
					"Microsoft HsiaoYu Online (Natural) - Chinese (Taiwan)": "zh-TW-HsiaoYuNeural",
					"Microsoft YunJhe Online (Natural) - Chinese (Taiwan)": "zh-TW-YunJheNeural",
					// 中文（香港）
					"Microsoft HiuGaai Online (Natural) - Chinese (Hong Kong)": "zh-HK-HiuGaaiNeural",
					"Microsoft HiuMaan Online (Natural) - Chinese (Hong Kong)": "zh-HK-HiuMaanNeural",
					"Microsoft WanLung Online (Natural) - Chinese (Hong Kong)": "zh-HK-WanLungNeural",
					// 日语
					"Microsoft Nanami Online (Natural) - Japanese (Japan)": "ja-JP-NanamiNeural",
					"Microsoft Keita Online (Natural) - Japanese (Japan)": "ja-JP-KeitaNeural",
					// 英语
					"Microsoft Jenny Online (Natural) - English (United States)": "en-US-JennyNeural",
					"Microsoft Guy Online (Natural) - English (United States)": "en-US-GuyNeural",
					"Microsoft Aria Online (Natural) - English (United States)": "en-US-AriaNeural",
					"Microsoft Davis Online (Natural) - English (United States)": "en-US-DavisNeural",
					// 韩语
					"Microsoft SunHi Online (Natural) - Korean (Korea)": "ko-KR-SunHiNeural",
					"Microsoft InJoon Online (Natural) - Korean (Korea)": "ko-KR-InJoonNeural",
				},

				/**
				 * 初始化并获取系统语音列表
				 * @returns {Promise<void>}
				 */
				async init() {
					if (this.initialized) return;

					// 检查浏览器是否支持 Web Speech API
					if (!("speechSynthesis" in window)) {
						console.warn("浏览器不支持 Web Speech API");
						return;
					}

					// 获取语音列表
					return new Promise((resolve) => {
						const loadVoices = () => {
							this.voices = speechSynthesis.getVoices();
							if (this.voices.length > 0) {
								this.initialized = true;
								console.log(`TTS 初始化完成，共 ${this.voices.length} 个语音可用`);
								// 自动扩展映射表
								this.buildVoiceNameMap();
								resolve();
							}
						};

						// 某些浏览器需要等待 voiceschanged 事件
						loadVoices();
						if (this.voices.length === 0) {
							speechSynthesis.addEventListener("voiceschanged", loadVoices, { once: true });
							// 设置超时，防止无限等待
							setTimeout(() => {
								if (!this.initialized) {
									this.voices = speechSynthesis.getVoices();
									this.initialized = true;
									this.buildVoiceNameMap();
									resolve();
								}
							}, 1000);
						}
					});
				},

				/**
				 * 自动构建语音名称映射表
				 * 从 Web Speech API 的语音名称推断 Edge TTS 名称
				 */
				buildVoiceNameMap() {
					this.voices.forEach((voice) => {
						if (this.voiceNameMap[voice.name]) return; // 已有映射

						// 尝试从名称中提取信息
						// 格式: "Microsoft XXX Online (Natural) - Language (Region)"
						const match = voice.name.match(/Microsoft\s+(\w+)\s+Online\s+\(Natural\)\s+-\s+(.+)/i);
						if (match) {
							const voiceShortName = match[1];
							const langRegion = match[2];

							// 尝试推断 Edge TTS 格式
							let edgeVoice = null;

							if (langRegion.includes("Chinese") && langRegion.includes("Mainland")) {
								edgeVoice = `zh-CN-${voiceShortName}Neural`;
							} else if (langRegion.includes("Chinese") && langRegion.includes("Taiwan")) {
								edgeVoice = `zh-TW-${voiceShortName}Neural`;
							} else if (langRegion.includes("Chinese") && langRegion.includes("Hong Kong")) {
								edgeVoice = `zh-HK-${voiceShortName}Neural`;
							} else if (langRegion.includes("Japanese")) {
								edgeVoice = `ja-JP-${voiceShortName}Neural`;
							} else if (langRegion.includes("English") && langRegion.includes("United States")) {
								edgeVoice = `en-US-${voiceShortName}Neural`;
							} else if (langRegion.includes("Korean")) {
								edgeVoice = `ko-KR-${voiceShortName}Neural`;
							}

							if (edgeVoice) {
								this.voiceNameMap[voice.name] = edgeVoice;
								console.log(`自动映射语音: ${voice.name} -> ${edgeVoice}`);
							}
						}
					});
				},

				/**
				 * 将 Web Speech API 语音名称转换为 Edge TTS 语音名称
				 * @param {string} webSpeechVoiceName - Web Speech API 语音名称
				 * @returns {string|null} Edge TTS 语音名称，如果无法映射则返回 null
				 */
				mapToEdgeVoice(webSpeechVoiceName) {
					if (!webSpeechVoiceName) return null;

					// 直接查找映射
					if (this.voiceNameMap[webSpeechVoiceName]) {
						return this.voiceNameMap[webSpeechVoiceName];
					}

					// 检查是否是本地语音（不带 Online）
					if (!webSpeechVoiceName.includes("Online")) {
						return null; // 本地语音无法映射到 Edge TTS
					}

					return null;
				},

				/**
				 * 检查语音是否支持 Edge TTS
				 * @param {string} voiceName - 语音名称
				 * @returns {boolean}
				 */
				isEdgeTTSSupported(voiceName) {
					return this.mapToEdgeVoice(voiceName) !== null;
				},

				/**
				 * 生成缓存键
				 * @param {string} text - 文本
				 * @param {Object} config - 语音配置
				 * @returns {string}
				 */
				getCacheKey(text, config) {
					return `${config.voiceName || "default"}_${config.rate || 1}_${config.pitch || 1}_${text}`;
				},

				/**
				 * 使用 Edge TTS API 获取音频
				 * @param {string} text - 要合成的文本
				 * @param {Object} config - 语音配置
				 * @returns {Promise<Blob|null>}
				 */
				async fetchEdgeTTSAudio(text, config) {
					const edgeVoice = this.mapToEdgeVoice(config.voiceName);
					if (!edgeVoice) return null;

					const cacheKey = this.getCacheKey(text, config);

					// 检查缓存
					if (this.audioCache.has(cacheKey)) {
						return this.audioCache.get(cacheKey);
					}

					// 检查是否已有相同请求在进行中
					if (this.pendingRequests.has(cacheKey)) {
						return this.pendingRequests.get(cacheKey);
					}

					// 创建请求 Promise
					const requestPromise = (async () => {
						try {
							// 构建请求参数
							const params = new URLSearchParams({
								text: text,
								voice: edgeVoice,
								rate: `${((config.rate || 1) - 1) * 100}%`,
								pitch: `${((config.pitch || 1) - 1) * 50}Hz`,
							});

							const response = await fetch(`${this.edgeTTSApi}?${params.toString()}`);

							if (!response.ok) {
								console.warn(`Edge TTS API 请求失败: ${response.status}`);
								return null;
							}

							const blob = await response.blob();

							// 缓存音频
							this.audioCache.set(cacheKey, blob);

							// 限制缓存大小（最多 30 条）
							if (this.audioCache.size > 30) {
								const firstKey = this.audioCache.keys().next().value;
								this.audioCache.delete(firstKey);
							}

							return blob;
						} catch (error) {
							console.warn("Edge TTS 请求错误:", error);
							return null;
						} finally {
							// 请求完成后从 pending 中移除
							this.pendingRequests.delete(cacheKey);
						}
					})();

					// 记录正在进行的请求
					this.pendingRequests.set(cacheKey, requestPromise);

					return requestPromise;
				},

				/**
				 * 处理预加载队列
				 */
				async processPreloadQueue() {
					while (this.preloadQueue.length > 0 && this.currentConcurrent < this.maxConcurrent) {
						// 按优先级排序（数字越小优先级越高）
						this.preloadQueue.sort((a, b) => a.priority - b.priority);

						const item = this.preloadQueue.shift();
						if (!item) break;

						const cacheKey = this.getCacheKey(item.text, item.config);

						// 跳过已缓存或正在加载的
						if (this.audioCache.has(cacheKey) || this.pendingRequests.has(cacheKey)) {
							continue;
						}

						this.currentConcurrent++;

						// 异步加载，不阻塞队列处理
						this.fetchEdgeTTSAudio(item.text, item.config).finally(() => {
							this.currentConcurrent--;
							// 继续处理队列
							this.processPreloadQueue();
						});
					}
				},

				/**
				 * 预加载后续消息的音频（带优先级）
				 * @param {number} currentIndex - 当前消息索引
				 */
				preloadAudio(currentIndex) {
					const messages = state.editedMessages;

					// 清空旧的预加载队列（保留正在进行的请求）
					this.preloadQueue = [];

					for (let i = 1; i <= this.preloadCount; i++) {
						const nextIndex = currentIndex + i;
						if (nextIndex >= messages.length) break;

						const msg = messages[nextIndex];
						if (!msg.text || !msg.name || msg.type === "narration" || msg.type === "system") continue;

						const config = this.getEffectiveVoiceConfig(msg.name);
						if (!this.isEdgeTTSSupported(config.voiceName)) continue;

						// 添加到队列，优先级 = 距离当前消息的距离
						this.preloadQueue.push({
							index: nextIndex,
							text: msg.text,
							config: config,
							priority: i, // i=1 优先级最高
						});
					}

					// 开始处理队列
					this.processPreloadQueue();
				},

				/**
				 * 初始预加载 - 加载项目时预加载前几条消息
				 * @param {number} startIndex - 起始索引，默认为 0
				 */
				initialPreload(startIndex = 0) {
					const messages = state.editedMessages;
					if (messages.length === 0) return;

					console.log(`[TTS] 开始初始预加载，从索引 ${startIndex} 开始`);

					// 清空队列
					this.preloadQueue = [];

					// 预加载从 startIndex 开始的消息
					for (let i = 0; i < this.preloadCount && startIndex + i < messages.length; i++) {
						const msg = messages[startIndex + i];
						if (!msg.text || !msg.name || msg.type === "narration" || msg.type === "system") continue;

						const config = this.getEffectiveVoiceConfig(msg.name);
						if (!this.isEdgeTTSSupported(config.voiceName)) continue;

						this.preloadQueue.push({
							index: startIndex + i,
							text: msg.text,
							config: config,
							priority: i, // 越靠前优先级越高
						});
					}

					// 开始处理队列
					this.processPreloadQueue();
				},

				/**
				 * 获取可用语音列表
				 * @returns {SpeechSynthesisVoice[]}
				 */
				getVoices() {
					return this.voices;
				},

				/**
				 * 按语言筛选语音
				 * @param {string} langPrefix - 语言前缀（如 'zh', 'ja', 'en'）
				 * @returns {SpeechSynthesisVoice[]}
				 */
				getVoicesByLang(langPrefix) {
					return this.voices.filter((v) => v.lang.toLowerCase().startsWith(langPrefix.toLowerCase()));
				},

				/**
				 * 根据名称查找语音
				 * @param {string} voiceName - 语音名称
				 * @returns {SpeechSynthesisVoice|null}
				 */
				findVoice(voiceName) {
					if (!voiceName) return null;
					return this.voices.find((v) => v.name === voiceName) || null;
				},

				/**
				 * 朗读文本
				 * @param {string} text - 要朗读的文本
				 * @param {VoiceConfig} config - 语音配置
				 * @returns {Promise<void>}
				 */
				async speak(text, config = {}) {
					if (!text || !text.trim()) return;

					// 停止当前朗读
					this.stop();

					// 尝试使用 Edge TTS
					if (this.useEdgeTTS && this.isEdgeTTSSupported(config.voiceName)) {
						const audioBlob = await this.fetchEdgeTTSAudio(text, config);
						if (audioBlob) {
							return this.playAudioBlob(audioBlob, config.volume);
						}
					}

					// 回退到 Web Speech API
					return this.speakWithWebSpeech(text, config);
				},

				/**
				 * 使用 Web Speech API 朗读
				 * @param {string} text - 文本
				 * @param {Object} config - 配置
				 * @returns {Promise<void>}
				 */
				speakWithWebSpeech(text, config = {}) {
					return new Promise((resolve) => {
						const utterance = new SpeechSynthesisUtterance(text);

						// 应用语音配置
						if (config.voiceName) {
							const voice = this.findVoice(config.voiceName);
							if (voice) {
								utterance.voice = voice;
							}
						}

						utterance.rate = config.rate ?? 1;
						utterance.pitch = config.pitch ?? 1;
						utterance.volume = config.volume ?? 1;

						// 事件处理
						utterance.onend = () => {
							this.currentUtterance = null;
							resolve();
						};

						utterance.onerror = (event) => {
							this.currentUtterance = null;
							console.warn("TTS 错误:", event.error);
							resolve();
						};

						this.currentUtterance = utterance;
						speechSynthesis.speak(utterance);
					});
				},

				/**
				 * 播放音频 Blob
				 * @param {Blob} blob - 音频数据
				 * @param {number} volume - 音量
				 * @returns {Promise<void>}
				 */
				playAudioBlob(blob, volume = 1) {
					return new Promise((resolve) => {
						const url = URL.createObjectURL(blob);
						const audio = new Audio(url);
						audio.volume = volume;

						audio.onended = () => {
							URL.revokeObjectURL(url);
							this.currentAudio = null;
							resolve();
						};

						audio.onerror = () => {
							URL.revokeObjectURL(url);
							this.currentAudio = null;
							resolve();
						};

						this.currentAudio = audio;
						audio.play().catch(() => {
							URL.revokeObjectURL(url);
							this.currentAudio = null;
							resolve();
						});
					});
				},

				/**
				 * 停止当前朗读
				 */
				stop() {
					// 停止 Web Speech API
					if (speechSynthesis.speaking) {
						speechSynthesis.cancel();
					}
					this.currentUtterance = null;

					// 停止 Edge TTS 音频
					if (this.currentAudio) {
						this.currentAudio.pause();
						this.currentAudio = null;
					}
				},

				/**
				 * 清除音频缓存
				 */
				clearCache() {
					this.audioCache.clear();
					console.log("TTS 音频缓存已清除");
				},

				/**
				 * 测试语音配置
				 * @param {VoiceConfig} config - 语音配置
				 * @param {string} [testText] - 测试文本
				 */
				testVoice(config, testText = "这是一段测试语音。") {
					this.speak(testText, config);
				},

				/**
				 * 检查是否正在朗读
				 * @returns {boolean}
				 */
				isSpeaking() {
					return speechSynthesis.speaking || (this.currentAudio && !this.currentAudio.paused);
				},

				/**
				 * 获取角色的有效语音配置（考虑默认配置）
				 * @param {string} characterName - 角色名称
				 * @returns {VoiceConfig}
				 */
				getEffectiveVoiceConfig(characterName) {
					const char = state.characters[characterName];
					// 如果角色有自定义语音配置（voiceName 不为空），使用角色配置
					if (char && char.voice && char.voice.voiceName) {
						return char.voice;
					}
					// 返回默认配置
					return state.ttsSettings.defaultVoice;
				},

				/**
				 * 为角色朗读消息
				 * @param {string} characterName - 角色名称
				 * @param {string} text - 消息文本
				 * @returns {Promise<void>}
				 */
				speakForCharacter(characterName, text) {
					const config = this.getEffectiveVoiceConfig(characterName);
					return this.speak(text, config);
				},
			};

			/**
			 * BGM Manager - 背景音乐管理模块
			 */
			const BGMManager = {
				/** @type {HTMLAudioElement|null} 当前 Audio 元素 */
				audioElement: null,

				/** @type {HTMLAudioElement|null} 用于淡入淡出切换的第二个 Audio 元素 */
				nextAudioElement: null,

				/** @type {string|null} 当前播放的 BGM URL */
				currentBgmUrl: null,

				/** @type {number|null} 淡入淡出动画的 interval ID */
				fadeInterval: null,

				/** @type {boolean} 是否已初始化 */
				initialized: false,

				/**
				 * 初始化 BGM 管理器
				 */
				init() {
					if (this.initialized) return;

					this.audioElement = new Audio();
					this.audioElement.loop = state.bgmSettings.loop;
					this.audioElement.volume = state.bgmSettings.muted ? 0 : state.bgmSettings.volume;

					this.nextAudioElement = new Audio();
					this.nextAudioElement.loop = state.bgmSettings.loop;
					this.nextAudioElement.volume = 0;

					this.initialized = true;
					console.log("BGM Manager 初始化完成");
				},

				/**
				 * 播放 BGM
				 * @param {string} url - BGM URL
				 * @param {boolean} [fadeIn=true] - 是否淡入
				 */
				play(url, fadeIn = true) {
					if (!this.initialized) this.init();
					if (!url || !url.trim()) return;

					// 如果是同一个 URL，不重复播放
					if (this.currentBgmUrl === url && !this.audioElement.paused) return;

					this.currentBgmUrl = url;
					this.audioElement.src = url;
					this.audioElement.loop = state.bgmSettings.loop;

					if (fadeIn && !state.bgmSettings.muted) {
						this.audioElement.volume = 0;
						this.audioElement.play().catch((e) => console.warn("BGM 播放失败:", e));
						this._fadeIn(this.audioElement, state.bgmSettings.volume, state.bgmSettings.fadeInDuration);
					} else {
						this.audioElement.volume = state.bgmSettings.muted ? 0 : state.bgmSettings.volume;
						this.audioElement.play().catch((e) => console.warn("BGM 播放失败:", e));
					}
				},

				/**
				 * 停止 BGM
				 * @param {boolean} [fadeOut=true] - 是否淡出
				 */
				stop(fadeOut = true) {
					if (!this.audioElement) return;

					if (fadeOut && !this.audioElement.paused) {
						this._fadeOut(this.audioElement, state.bgmSettings.fadeOutDuration, () => {
							this.audioElement.pause();
							this.audioElement.currentTime = 0;
							this.currentBgmUrl = null;
						});
					} else {
						this.audioElement.pause();
						this.audioElement.currentTime = 0;
						this.currentBgmUrl = null;
					}
				},

				/**
				 * 切换到新 BGM（淡出旧的，淡入新的）
				 * @param {string} url - 新 BGM URL（空字符串表示停止）
				 */
				switchTo(url) {
					if (!this.initialized) this.init();

					// 如果 URL 为空，停止当前 BGM
					if (!url || !url.trim()) {
						this.stop(true);
						return;
					}

					// 如果是同一个 URL，不切换
					if (this.currentBgmUrl === url) return;

					// 如果当前没有播放，直接播放新的
					if (!this.currentBgmUrl || this.audioElement.paused) {
						this.play(url, true);
						return;
					}

					// 交叉淡入淡出
					const oldAudio = this.audioElement;
					const newAudio = this.nextAudioElement;

					newAudio.src = url;
					newAudio.loop = state.bgmSettings.loop;
					newAudio.volume = 0;
					newAudio.play().catch((e) => console.warn("BGM 播放失败:", e));

					// 淡出旧的
					this._fadeOut(oldAudio, state.bgmSettings.fadeOutDuration, () => {
						oldAudio.pause();
						oldAudio.currentTime = 0;
					});

					// 淡入新的
					this._fadeIn(
						newAudio,
						state.bgmSettings.muted ? 0 : state.bgmSettings.volume,
						state.bgmSettings.fadeInDuration
					);

					// 交换引用
					this.audioElement = newAudio;
					this.nextAudioElement = oldAudio;
					this.currentBgmUrl = url;
				},

				/**
				 * 设置音量
				 * @param {number} volume - 音量 (0-1)
				 */
				setVolume(volume) {
					state.bgmSettings.volume = Math.max(0, Math.min(1, volume));
					if (this.audioElement && !state.bgmSettings.muted) {
						this.audioElement.volume = state.bgmSettings.volume;
					}
				},

				/**
				 * 静音/取消静音
				 */
				toggleMute() {
					state.bgmSettings.muted = !state.bgmSettings.muted;
					if (this.audioElement) {
						this.audioElement.volume = state.bgmSettings.muted ? 0 : state.bgmSettings.volume;
					}
				},

				/**
				 * 设置是否循环
				 * @param {boolean} loop - 是否循环
				 */
				setLoop(loop) {
					state.bgmSettings.loop = loop;
					if (this.audioElement) {
						this.audioElement.loop = loop;
					}
					if (this.nextAudioElement) {
						this.nextAudioElement.loop = loop;
					}
				},

				/**
				 * 获取指定消息位置应播放的 BGM
				 * @param {number} index - 消息索引
				 * @returns {string|null} BGM URL 或 null
				 */
				getBGMForIndex(index) {
					// 向前查找最近的 bgmUrl 切换点
					for (let i = index; i >= 0; i--) {
						const msg = state.editedMessages[i];
						if (msg.bgmUrl !== undefined) {
							// 空字符串表示停止 BGM
							return msg.bgmUrl || null;
						}
					}
					// 无切换点时返回默认 BGM
					return state.bgmSettings.defaultBgmUrl || null;
				},

				/**
				 * 根据当前消息索引更新 BGM
				 * @param {number} index - 消息索引
				 */
				updateBGM(index) {
					const bgmUrl = this.getBGMForIndex(index);
					if (bgmUrl) {
						this.switchTo(bgmUrl);
					} else if (this.currentBgmUrl) {
						this.stop(true);
					}
				},

				/**
				 * 淡入效果
				 * @param {HTMLAudioElement} audio - Audio 元素
				 * @param {number} targetVolume - 目标音量
				 * @param {number} duration - 持续时间（毫秒）
				 * @private
				 */
				_fadeIn(audio, targetVolume, duration) {
					const steps = 20;
					const stepTime = duration / steps;
					const volumeStep = targetVolume / steps;
					let currentStep = 0;

					const interval = setInterval(() => {
						currentStep++;
						audio.volume = Math.min(volumeStep * currentStep, targetVolume);
						if (currentStep >= steps) {
							clearInterval(interval);
							audio.volume = targetVolume;
						}
					}, stepTime);
				},

				/**
				 * 淡出效果
				 * @param {HTMLAudioElement} audio - Audio 元素
				 * @param {number} duration - 持续时间（毫秒）
				 * @param {Function} [callback] - 完成回调
				 * @private
				 */
				_fadeOut(audio, duration, callback) {
					const steps = 20;
					const stepTime = duration / steps;
					const startVolume = audio.volume;
					const volumeStep = startVolume / steps;
					let currentStep = 0;

					const interval = setInterval(() => {
						currentStep++;
						audio.volume = Math.max(startVolume - volumeStep * currentStep, 0);
						if (currentStep >= steps) {
							clearInterval(interval);
							audio.volume = 0;
							if (callback) callback();
						}
					}, stepTime);
				},
			};

			// ============================================================
			// CCFOLIA API Functions
			// ============================================================

			/**
			 * 从 CCFOLIA 房间获取场景列表
			 * @param {string} roomId - 房间 ID
			 * @returns {Promise<{scenes: Array, error: string|null}>}
			 */
			async function fetchCcfoliaScenes(roomId) {
				const baseUrl = "https://firestore.googleapis.com/v1/projects/ccfolia-160aa/databases/(default)/documents";
				const url = `${baseUrl}/rooms/${roomId}/scenes`;

				try {
					const response = await fetch(url);
					if (!response.ok) {
						if (response.status === 404) {
							return { scenes: [], error: "房间不存在或无法访问" };
						}
						return { scenes: [], error: `请求失败: ${response.status}` };
					}

					const data = await response.json();
					if (!data.documents || data.documents.length === 0) {
						return { scenes: [], error: null };
					}

					// 解析场景数据，提取有 mediaUrl 的场景
					const scenes = data.documents
						.map((doc) => {
							const fields = doc.fields || {};
							const sceneName = fields.name?.stringValue || "未命名场景";
							const mediaUrl = fields.mediaUrl?.stringValue || null;
							const mediaName = fields.mediaName?.stringValue || "";

							if (!mediaUrl) return null;

							return {
								sceneName,
								mediaName,
								mediaUrl,
							};
						})
						.filter(Boolean);

					return { scenes, error: null };
				} catch (error) {
					console.error("获取 CCFOLIA 场景失败:", error);
					return { scenes: [], error: "网络错误，请检查连接" };
				}
			}

			/**
			 * 将 CCFOLIA 场景添加到 BGM 音乐库
			 * @param {Array<{sceneName: string, mediaName: string, mediaUrl: string}>} scenes - 场景列表
			 */
			function addScenesToBgmLibrary(scenes) {
				scenes.forEach((scene) => {
					// 检查是否已存在相同 URL
					const exists = state.bgmLibrary.some((item) => item.url === scene.mediaUrl);
					if (!exists) {
						state.bgmLibrary.push({
							id: `ccfolia_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
							name: scene.mediaName || scene.sceneName,
							url: scene.mediaUrl,
							source: "ccfolia",
							sceneName: scene.sceneName,
						});
					}
				});
				state.meta.lastModified = Date.now();
			}

			/**
			 * 添加自定义 BGM 到音乐库
			 * @param {string} name - 显示名称
			 * @param {string} url - BGM URL
			 */
			function addCustomBgmToLibrary(name, url) {
				// 检查是否已存在相同 URL
				const exists = state.bgmLibrary.some((item) => item.url === url);
				if (exists) {
					return false;
				}

				state.bgmLibrary.push({
					id: `custom_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
					name: name || "自定义 BGM",
					url: url,
					source: "custom",
				});
				state.meta.lastModified = Date.now();
				return true;
			}

			/**
			 * 从音乐库删除 BGM
			 * @param {string} id - BGM ID
			 */
			function removeBgmFromLibrary(id) {
				const index = state.bgmLibrary.findIndex((item) => item.id === id);
				if (index !== -1) {
					state.bgmLibrary.splice(index, 1);
					state.meta.lastModified = Date.now();
				}
			}

			/**
			 * Get default position for a character based on index (in percentage)
			 * @param {number} index - Character index
			 * @param {number} total - Total number of characters
			 * @returns {PortraitPosition} Position in percentage (0-100)
			 */
			function getDefaultPosition(index, total) {
				// 默认立绘宽度约15%，高度约45%
				const portraitWidthPct = 15;
				const portraitHeightPct = 45;

				// 均匀分布在底部，留出对话框空间（底部约25%）
				const spacing = 100 / (total + 1);
				const xPct = spacing * (index + 1) - portraitWidthPct / 2;
				const yPct = 100 - portraitHeightPct - 28; // 28% 给对话框

				return {
					x: Math.max(0, Math.min(xPct, 100 - portraitWidthPct)),
					y: Math.max(0, yPct),
					width: portraitWidthPct,
					height: portraitHeightPct,
				};
			}

			/**
			 * Convert percentage position to pixel position
			 * @param {PortraitPosition} position - Position in percentage
			 * @returns {{x: number, y: number, width: number, height: number}} Position in pixels
			 */
			function percentToPixel(position) {
				const areaWidth = DOM.portraitArea.clientWidth || 800;
				const areaHeight = DOM.portraitArea.clientHeight || 600;

				if (state.portraitConfig.scaleMode === "canvas") {
					// Canvas mode: use canvas dimensions
					const canvasWidth = state.portraitConfig.canvasWidth || 1920;
					const canvasHeight = state.portraitConfig.canvasHeight || 1080;
					return {
						x: (position.x / 100) * canvasWidth,
						y: (position.y / 100) * canvasHeight,
						width: (position.width / 100) * canvasWidth,
						height: (position.height / 100) * canvasHeight,
					};
				} else {
					// Percent mode: use actual area dimensions
					return {
						x: (position.x / 100) * areaWidth,
						y: (position.y / 100) * areaHeight,
						width: (position.width / 100) * areaWidth,
						height: (position.height / 100) * areaHeight,
					};
				}
			}

			/**
			 * Convert pixel position to percentage position
			 * @param {{x: number, y: number, width: number, height: number}} pixel - Position in pixels
			 * @returns {PortraitPosition} Position in percentage
			 */
			function pixelToPercent(pixel) {
				const areaWidth = DOM.portraitArea.clientWidth || 800;
				const areaHeight = DOM.portraitArea.clientHeight || 600;

				if (state.portraitConfig.scaleMode === "canvas") {
					const canvasWidth = state.portraitConfig.canvasWidth || 1920;
					const canvasHeight = state.portraitConfig.canvasHeight || 1080;
					return {
						x: (pixel.x / canvasWidth) * 100,
						y: (pixel.y / canvasHeight) * 100,
						width: (pixel.width / canvasWidth) * 100,
						height: (pixel.height / canvasHeight) * 100,
					};
				} else {
					return {
						x: (pixel.x / areaWidth) * 100,
						y: (pixel.y / areaHeight) * 100,
						width: (pixel.width / areaWidth) * 100,
						height: (pixel.height / areaHeight) * 100,
					};
				}
			}

			/**
			 * Apply position to a portrait wrapper element
			 * @param {HTMLElement} wrapper - The wrapper element
			 * @param {PortraitPosition} position - Position in percentage
			 */
			function applyPortraitPosition(wrapper, position) {
				if (state.portraitConfig.scaleMode === "canvas") {
					// Canvas mode: use percentage of canvas
					const pixel = percentToPixel(position);
					wrapper.style.left = `${pixel.x}px`;
					wrapper.style.top = `${pixel.y}px`;
					wrapper.style.width = `${pixel.width}px`;
					wrapper.style.height = `${pixel.height}px`;
				} else {
					// Percent mode: use CSS percentage
					wrapper.style.left = `${position.x}%`;
					wrapper.style.top = `${position.y}%`;
					wrapper.style.width = `${position.width}%`;
					wrapper.style.height = `${position.height}%`;
				}
			}

			/**
			 * Update all portrait positions (called on window resize)
			 */
			function updateAllPortraitPositions() {
				portraitWrappers.forEach((wrapper, name) => {
					const position = state.portraitConfig.positions[name];
					if (position) {
						applyPortraitPosition(wrapper, position);
					}
				});

				// Update canvas scale if in canvas mode
				if (state.portraitConfig.scaleMode === "canvas") {
					updateCanvasScale();
				}
			}

			/** @type {number} Canvas zoom level (1.0 = fit to screen) */
			let canvasZoom = 1.0;

			/** @type {{x: number, y: number}} Canvas position offset */
			let canvasOffset = { x: 0, y: 0 };

			/** @type {Object|null} Canvas drag state */
			let canvasDragState = null;

			/** @type {Object|null} Dialogue drag state */
			let dialogueDragState = null;

			/**
			 * Update canvas scale to fit the viewport
			 * @param {number} [zoomDelta] - Optional zoom delta from mouse wheel
			 */
			function updateCanvasScale(zoomDelta = 0) {
				const areaWidth = DOM.portraitArea.clientWidth;
				const areaHeight = DOM.portraitArea.clientHeight;

				// If area has no size yet, retry after a short delay
				if (!areaWidth || !areaHeight) {
					requestAnimationFrame(() => updateCanvasScale(zoomDelta));
					return;
				}

				const canvasWidth = state.portraitConfig.canvasWidth || 1920;
				const canvasHeight = state.portraitConfig.canvasHeight || 1080;

				// Calculate base scale to fit while maintaining aspect ratio
				const scaleX = areaWidth / canvasWidth;
				const scaleY = areaHeight / canvasHeight;
				const baseScale = Math.min(scaleX, scaleY) * 0.95; // 95% to leave margin

				// Get or create canvas inner container
				let canvasInner = DOM.portraitArea.querySelector(".portrait-canvas-inner");
				const isNewCanvas = !canvasInner;

				if (isNewCanvas) {
					// Reset view BEFORE calculating finalScale for new canvas
					canvasZoom = 1.0;
					canvasOffset = { x: 0, y: 0 };

					canvasInner = document.createElement("div");
					canvasInner.className = "portrait-canvas-inner";

					// Sync current background to canvas inner
					if (currentBackgroundUrl) {
						canvasInner.style.backgroundImage = `url(${currentBackgroundUrl})`;
						canvasInner.style.backgroundSize = "cover";
						canvasInner.style.backgroundPosition = "center";
					}

					// Create dialogue box inside canvas
					const dialogueBox = document.createElement("div");
					dialogueBox.className = "canvas-dialogue-box";
					dialogueBox.innerHTML = `
						<div class="drag-hint">拖拽移动 | 角落调整大小</div>
						<div class="dialogue-resize-handle top-left" data-handle="top-left"></div>
						<div class="dialogue-resize-handle top-right" data-handle="top-right"></div>
						<div class="dialogue-resize-handle bottom-left" data-handle="bottom-left"></div>
						<div class="dialogue-resize-handle bottom-right" data-handle="bottom-right"></div>
						<div class="dialogue-resize-handle middle-left" data-handle="middle-left"></div>
						<div class="dialogue-resize-handle middle-right" data-handle="middle-right"></div>
						<div class="dialogue-resize-handle middle-top" data-handle="middle-top"></div>
						<div class="dialogue-resize-handle middle-bottom" data-handle="middle-bottom"></div>
						<div class="canvas-dialogue-name"></div>
						<div class="canvas-dialogue-text"></div>
					`;

					// Add dialogue drag events
					dialogueBox.addEventListener("mousedown", handleDialogueDragStart);
					dialogueBox.addEventListener("touchstart", handleDialogueDragStart, { passive: false });

					canvasInner.appendChild(dialogueBox);

					// Move all portrait wrappers into canvas inner
					const wrappers = DOM.portraitArea.querySelectorAll(".portrait-wrapper");
					wrappers.forEach((w) => canvasInner.appendChild(w));
					DOM.portraitArea.appendChild(canvasInner);
				}

				// Apply zoom delta (smoother zoom)
				if (zoomDelta !== 0) {
					const zoomFactor = zoomDelta > 0 ? 1.1 : 0.9;
					canvasZoom = Math.max(0.3, Math.min(3.0, canvasZoom * zoomFactor));
				}

				const finalScale = baseScale * canvasZoom;

				// Apply dialogue styles and position
				applyCanvasDialogueStyles(canvasInner);

				// Calculate center position
				const scaledWidth = canvasWidth * finalScale;
				const scaledHeight = canvasHeight * finalScale;
				const centerX = (areaWidth - scaledWidth) / 2 + canvasOffset.x;
				const centerY = (areaHeight - scaledHeight) / 2 + canvasOffset.y;

				// Apply canvas size, scale and position using transform for smoother rendering
				canvasInner.style.width = `${canvasWidth}px`;
				canvasInner.style.height = `${canvasHeight}px`;
				canvasInner.style.transform = `translate(${centerX}px, ${centerY}px) scale(${finalScale})`;
				canvasInner.style.transformOrigin = "top left";

				// Store current scale for coordinate conversion
				state.portraitConfig.currentScale = finalScale;
			}

			/**
			 * Lightweight function to update only canvas position (for smooth animations)
			 * Does not recreate canvas or apply dialogue styles
			 * Keeps canvas size fixed, only updates position
			 */
			function updateCanvasPosition() {
				const canvasInner = DOM.portraitArea.querySelector(".portrait-canvas-inner");
				if (!canvasInner) return;

				const areaWidth = DOM.portraitArea.clientWidth;
				const areaHeight = DOM.portraitArea.clientHeight;
				if (!areaWidth || !areaHeight) return;

				const canvasWidth = state.portraitConfig.canvasWidth || 1920;
				const canvasHeight = state.portraitConfig.canvasHeight || 1080;

				// Use stored scale (don't recalculate to keep size fixed)
				const finalScale = state.portraitConfig.currentScale || 1;

				// Calculate center position with current scale
				const scaledWidth = canvasWidth * finalScale;
				const scaledHeight = canvasHeight * finalScale;
				const centerX = (areaWidth - scaledWidth) / 2 + canvasOffset.x;
				const centerY = (areaHeight - scaledHeight) / 2 + canvasOffset.y;

				// Only update transform position (keep scale fixed)
				canvasInner.style.transform = `translate(${centerX}px, ${centerY}px) scale(${finalScale})`;
			}

			/**
			 * Get character-specific style with fallback to global defaults
			 * @param {string} name - Character name
			 * @returns {{nameColor: string, textColor: string, fontFamily: string}}
			 */
			function getCharacterStyle(name) {
				const style = state.portraitConfig.dialogueStyle || {};
				const charStyle = style.characterStyles?.[name] || {};
				return {
					nameColor: charStyle.nameColor || style.nameColor || "#ffffff",
					textColor: charStyle.textColor || style.textColor || "#ffffff",
					fontFamily: charStyle.fontFamily || style.fontFamily || "",
				};
			}

			/**
			 * Render character style list in the editor panel
			 */
			function renderCharacterStyleList() {
				if (!DOM.characterStyleList) return;

				const characters = extractCharacters(state.editedMessages);
				const charArray = Array.from(characters.keys());

				if (charArray.length === 0) {
					DOM.characterStyleList.innerHTML =
						'<div style="padding: 12px; color: var(--text-secondary); font-size: 0.75rem; text-align: center">暂无角色</div>';
					return;
				}

				const globalStyle = state.portraitConfig.dialogueStyle;

				DOM.characterStyleList.innerHTML = charArray
					.map((name) => {
						const charStyle = state.portraitConfig.dialogueStyle.characterStyles?.[name] || {};
						const hasCustomStyle = charStyle.nameColor || charStyle.textColor || charStyle.fontFamily;
						const nameColor = charStyle.nameColor || globalStyle.nameColor || "#ffffff";
						const textColor = charStyle.textColor || globalStyle.textColor || "#ffffff";
						return `
						<div class="character-style-item" data-name="${name}" style="
							display: flex; align-items: center; gap: 8px; padding: 8px 10px;
							border-bottom: 1px solid var(--border-color); cursor: pointer;
							transition: background 0.15s;
						" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
							<div style="display: flex; gap: 3px">
								<span style="width: 14px; height: 14px; border-radius: 3px; background: ${nameColor}; border: 1px solid rgba(255,255,255,0.2)"></span>
								<span style="width: 14px; height: 14px; border-radius: 3px; background: ${textColor}; border: 1px solid rgba(255,255,255,0.2)"></span>
							</div>
							<span style="flex: 1; font-size: 0.8rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap">${name}</span>
							<span style="font-size: 0.65rem; color: ${
								hasCustomStyle ? "var(--primary-color)" : "var(--text-secondary)"
							}; white-space: nowrap">
								${hasCustomStyle ? "✓ 自定义" : "全局"}
							</span>
						</div>
					`;
					})
					.join("");

				// Add click handlers
				DOM.characterStyleList.querySelectorAll(".character-style-item").forEach((item) => {
					item.addEventListener("click", () => {
						const name = item.dataset.name;
						showCharacterStyleEditor(name);
					});
				});
			}

			/**
			 * Show character style editor modal
			 * @param {string} name - Character name
			 */
			function showCharacterStyleEditor(name) {
				const charStyle = state.portraitConfig.dialogueStyle.characterStyles?.[name] || {};
				const globalStyle = state.portraitConfig.dialogueStyle;

				// Remove existing
				const existingOverlay = document.getElementById("char-style-overlay");
				if (existingOverlay) existingOverlay.remove();

				// Create overlay
				const overlay = document.createElement("div");
				overlay.id = "char-style-overlay";
				overlay.style.cssText = `
					position: fixed; inset: 0; background: rgba(0,0,0,0.6);
					display: flex; align-items: center; justify-content: center;
					z-index: 10000; backdrop-filter: blur(2px);
				`;

				const nameColor = charStyle.nameColor || globalStyle.nameColor || "#ffffff";
				const textColor = charStyle.textColor || globalStyle.textColor || "#ffffff";

				overlay.innerHTML = `
					<div id="char-style-editor" style="
						background: var(--bg-secondary); border: 1px solid var(--border-color);
						border-radius: 12px; padding: 20px; min-width: 320px; max-width: 90vw;
						box-shadow: 0 16px 48px rgba(0,0,0,0.4);
					">
						<div style="font-weight: 600; margin-bottom: 16px; font-size: 1rem; display: flex; align-items: center; gap: 8px">
							<span style="font-size: 1.2rem">🎨</span>
							<span>${name}</span>
						</div>

						<div style="display: flex; gap: 16px; margin-bottom: 16px">
							<div style="flex: 1">
								<div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 6px">名称颜色</div>
								<div style="display: flex; align-items: center; gap: 8px">
									<input type="color" id="char-name-color" value="${nameColor}"
										style="width: 36px; height: 36px; padding: 0; border: 2px solid var(--border-color); border-radius: 6px; cursor: pointer; background: none" />
									<input type="text" id="char-name-color-text" value="${nameColor}"
										class="form-input" style="flex: 1; font-size: 0.8rem; padding: 8px; font-family: monospace" />
								</div>
							</div>
							<div style="flex: 1">
								<div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 6px">内容颜色</div>
								<div style="display: flex; align-items: center; gap: 8px">
									<input type="color" id="char-text-color" value="${textColor}"
										style="width: 36px; height: 36px; padding: 0; border: 2px solid var(--border-color); border-radius: 6px; cursor: pointer; background: none" />
									<input type="text" id="char-text-color-text" value="${textColor}"
										class="form-input" style="flex: 1; font-size: 0.8rem; padding: 8px; font-family: monospace" />
								</div>
							</div>
						</div>

						<div style="margin-bottom: 20px">
							<div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 6px">字体</div>
							<select class="form-input" id="char-font-family" style="width: 100%; padding: 10px; font-size: 0.85rem">
								<option value="" ${!charStyle.fontFamily ? "selected" : ""}>使用全局设置</option>
								<option value="serif" ${charStyle.fontFamily === "serif" ? "selected" : ""}>衬线体</option>
								<option value="sans-serif" ${charStyle.fontFamily === "sans-serif" ? "selected" : ""}>无衬线</option>
								<option value="monospace" ${charStyle.fontFamily === "monospace" ? "selected" : ""}>等宽</option>
								<option value="cursive" ${charStyle.fontFamily === "cursive" ? "selected" : ""}>手写</option>
							</select>
						</div>

						<div style="display: flex; gap: 10px">
							<button class="btn btn-secondary" id="char-style-reset" style="flex: 1; padding: 10px">重置</button>
							<button class="btn btn-secondary" id="char-style-cancel" style="flex: 1; padding: 10px">取消</button>
							<button class="btn btn-primary" id="char-style-save" style="flex: 1.5; padding: 10px">保存</button>
						</div>
					</div>
				`;

				document.body.appendChild(overlay);

				const editor = overlay.querySelector("#char-style-editor");

				// Sync color picker and text input
				const syncColorInputs = (colorInput, textInput) => {
					colorInput.addEventListener("input", () => {
						textInput.value = colorInput.value;
					});
					textInput.addEventListener("input", () => {
						if (/^#[0-9A-Fa-f]{6}$/.test(textInput.value)) {
							colorInput.value = textInput.value;
						}
					});
				};

				syncColorInputs(editor.querySelector("#char-name-color"), editor.querySelector("#char-name-color-text"));
				syncColorInputs(editor.querySelector("#char-text-color"), editor.querySelector("#char-text-color-text"));

				// Close on overlay click
				overlay.addEventListener("click", (e) => {
					if (e.target === overlay) overlay.remove();
				});

				editor.querySelector("#char-style-cancel").addEventListener("click", () => overlay.remove());

				editor.querySelector("#char-style-reset").addEventListener("click", () => {
					if (state.portraitConfig.dialogueStyle.characterStyles) {
						delete state.portraitConfig.dialogueStyle.characterStyles[name];
					}
					renderCharacterStyleList();
					updateDialogueTextStyle();
					overlay.remove();
				});

				editor.querySelector("#char-style-save").addEventListener("click", () => {
					const newNameColor = editor.querySelector("#char-name-color").value;
					const newTextColor = editor.querySelector("#char-text-color").value;
					const fontFamily = editor.querySelector("#char-font-family").value;

					if (!state.portraitConfig.dialogueStyle.characterStyles) {
						state.portraitConfig.dialogueStyle.characterStyles = {};
					}

					const newStyle = {};
					if (newNameColor !== (globalStyle.nameColor || "#ffffff")) newStyle.nameColor = newNameColor;
					if (newTextColor !== (globalStyle.textColor || "#ffffff")) newStyle.textColor = newTextColor;
					if (fontFamily) newStyle.fontFamily = fontFamily;

					if (Object.keys(newStyle).length > 0) {
						state.portraitConfig.dialogueStyle.characterStyles[name] = newStyle;
					} else {
						delete state.portraitConfig.dialogueStyle.characterStyles[name];
					}

					renderCharacterStyleList();
					updateDialogueTextStyle();
					overlay.remove();
				});

				// ESC to close
				const handleEsc = (e) => {
					if (e.key === "Escape") {
						overlay.remove();
						document.removeEventListener("keydown", handleEsc);
					}
				};
				document.addEventListener("keydown", handleEsc);
			}

			/**
			 * Update dialogue text style based on current speaker
			 */
			function updateDialogueTextStyle() {
				const canvasInner = DOM.portraitArea.querySelector(".portrait-canvas-inner");
				if (!canvasInner) return;

				const nameEl = canvasInner.querySelector(".canvas-dialogue-name");
				const textEl = canvasInner.querySelector(".canvas-dialogue-text");
				if (!nameEl || !textEl) return;

				const currentName = nameEl.textContent;
				const charStyle = getCharacterStyle(currentName);

				nameEl.style.color = charStyle.nameColor;
				textEl.style.color = charStyle.textColor;
				if (charStyle.fontFamily) {
					nameEl.style.fontFamily = charStyle.fontFamily;
					textEl.style.fontFamily = charStyle.fontFamily;
				} else {
					nameEl.style.fontFamily = "";
					textEl.style.fontFamily = "";
				}
			}

			/**
			 * Apply dialogue styles to canvas dialogue elements
			 * @param {HTMLElement} canvasInner - Canvas inner container
			 */
			function applyCanvasDialogueStyles(canvasInner) {
				const style = state.portraitConfig.dialogueStyle || {};
				const fontSize = style.fontSize ?? 24;
				const nameSize = style.nameSize ?? 20;
				const bgOpacity = (style.bgOpacity ?? 70) / 100;
				const bgImage = style.bgImage || "";
				const height = style.height ?? 120;
				// 兼容旧数据：如果有旧的 padding 字段，用它作为默认值
				const oldPadding = style.padding ?? 20;
				const paddingX = style.paddingX ?? oldPadding;
				const paddingY = style.paddingY ?? (oldPadding > 16 ? oldPadding - 4 : oldPadding);
				const canvasWidth = state.portraitConfig.canvasWidth || 1920;
				const canvasHeight = state.portraitConfig.canvasHeight || 1080;

				const dialogueBox = canvasInner.querySelector(".canvas-dialogue-box");
				const nameEl = canvasInner.querySelector(".canvas-dialogue-name");
				const textEl = canvasInner.querySelector(".canvas-dialogue-text");

				if (dialogueBox) {
					// Apply background - image or solid color
					if (bgImage) {
						dialogueBox.style.background = `rgba(0, 0, 0, ${bgOpacity})`;
						dialogueBox.style.backgroundImage = `url(${bgImage})`;
						dialogueBox.style.backgroundSize = "cover";
						dialogueBox.style.backgroundPosition = "center";
						dialogueBox.style.backgroundRepeat = "no-repeat";
					} else {
						dialogueBox.style.background = `rgba(0, 0, 0, ${bgOpacity})`;
						dialogueBox.style.backgroundImage = "none";
					}
					dialogueBox.style.padding = `${paddingY}px ${paddingX}px`;
					dialogueBox.style.minHeight = `${height}px`;

					// Apply custom position if set
					if (style.x !== null && style.x !== undefined && style.y !== null && style.y !== undefined) {
						dialogueBox.classList.add("custom-position");
						dialogueBox.style.left = `${(style.x / 100) * canvasWidth}px`;
						dialogueBox.style.top = `${(style.y / 100) * canvasHeight}px`;
						dialogueBox.style.width = `${((style.width || 80) / 100) * canvasWidth}px`;
					} else {
						// Default: bottom center position
						dialogueBox.classList.remove("custom-position");
						dialogueBox.style.left = "50%";
						dialogueBox.style.top = "auto";
						dialogueBox.style.bottom = "20px";
						dialogueBox.style.transform = "translateX(-50%)";
						dialogueBox.style.width = "80%";
					}
				}
				if (nameEl) {
					nameEl.style.fontSize = `${nameSize}px`;
				}
				if (textEl) {
					textEl.style.fontSize = `${fontSize}px`;
				}
			}

			/**
			 * Update canvas dialogue content
			 * @param {string} name - Character name
			 * @param {string} text - Dialogue text
			 */
			function updateCanvasDialogue(name, text) {
				const canvasInner = DOM.portraitArea.querySelector(".portrait-canvas-inner");
				if (!canvasInner) return;

				const nameEl = canvasInner.querySelector(".canvas-dialogue-name");
				const textEl = canvasInner.querySelector(".canvas-dialogue-text");

				if (nameEl) nameEl.textContent = name || "";
				if (textEl) textEl.textContent = text || "";

				// Apply character-specific style
				const charStyle = getCharacterStyle(name || "");
				if (nameEl) {
					nameEl.style.color = charStyle.nameColor;
					if (charStyle.fontFamily) nameEl.style.fontFamily = charStyle.fontFamily;
					else nameEl.style.fontFamily = "";
				}
				if (textEl) {
					textEl.style.color = charStyle.textColor;
					if (charStyle.fontFamily) textEl.style.fontFamily = charStyle.fontFamily;
					else textEl.style.fontFamily = "";
				}
			}

			/**
			 * Handle dialogue drag start
			 * @param {MouseEvent|TouchEvent} e - Event
			 */
			function handleDialogueDragStart(e) {
				e.preventDefault();
				e.stopPropagation();

				const target = e.target;
				const dialogueBox = e.currentTarget;
				const canvasInner = DOM.portraitArea.querySelector(".portrait-canvas-inner");
				if (!canvasInner) return;

				// Check if clicking on resize handle
				const isResizeHandle = target.classList.contains("dialogue-resize-handle");
				const handle = isResizeHandle ? target.dataset.handle : null;

				const canvasWidth = state.portraitConfig.canvasWidth || 1920;
				const canvasHeight = state.portraitConfig.canvasHeight || 1080;
				const scale = state.portraitConfig.currentScale || 1;

				const clientX = e.touches ? e.touches[0].clientX : e.clientX;
				const clientY = e.touches ? e.touches[0].clientY : e.clientY;

				// Get current position and size in screen coordinates
				const rect = dialogueBox.getBoundingClientRect();
				const canvasRect = canvasInner.getBoundingClientRect();

				// Convert to canvas coordinates
				const startLeft = (rect.left - canvasRect.left) / scale;
				const startTop = (rect.top - canvasRect.top) / scale;
				const startWidth = rect.width / scale;
				const startHeight = rect.height / scale;

				// Immediately convert to absolute positioning (remove centering transform)
				dialogueBox.classList.add("custom-position");
				dialogueBox.style.left = `${startLeft}px`;
				dialogueBox.style.top = `${startTop}px`;
				dialogueBox.style.bottom = "auto";
				dialogueBox.style.transform = "none";
				dialogueBox.style.width = `${startWidth}px`;
				dialogueBox.style.minHeight = `${startHeight}px`;

				dialogueDragState = {
					type: isResizeHandle ? "resize" : "move",
					handle: handle,
					startX: clientX,
					startY: clientY,
					startLeft: startLeft,
					startTop: startTop,
					startWidth: startWidth,
					startHeight: startHeight,
					scale: scale,
					canvasWidth: canvasWidth,
					canvasHeight: canvasHeight,
				};

				dialogueBox.classList.add("dragging");
				document.addEventListener("mousemove", handleDialogueDrag);
				document.addEventListener("mouseup", handleDialogueDragEnd);
				document.addEventListener("touchmove", handleDialogueDrag, { passive: false });
				document.addEventListener("touchend", handleDialogueDragEnd);
			}

			/**
			 * Handle dialogue drag move
			 * @param {MouseEvent|TouchEvent} e - Event
			 */
			function handleDialogueDrag(e) {
				if (!dialogueDragState) return;
				e.preventDefault();

				const clientX = e.touches ? e.touches[0].clientX : e.clientX;
				const clientY = e.touches ? e.touches[0].clientY : e.clientY;

				const deltaX = (clientX - dialogueDragState.startX) / dialogueDragState.scale;
				const deltaY = (clientY - dialogueDragState.startY) / dialogueDragState.scale;

				const dialogueBox = DOM.portraitArea.querySelector(".canvas-dialogue-box");
				if (!dialogueBox) return;

				// Add custom-position class to disable default centering
				dialogueBox.classList.add("custom-position");

				if (dialogueDragState.type === "move") {
					// Move dialogue
					const newLeft = dialogueDragState.startLeft + deltaX;
					const newTop = dialogueDragState.startTop + deltaY;

					dialogueBox.style.left = `${newLeft}px`;
					dialogueBox.style.top = `${newTop}px`;
				} else if (dialogueDragState.type === "resize") {
					// Resize dialogue
					const handle = dialogueDragState.handle;
					let newLeft = dialogueDragState.startLeft;
					let newTop = dialogueDragState.startTop;
					let newWidth = dialogueDragState.startWidth;
					let newHeight = dialogueDragState.startHeight;

					// Handle horizontal resize
					if (handle.includes("right")) {
						newWidth = Math.max(300, dialogueDragState.startWidth + deltaX);
					}
					if (handle.includes("left")) {
						newWidth = Math.max(300, dialogueDragState.startWidth - deltaX);
						newLeft = dialogueDragState.startLeft + deltaX;
					}

					// Handle vertical resize
					if (handle.includes("bottom")) {
						newHeight = Math.max(80, dialogueDragState.startHeight + deltaY);
					}
					if (handle.includes("top")) {
						newHeight = Math.max(80, dialogueDragState.startHeight - deltaY);
						newTop = dialogueDragState.startTop + deltaY;
					}

					dialogueBox.style.left = `${newLeft}px`;
					dialogueBox.style.top = `${newTop}px`;
					dialogueBox.style.width = `${newWidth}px`;
					dialogueBox.style.minHeight = `${newHeight}px`;
				}
			}

			/**
			 * Handle dialogue drag end
			 */
			function handleDialogueDragEnd() {
				if (!dialogueDragState) return;

				const dialogueBox = DOM.portraitArea.querySelector(".canvas-dialogue-box");
				if (dialogueBox) {
					dialogueBox.classList.remove("dragging");

					// Save position and size as percentage
					const left = parseFloat(dialogueBox.style.left) || 0;
					const top = parseFloat(dialogueBox.style.top) || 0;
					const width = parseFloat(dialogueBox.style.width) || dialogueDragState.startWidth;
					const height = parseFloat(dialogueBox.style.minHeight) || 120;

					state.portraitConfig.dialogueStyle.x = (left / dialogueDragState.canvasWidth) * 100;
					state.portraitConfig.dialogueStyle.y = (top / dialogueDragState.canvasHeight) * 100;
					state.portraitConfig.dialogueStyle.width = (width / dialogueDragState.canvasWidth) * 100;
					state.portraitConfig.dialogueStyle.height = height;
					state.meta.lastModified = Date.now();

					// Sync height to UI input
					if (DOM.dialogueHeight) {
						DOM.dialogueHeight.value = Math.round(height);
					}
				}

				dialogueDragState = null;
				document.removeEventListener("mousemove", handleDialogueDrag);
				document.removeEventListener("mouseup", handleDialogueDragEnd);
				document.removeEventListener("touchmove", handleDialogueDrag);
				document.removeEventListener("touchend", handleDialogueDragEnd);
			}

			/**
			 * Remove canvas inner container (when switching to percent mode)
			 */
			function removeCanvasContainer() {
				const canvasInner = DOM.portraitArea.querySelector(".portrait-canvas-inner");
				if (canvasInner) {
					// Move wrappers back to portrait area
					const wrappers = canvasInner.querySelectorAll(".portrait-wrapper");
					wrappers.forEach((w) => DOM.portraitArea.appendChild(w));
					canvasInner.remove();
				}
				canvasZoom = 1.0; // Reset zoom
				canvasOffset = { x: 0, y: 0 }; // Reset position
			}

			/**
			 * Handle canvas drag start
			 * @param {MouseEvent} e - Mouse event
			 */
			function handleCanvasDragStart(e) {
				// Don't drag canvas if clicking on dialogue box (it has its own drag)
				const target = e.target;
				const isDialogueBox = target.closest(".canvas-dialogue-box") !== null;
				if (isDialogueBox) {
					return; // Let dialogue handle its own drag
				}

				// Only drag if clicking on the canvas area background or canvas inner (not portraits)
				const isCanvasBackground = target === DOM.portraitArea;
				const isCanvasInner = target.classList.contains("portrait-canvas-inner");

				if (!isCanvasBackground && !isCanvasInner) {
					return;
				}

				e.preventDefault();
				e.stopPropagation();
				canvasDragState = {
					startX: e.clientX,
					startY: e.clientY,
					startOffsetX: canvasOffset.x,
					startOffsetY: canvasOffset.y,
				};
				DOM.portraitArea.classList.add("dragging-canvas");
			}

			/**
			 * Handle canvas drag move
			 * @param {MouseEvent} e - Mouse event
			 */
			function handleCanvasDrag(e) {
				if (!canvasDragState) return;
				e.preventDefault();

				const deltaX = e.clientX - canvasDragState.startX;
				const deltaY = e.clientY - canvasDragState.startY;

				canvasOffset.x = canvasDragState.startOffsetX + deltaX;
				canvasOffset.y = canvasDragState.startOffsetY + deltaY;

				// Direct DOM update for smoother dragging
				const canvasInner = DOM.portraitArea.querySelector(".portrait-canvas-inner");
				if (canvasInner) {
					const areaWidth = DOM.portraitArea.clientWidth || 800;
					const areaHeight = DOM.portraitArea.clientHeight || 600;
					const canvasWidth = state.portraitConfig.canvasWidth || 1920;
					const canvasHeight = state.portraitConfig.canvasHeight || 1080;
					const finalScale = state.portraitConfig.currentScale || 1;

					const scaledWidth = canvasWidth * finalScale;
					const scaledHeight = canvasHeight * finalScale;
					const centerX = (areaWidth - scaledWidth) / 2 + canvasOffset.x;
					const centerY = (areaHeight - scaledHeight) / 2 + canvasOffset.y;

					canvasInner.style.transform = `translate(${centerX}px, ${centerY}px) scale(${finalScale})`;
				}
			}

			/**
			 * Handle canvas drag end
			 */
			function handleCanvasDragEnd() {
				if (!canvasDragState) return;
				canvasDragState = null;
				DOM.portraitArea.classList.remove("dragging-canvas");
			}

			/**
			 * Reset canvas view (zoom and position)
			 */
			function resetCanvasView() {
				canvasZoom = 1.0;
				canvasOffset = { x: 0, y: 0 };
				updateCanvasScale(0);
			}

			/**
			 * Create a portrait wrapper element for multi-mode
			 * @param {string} name - Character name
			 * @param {string} iconUrl - Icon URL
			 * @param {PortraitPosition} position - Position config (in percentage)
			 * @returns {HTMLElement}
			 */
			function createPortraitWrapper(name, iconUrl, position) {
				const wrapper = document.createElement("div");
				wrapper.className = "portrait-wrapper";
				wrapper.dataset.name = name;

				// Apply position (convert from percentage to pixels or use percentage directly)
				applyPortraitPosition(wrapper, position);

				const img = document.createElement("img");
				img.className = "portrait-image";
				img.src = iconUrl;
				img.alt = name;
				img.draggable = false;

				const label = document.createElement("div");
				label.className = "portrait-label";
				label.textContent = name;

				// Resize handles
				const handles = ["top-left", "top-right", "bottom-left", "bottom-right"];
				handles.forEach((pos) => {
					const handle = document.createElement("div");
					handle.className = `resize-handle ${pos}`;
					handle.dataset.handle = pos;
					wrapper.appendChild(handle);
				});

				wrapper.appendChild(img);
				wrapper.appendChild(label);

				// Drag events
				wrapper.addEventListener("mousedown", (e) => handlePortraitDragStart(e, name));
				wrapper.addEventListener("touchstart", (e) => handlePortraitDragStart(e, name), { passive: false });

				return wrapper;
			}

			/**
			 * Handle portrait drag start
			 * @param {MouseEvent|TouchEvent} e - Event
			 * @param {string} name - Character name
			 */
			function handlePortraitDragStart(e, name) {
				if (e.target.classList.contains("resize-handle")) {
					// Start resize
					handlePortraitResizeStart(e, name, e.target.dataset.handle);
					return;
				}

				e.preventDefault();
				const wrapper = portraitWrappers.get(name);
				if (!wrapper) return;

				const clientX = e.touches ? e.touches[0].clientX : e.clientX;
				const clientY = e.touches ? e.touches[0].clientY : e.clientY;

				let currentLeft, currentTop, currentWidth, currentHeight, scale;

				if (state.portraitConfig.scaleMode === "canvas") {
					// Canvas mode: read from style (canvas pixel coordinates)
					currentLeft = parseFloat(wrapper.style.left) || 0;
					currentTop = parseFloat(wrapper.style.top) || 0;
					currentWidth = parseFloat(wrapper.style.width) || 200;
					currentHeight = parseFloat(wrapper.style.height) || 300;
					scale = state.portraitConfig.currentScale || 1;
				} else {
					// Percent mode: use getBoundingClientRect for actual screen position
					const rect = wrapper.getBoundingClientRect();
					const areaRect = DOM.portraitArea.getBoundingClientRect();
					currentLeft = rect.left - areaRect.left;
					currentTop = rect.top - areaRect.top;
					currentWidth = rect.width;
					currentHeight = rect.height;
					scale = 1;

					// Convert to pixel positioning for dragging
					wrapper.style.left = `${currentLeft}px`;
					wrapper.style.top = `${currentTop}px`;
					wrapper.style.width = `${currentWidth}px`;
					wrapper.style.height = `${currentHeight}px`;
				}

				portraitDragState = {
					name,
					type: "move",
					startX: clientX,
					startY: clientY,
					startLeft: currentLeft,
					startTop: currentTop,
					startWidth: currentWidth,
					startHeight: currentHeight,
					scale: scale,
				};

				wrapper.classList.add("dragging");
				document.addEventListener("mousemove", handlePortraitDrag);
				document.addEventListener("mouseup", handlePortraitDragEnd);
				document.addEventListener("touchmove", handlePortraitDrag, { passive: false });
				document.addEventListener("touchend", handlePortraitDragEnd);
			}

			/**
			 * Handle portrait resize start
			 * @param {MouseEvent|TouchEvent} e - Event
			 * @param {string} name - Character name
			 * @param {string} handle - Handle position
			 */
			function handlePortraitResizeStart(e, name, handle) {
				e.preventDefault();
				e.stopPropagation();
				const wrapper = portraitWrappers.get(name);
				if (!wrapper) return;

				const clientX = e.touches ? e.touches[0].clientX : e.clientX;
				const clientY = e.touches ? e.touches[0].clientY : e.clientY;

				let currentLeft, currentTop, currentWidth, currentHeight, scale;

				if (state.portraitConfig.scaleMode === "canvas") {
					// Canvas mode: read from style (canvas pixel coordinates)
					currentLeft = parseFloat(wrapper.style.left) || 0;
					currentTop = parseFloat(wrapper.style.top) || 0;
					currentWidth = parseFloat(wrapper.style.width) || 200;
					currentHeight = parseFloat(wrapper.style.height) || 300;
					scale = state.portraitConfig.currentScale || 1;
				} else {
					// Percent mode: use getBoundingClientRect for actual screen position
					const rect = wrapper.getBoundingClientRect();
					const areaRect = DOM.portraitArea.getBoundingClientRect();
					currentLeft = rect.left - areaRect.left;
					currentTop = rect.top - areaRect.top;
					currentWidth = rect.width;
					currentHeight = rect.height;
					scale = 1;

					// Convert to pixel positioning for resizing
					wrapper.style.left = `${currentLeft}px`;
					wrapper.style.top = `${currentTop}px`;
					wrapper.style.width = `${currentWidth}px`;
					wrapper.style.height = `${currentHeight}px`;
				}

				portraitDragState = {
					name,
					type: "resize",
					handle,
					startX: clientX,
					startY: clientY,
					startLeft: currentLeft,
					startTop: currentTop,
					startWidth: currentWidth,
					startHeight: currentHeight,
					scale: scale,
				};

				wrapper.classList.add("dragging");
				document.addEventListener("mousemove", handlePortraitDrag);
				document.addEventListener("mouseup", handlePortraitDragEnd);
				document.addEventListener("touchmove", handlePortraitDrag, { passive: false });
				document.addEventListener("touchend", handlePortraitDragEnd);
			}

			/**
			 * Handle portrait drag/resize move
			 * @param {MouseEvent|TouchEvent} e - Event
			 */
			function handlePortraitDrag(e) {
				if (!portraitDragState) return;
				e.preventDefault();

				const clientX = e.touches ? e.touches[0].clientX : e.clientX;
				const clientY = e.touches ? e.touches[0].clientY : e.clientY;
				const wrapper = portraitWrappers.get(portraitDragState.name);
				if (!wrapper) return;

				// Convert screen delta to canvas delta (divide by scale)
				const scale = portraitDragState.scale;
				const deltaX = (clientX - portraitDragState.startX) / scale;
				const deltaY = (clientY - portraitDragState.startY) / scale;

				if (portraitDragState.type === "move") {
					const newLeft = portraitDragState.startLeft + deltaX;
					const newTop = portraitDragState.startTop + deltaY;
					wrapper.style.left = `${newLeft}px`;
					wrapper.style.top = `${newTop}px`;
				} else if (portraitDragState.type === "resize") {
					const handle = portraitDragState.handle;
					let newWidth = portraitDragState.startWidth;
					let newHeight = portraitDragState.startHeight;
					let newLeft = portraitDragState.startLeft;
					let newTop = portraitDragState.startTop;

					if (handle.includes("right")) {
						newWidth = Math.max(100, portraitDragState.startWidth + deltaX);
					}
					if (handle.includes("left")) {
						newWidth = Math.max(100, portraitDragState.startWidth - deltaX);
						newLeft = portraitDragState.startLeft + deltaX;
					}
					if (handle.includes("bottom")) {
						newHeight = Math.max(100, portraitDragState.startHeight + deltaY);
					}
					if (handle.includes("top")) {
						newHeight = Math.max(100, portraitDragState.startHeight - deltaY);
						newTop = portraitDragState.startTop + deltaY;
					}

					wrapper.style.width = `${newWidth}px`;
					wrapper.style.height = `${newHeight}px`;
					wrapper.style.left = `${newLeft}px`;
					wrapper.style.top = `${newTop}px`;
				}
			}

			/**
			 * Handle portrait drag/resize end
			 */
			function handlePortraitDragEnd() {
				if (!portraitDragState) return;

				const wrapper = portraitWrappers.get(portraitDragState.name);
				if (wrapper) {
					wrapper.classList.remove("dragging");

					let pixelPos;

					if (state.portraitConfig.scaleMode === "canvas") {
						// Canvas mode: read directly from style (already in canvas coordinates)
						pixelPos = {
							x: parseFloat(wrapper.style.left) || 0,
							y: parseFloat(wrapper.style.top) || 0,
							width: parseFloat(wrapper.style.width) || 200,
							height: parseFloat(wrapper.style.height) || 300,
						};
					} else {
						// Percent mode: get position relative to portrait area
						const rect = wrapper.getBoundingClientRect();
						const areaRect = DOM.portraitArea.getBoundingClientRect();
						pixelPos = {
							x: rect.left - areaRect.left,
							y: rect.top - areaRect.top,
							width: rect.width,
							height: rect.height,
						};
					}

					// Convert to percentage and save
					const percentPos = pixelToPercent(pixelPos);
					state.portraitConfig.positions[portraitDragState.name] = percentPos;

					// Re-apply position using the percentage system
					applyPortraitPosition(wrapper, percentPos);

					state.meta.lastModified = Date.now();
				}

				portraitDragState = null;
				document.removeEventListener("mousemove", handlePortraitDrag);
				document.removeEventListener("mouseup", handlePortraitDragEnd);
				document.removeEventListener("touchmove", handlePortraitDrag);
				document.removeEventListener("touchend", handlePortraitDragEnd);
			}

			/**
			 * Initialize multi-mode portraits
			 */
			function initMultiModePortraits() {
				// Clear existing wrappers
				portraitWrappers.forEach((wrapper) => wrapper.remove());
				portraitWrappers.clear();
				activeCharacters.clear();

				// Remove old canvas container if exists
				removeCanvasContainer();

				// Hide single portrait
				DOM.portraitImg.classList.add("hidden");

				// Get all characters
				const characters = extractCharacters(state.editedMessages);
				const charArray = Array.from(characters.entries());

				// Determine the container for portraits
				let container = DOM.portraitArea;
				if (state.portraitConfig.scaleMode === "canvas") {
					// Create canvas container first - use requestAnimationFrame to ensure DOM is ready
					requestAnimationFrame(() => {
						updateCanvasScale();
						// Move wrappers into canvas after it's created
						const canvasInner = DOM.portraitArea.querySelector(".portrait-canvas-inner");
						if (canvasInner) {
							portraitWrappers.forEach((wrapper) => {
								canvasInner.appendChild(wrapper);
							});
						}
					});
				}

				// Create wrappers for each character (add to portraitArea first, will be moved to canvas if needed)
				charArray.forEach(([name, iconUrl], index) => {
					const position = state.portraitConfig.positions[name] || getDefaultPosition(index, charArray.length);

					const wrapper = createPortraitWrapper(name, iconUrl, position);
					wrapper.classList.add("offstage"); // Start offstage - need stage enter to show
					DOM.portraitArea.appendChild(wrapper);
					portraitWrappers.set(name, wrapper);

					// Save default position if not exists
					if (!state.portraitConfig.positions[name]) {
						state.portraitConfig.positions[name] = position;
					}
				});

				DOM.portraitArea.classList.add("multi-mode");

				// Recalculate active characters based on current position
				if (state.editedMessages.length > 0) {
					recalculateActiveCharacters(currentMessageIndex);
				}
			}

			/**
			 * Update portrait display for multi-mode
			 * @param {Message} msg - Current message
			 */
			function updateMultiModePortraits(msg) {
				const speakerName = msg.name;
				const speakerIconUrl = msg.iconUrl;

				// Update display state for all portraits based on activeCharacters set
				portraitWrappers.forEach((wrapper, name) => {
					const isOnStage = activeCharacters.has(name); // 是否在场
					const isSpeaker = name === speakerName; // 是否是当前发言者

					// 不在场 - 完全不显示
					wrapper.classList.toggle("offstage", !isOnStage);

					// 在场但不是发言者 - 半透明
					wrapper.classList.toggle("inactive", isOnStage && !isSpeaker);

					// 当前发言者 - 完全显示并高亮
					wrapper.classList.toggle("speaking", isOnStage && isSpeaker);

					// 发言者在最上层
					wrapper.style.zIndex = isOnStage && isSpeaker ? "10" : "1";

					// 更新发言者的立绘差分图片
					if (isSpeaker && speakerIconUrl) {
						const img = wrapper.querySelector(".portrait-image");
						if (img) {
							// 直接设置 src，浏览器会自动处理相同 URL 的情况
							img.src = speakerIconUrl;
						}
					}
				});

				currentSpeaker = speakerName;
			}

			/**
			 * Reset all portrait positions to default
			 */
			function resetPortraitPositions() {
				const characters = extractCharacters(state.editedMessages);
				const charArray = Array.from(characters.entries());

				charArray.forEach(([name], index) => {
					const position = getDefaultPosition(index, charArray.length);
					state.portraitConfig.positions[name] = position;

					const wrapper = portraitWrappers.get(name);
					if (wrapper) {
						applyPortraitPosition(wrapper, position);
					}
				});

				state.meta.lastModified = Date.now();
			}

			/**
			 * Display a message in the player
			 * @param {number} index - Message index
			 * @param {boolean} skipAnimation - Whether to skip typing animation
			 */
			function displayMessage(index, skipAnimation = false) {
				const messages = state.editedMessages;
				if (index < 0 || index >= messages.length) return;

				const msg = messages[index];

				// Stop any current TTS before starting new one
				TTSManager.stop();

				// Update dialogue name
				if (msg.type === "narration") {
					DOM.dialogueName.textContent = "";
					DOM.dialogueName.style.display = "none";
				} else if (msg.type === "system") {
					DOM.dialogueName.textContent = "System";
					DOM.dialogueName.style.display = "block";
				} else {
					DOM.dialogueName.textContent = msg.name || "";
					DOM.dialogueName.style.display = msg.name ? "block" : "none";
				}

				// Prepare text content
				let displayText = msg.text || "";

				// Add dice result if present
				if (msg.diceInfo && msg.diceInfo.result) {
					const diceText = formatDiceResult(msg.diceInfo);
					if (diceText) {
						displayText = displayText ? `${displayText}\n${diceText}` : diceText;
					}
				}

				// Apply typing effect or show immediately
				if (skipAnimation) {
					DOM.dialogueText.textContent = displayText;
					DOM.dialogueText.classList.remove("typing");
					DOM.dialogueBox.classList.remove("typing");
					isTyping = false;
				} else {
					startTyping(displayText, state.settings.typingSpeed);
				}

				// Update portrait (multi-mode)
				applyStageSnapshot(index);
				updateMultiModePortraits(msg);

				// Apply special styles based on message type
				DOM.dialogueBox.className = "dialogue-box";
				if (msg.type === "narration") {
					DOM.dialogueText.className = "dialogue-text narration-text";
				} else if (msg.type === "system") {
					DOM.dialogueBox.classList.add("system-message");
					DOM.dialogueText.className = "dialogue-text";
				} else {
					DOM.dialogueText.className = "dialogue-text";
				}

				// Apply dice result style
				if (msg.diceInfo) {
					const diceClass = getDiceClass(msg.diceInfo);
					if (diceClass) {
						DOM.dialogueBox.classList.add(diceClass);
					}
				}

				// Update canvas dialogue if in canvas mode
				if (state.portraitConfig.scaleMode === "canvas") {
					const displayName = msg.type === "narration" ? "" : msg.type === "system" ? "System" : msg.name || "";
					// Only set name here, text will be updated by typing effect or set below if skipping
					updateCanvasDialogue(displayName, skipAnimation ? displayText : "");
				}

				// Update background
				updateBackground(index);

				// Update BGM
				BGMManager.updateBGM(index);

				// Update history panel
				renderHistoryPanel();

				// Play TTS for the message (only for regular messages with text)
				if (msg.text && msg.name && msg.type !== "narration" && msg.type !== "system") {
					const voiceConfig = TTSManager.getEffectiveVoiceConfig(msg.name);

					// 如果是自动播放模式，等待 TTS 播放完成后自动切换下一条
					if (isAutoPlaying) {
						TTSManager.speak(msg.text, voiceConfig).then(() => {
							// TTS 播放完成，检查是否仍在自动播放模式
							if (isAutoPlaying && currentMessageIndex < state.editedMessages.length - 1) {
								// 等待打字机完成（如果还在打字）
								if (isTyping) {
									skipTyping();
								}
								// 短暂延迟后切换下一条
								setTimeout(() => {
									if (isAutoPlaying) {
										goToNext(true);
									}
								}, 300);
							} else if (isAutoPlaying && currentMessageIndex >= state.editedMessages.length - 1) {
								// 已到最后一条，停止自动播放
								stopAutoPlay();
							}
						});
					} else {
						TTSManager.speak(msg.text, voiceConfig);
					}

					// 预加载后续消息的音频
					TTSManager.preloadAudio(index);
				} else if (isAutoPlaying) {
					// 非对话消息（旁白/系统），自动播放时等待打字机完成后切换
					const waitForTyping = () => {
						if (isTyping) {
							setTimeout(waitForTyping, 100);
						} else if (isAutoPlaying && currentMessageIndex < state.editedMessages.length - 1) {
							setTimeout(() => {
								if (isAutoPlaying) {
									goToNext(true);
								}
							}, 1000); // 旁白/系统消息停留 1 秒
						} else if (isAutoPlaying) {
							stopAutoPlay();
						}
					};
					waitForTyping();
				}
			}

			/**
			 * Update progress bar and text
			 */
			function updateProgress() {
				const total = state.editedMessages.length;
				const current = currentMessageIndex + 1;

				DOM.progressText.textContent = `${current} / ${total}`;
				DOM.progressFill.style.width = total > 0 ? `${(current / total) * 100}%` : "0%";
			}

			// ============================================================
			// History Panel
			// ============================================================

			/**
			 * Render history panel with all messages up to current
			 */
			function renderHistoryPanel() {
				const messages = state.editedMessages;
				DOM.historyList.innerHTML = "";

				// Show all messages up to and including current
				for (let i = 0; i <= currentMessageIndex && i < messages.length; i++) {
					const msg = messages[i];
					const item = document.createElement("div");
					item.className = "history-item" + (i === currentMessageIndex ? " current" : "");
					item.dataset.index = i;

					const displayName = msg.name || (msg.type === "narration" ? "旁白" : msg.type === "system" ? "System" : "");
					const truncatedText = msg.text.length > 50 ? msg.text.substring(0, 50) + "..." : msg.text;

					item.innerHTML = `
						${
							msg.iconUrl
								? `<img class="history-item-icon" src="${msg.iconUrl}" alt="" onerror="this.style.display='none'">`
								: '<div class="history-item-icon" style="background: var(--bg-secondary);"></div>'
						}
						<div class="history-item-content">
							<div class="history-item-name">${displayName || "（无名）"}</div>
							<div class="history-item-text">${truncatedText || "(空消息)"}</div>
						</div>
						<span class="history-item-index">#${i + 1}</span>
					`;

					item.addEventListener("click", () => {
						jumpToMessage(i);
						DOM.historyPanel.classList.remove("visible");
					});

					DOM.historyList.appendChild(item);
				}

				// Scroll to bottom to show current message
				DOM.historyList.scrollTop = DOM.historyList.scrollHeight;
			}

			/**
			 * Jump to a specific message
			 * @param {number} index - Message index to jump to
			 */
			function jumpToMessage(index) {
				const messages = state.editedMessages;
				if (index < 0 || index >= messages.length) return;

				// 跳转时停止自动播放
				if (isAutoPlaying) {
					stopAutoPlay();
				}

				currentMessageIndex = index;

				// Recalculate active characters when jumping
				recalculateActiveCharacters(index);

				displayMessage(index, true); // Skip animation when jumping
				updateProgress();
			}

			// ============================================================
			// Player Controls
			// ============================================================

			/**
			 * Go to previous message
			 */
			function goToPrevious() {
				// 手动切换时停止自动播放
				if (isAutoPlaying) {
					stopAutoPlay();
				}

				if (currentMessageIndex > 0) {
					currentMessageIndex--;
					displayMessage(currentMessageIndex);
					updateProgress();
				}
			}

			/**
			 * Go to next message
			 * @param {boolean} [fromAutoPlay=false] - 是否由自动播放触发
			 */
			function goToNext(fromAutoPlay = false) {
				// 手动切换时停止自动播放
				if (!fromAutoPlay && isAutoPlaying) {
					stopAutoPlay();
				}

				if (currentMessageIndex < state.editedMessages.length - 1) {
					currentMessageIndex++;
					displayMessage(currentMessageIndex);
					updateProgress();
				}
			}

			/**
			 * 开始自动播放
			 */
			function startAutoPlay() {
				if (state.editedMessages.length === 0) return;

				isAutoPlaying = true;
				DOM.btnAutoPlay.textContent = "⏸";
				DOM.btnAutoPlay.title = "暂停自动播放";
				DOM.btnAutoPlay.classList.add("active");

				// 如果当前消息已经显示完，直接切换下一条开始
				if (!isTyping && !TTSManager.isSpeaking()) {
					if (currentMessageIndex < state.editedMessages.length - 1) {
						goToNext(true);
					} else {
						// 已经是最后一条，重新播放当前消息
						displayMessage(currentMessageIndex);
					}
				} else {
					// 正在打字或朗读中，等待完成后自动切换
					waitForCurrentMessageComplete();
				}
			}

			/**
			 * 等待当前消息完成后自动切换下一条
			 */
			function waitForCurrentMessageComplete() {
				const checkComplete = () => {
					// 如果已停止自动播放，不再检查
					if (!isAutoPlaying) return;

					// 如果还在打字或朗读，继续等待
					if (isTyping || TTSManager.isSpeaking()) {
						setTimeout(checkComplete, 100);
						return;
					}

					// 完成了，切换下一条
					if (currentMessageIndex < state.editedMessages.length - 1) {
						setTimeout(() => {
							if (isAutoPlaying) {
								goToNext(true);
							}
						}, 300);
					} else {
						// 已到最后一条，停止自动播放
						stopAutoPlay();
					}
				};
				checkComplete();
			}

			/**
			 * 停止自动播放
			 */
			function stopAutoPlay() {
				isAutoPlaying = false;
				DOM.btnAutoPlay.textContent = "▶";
				DOM.btnAutoPlay.title = "自动播放";
				DOM.btnAutoPlay.classList.remove("active");
			}

			/**
			 * 切换自动播放状态
			 */
			function toggleAutoPlay() {
				if (isAutoPlaying) {
					stopAutoPlay();
				} else {
					startAutoPlay();
				}
			}

			/**
			 * Handle click on dialogue area
			 */
			function handleDialogueClick() {
				// 点击对话框时停止自动播放
				if (isAutoPlaying) {
					stopAutoPlay();
				}

				if (isTyping) {
					// Skip typing animation
					skipTyping();
				} else {
					// Go to next message
					goToNext();
				}
			}

			/**
			 * Handle click on progress bar
			 * @param {MouseEvent} e - Click event
			 */
			function handleProgressBarClick(e) {
				const rect = DOM.progressBar.getBoundingClientRect();
				const clickX = e.clientX - rect.left;
				const percentage = clickX / rect.width;
				const targetIndex = Math.floor(percentage * state.editedMessages.length);

				if (targetIndex >= 0 && targetIndex < state.editedMessages.length) {
					jumpToMessage(targetIndex);
				}
			}

			/**
			 * Check if there's existing data that would be lost
			 * @param {string} actionName - Description of the action being performed
			 * @returns {boolean} - True if user confirms or no data exists
			 */
			function confirmOverwriteData(actionName) {
				const msgCount = state.editedMessages.length;
				const bgmCount = state.bgmLibrary.length;

				if (msgCount === 0 && bgmCount === 0) return true;

				const details = [];
				if (msgCount > 0) details.push(`${msgCount} 条消息`);
				if (bgmCount > 0) details.push(`${bgmCount} 个 BGM`);

				return confirm(
					`当前项目有 ${details.join("、")}。\n\n` +
						`${actionName}会覆盖这些数据，建议先导出保存。\n\n` +
						`确定要继续吗？`
				);
			}

			/**
			 * Handle fetch button click
			 */
			async function handleFetchLogs() {
				const input = DOM.inputRoom.value;
				const roomId = extractRoomId(input);

				if (!roomId) {
					showError("请输入有效的房间号或 URL");
					return;
				}

				// 防呆检查
				if (!confirmOverwriteData("获取新的房间日志")) return;

				hideError();
				showLoading("正在连接...");

				try {
					showLoading("正在获取日志...");
					const rawLogs = await fetchRoomLogs(roomId);

					if (rawLogs.length === 0) {
						showError("该房间没有消息记录");
						hideLoading();
						return;
					}

					showLoading("正在解析数据...");
					const messages = parseLogs(rawLogs);

					// Update state
					state.originalMessages = messages;
					state.editedMessages = [...messages];
					state.deletedIds = new Set();
					state.meta.roomId = roomId;
					state.meta.createdAt = Date.now();
					state.meta.lastModified = Date.now();

					// Reset player
					currentMessageIndex = 0;
					currentPage = 1;

					// Initialize character data from messages
					CharacterManager.initFromMessages(messages);

					// Update UI
					renderMessageListFull();
					renderChannelCheckboxes(messages);
					renderCharacterStyleList();
					renderBackgroundSwitchList();

					// Build stage snapshots for quick lookup
					buildStageSnapshots();

					// Initialize multi-mode portraits
					initMultiModePortraits();

					displayMessage(0);
					updateProgress();

					hideLoading();
					console.log(`成功获取 ${messages.length} 条消息`);
				} catch (error) {
					console.error("Fetch error:", error);
					showError(error.message || "获取日志失败，请重试");
					hideLoading();
				}
			}

			DOM.btnFetch.addEventListener("click", handleFetchLogs);

			// ============================================================
			// Storage & Export Functions
			// ============================================================

			const STORAGE_KEY = "ccfolia-replay-editor-autosave";
			const AUTOSAVE_INTERVAL = 30000; // 30 seconds
			let autosaveTimer = null;

			/**
			 * Serialize state to JSON-compatible object
			 * @returns {Object} Serializable state object
			 */
			function serializeState() {
				return {
					version: 1,
					originalMessages: state.originalMessages,
					editedMessages: state.editedMessages,
					deletedIds: Array.from(state.deletedIds),
					filterRules: state.filterRules,
					portraitConfig: state.portraitConfig,
					settings: state.settings,
					characters: state.characters,
					ttsSettings: state.ttsSettings,
					bgmSettings: state.bgmSettings,
					bgmLibrary: state.bgmLibrary,
					customCategories: state.customCategories,
					meta: state.meta,
				};
			}

			/**
			 * Deserialize state from JSON object
			 * @param {Object} data - Serialized state object
			 */
			function deserializeState(data) {
				if (!data || typeof data !== "object") {
					throw new Error("无效的项目数据");
				}

				// Validate version
				if (data.version !== 1) {
					console.warn("项目版本不匹配，尝试兼容加载");
				}

				// Restore state
				state.originalMessages = data.originalMessages || [];
				state.editedMessages = data.editedMessages || [];
				state.deletedIds = new Set(data.deletedIds || []);
				state.filterRules = {
					...state.filterRules,
					...(data.filterRules || {}),
				};
				state.portraitConfig = {
					...state.portraitConfig,
					...(data.portraitConfig || {}),
				};
				state.settings = {
					...state.settings,
					...(data.settings || {}),
				};
				state.characters = data.characters || {};
				state.ttsSettings = {
					...state.ttsSettings,
					...(data.ttsSettings || {}),
				};
				state.bgmSettings = {
					...state.bgmSettings,
					...(data.bgmSettings || {}),
				};
				state.bgmLibrary = data.bgmLibrary || [];
				state.customCategories = data.customCategories || [];
				state.meta = {
					...state.meta,
					...(data.meta || {}),
				};
			}

			/**
			 * Save state to localStorage
			 */
			function saveToLocalStorage() {
				try {
					const data = serializeState();
					localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
					state.meta.lastModified = Date.now();
					console.log("自动保存成功");
				} catch (error) {
					console.error("自动保存失败:", error);
					if (error.name === "QuotaExceededError") {
						showError("存储空间已满，请导出项目后清理");
					}
				}
			}

			/**
			 * Load state from localStorage
			 * @returns {boolean} Whether data was loaded
			 */
			function loadFromLocalStorage() {
				try {
					const saved = localStorage.getItem(STORAGE_KEY);
					if (!saved) return false;

					const data = JSON.parse(saved);
					deserializeState(data);
					return true;
				} catch (error) {
					console.error("加载自动保存失败:", error);
					return false;
				}
			}

			/**
			 * Check if there's autosave data and prompt user
			 */
			function checkAutosave() {
				const saved = localStorage.getItem(STORAGE_KEY);
				if (!saved) return;

				try {
					const data = JSON.parse(saved);
					const hasMessages = data.editedMessages && data.editedMessages.length > 0;
					const hasBgmLibrary = data.bgmLibrary && data.bgmLibrary.length > 0;

					if (hasMessages || hasBgmLibrary) {
						const lastModified = data.meta?.lastModified
							? new Date(data.meta.lastModified).toLocaleString()
							: "未知时间";
						const messageCount = data.editedMessages?.length || 0;
						const bgmCount = data.bgmLibrary?.length || 0;

						let info = [];
						if (messageCount > 0) info.push(`${messageCount} 条消息`);
						if (bgmCount > 0) info.push(`${bgmCount} 个 BGM`);

						if (confirm(`发现上次的自动保存 (${info.join(", ")}, ${lastModified})\n是否恢复？`)) {
							loadFromLocalStorage();
							refreshUI();
							console.log("已恢复自动保存");
						}
					}
				} catch (error) {
					console.error("检查自动保存失败:", error);
				}
			}

			/**
			 * Start autosave timer
			 */
			function startAutosave() {
				if (autosaveTimer) {
					clearInterval(autosaveTimer);
				}
				autosaveTimer = setInterval(() => {
					// 有消息或有 BGM 库时都保存
					if (state.editedMessages.length > 0 || state.bgmLibrary.length > 0) {
						saveToLocalStorage();
					}
				}, AUTOSAVE_INTERVAL);
			}

			/**
			 * Stop autosave timer
			 */
			function stopAutosave() {
				if (autosaveTimer) {
					clearInterval(autosaveTimer);
					autosaveTimer = null;
				}
			}

			/**
			 * Clear autosave data
			 */
			function clearAutosave() {
				localStorage.removeItem(STORAGE_KEY);
			}

			/**
			 * Refresh UI after loading state
			 */
			function refreshUI() {
				currentMessageIndex = 0;
				currentPage = 1;

				renderMessageListFull();
				if (state.originalMessages.length > 0) {
					renderChannelCheckboxes(state.originalMessages);
				}
				renderCharacterStyleList();
				renderBackgroundSwitchList();
				renderBgmLibraryList();
				renderBgmSwitchList();
				buildStageSnapshots();
				initMultiModePortraits();

				// Render prefix tags
				renderPrefixTags();

				// Sync BGM UI with state
				DOM.bgmVolumeSlider.value = state.bgmSettings.volume * 100;
				DOM.bgmVolumeValue.textContent = `${Math.round(state.bgmSettings.volume * 100)}%`;
				DOM.bgmMuteBtn.textContent = state.bgmSettings.muted ? "🔇" : "🔊";
				DOM.bgmLoopCheckbox.checked = state.bgmSettings.loop;

				// Sync dialogue style UI with state
				syncDialogueStyleUI();

				// Always reinitialize character data from messages
				if (state.editedMessages.length > 0) {
					CharacterManager.initFromMessages(state.editedMessages);
				}

				// 延迟显示第一条消息，确保画布模式下对话框已创建
				if (state.editedMessages.length > 0) {
					requestAnimationFrame(() => {
						requestAnimationFrame(() => {
							displayMessage(0);
							updateProgress();
						});
					});
				} else {
					updateProgress();
				}

				// 初始预加载 TTS 音频
				if (state.editedMessages.length > 0) {
					TTSManager.initialPreload(0);
				}
			}

			/**
			 * Sync dialogue style settings from state to UI inputs
			 */
			function syncDialogueStyleUI() {
				const style = state.portraitConfig.dialogueStyle;

				if (DOM.dialogueFontSize) DOM.dialogueFontSize.value = style.fontSize || 24;
				if (DOM.dialogueNameSize) DOM.dialogueNameSize.value = style.nameSize || 20;
				if (DOM.dialogueBgOpacity) {
					DOM.dialogueBgOpacity.value = style.bgOpacity || 70;
					if (DOM.dialogueBgOpacityValue) {
						DOM.dialogueBgOpacityValue.textContent = `${style.bgOpacity || 70}%`;
					}
				}
				if (DOM.dialogueBgImage) DOM.dialogueBgImage.value = style.bgImage || "";
				if (DOM.dialogueHeight) DOM.dialogueHeight.value = style.height || 150;
				if (DOM.dialoguePaddingX) DOM.dialoguePaddingX.value = style.paddingX || 20;
				if (DOM.dialoguePaddingY) DOM.dialoguePaddingY.value = style.paddingY || 16;
				if (DOM.dialogueNameColor) DOM.dialogueNameColor.value = style.nameColor || "#ffffff";
				if (DOM.dialogueNameColorText) DOM.dialogueNameColorText.value = style.nameColor || "#ffffff";
				if (DOM.dialogueTextColor) DOM.dialogueTextColor.value = style.textColor || "#ffffff";
				if (DOM.dialogueTextColorText) DOM.dialogueTextColorText.value = style.textColor || "#ffffff";
				if (DOM.dialogueFontFamily) DOM.dialogueFontFamily.value = style.fontFamily || "";
			}

			/**
			 * Export project as JSON file
			 */
			function exportProjectJSON() {
				if (state.editedMessages.length === 0) {
					showError("没有可导出的数据");
					return;
				}

				const data = serializeState();
				const json = JSON.stringify(data, null, 2);
				const blob = new Blob([json], { type: "application/json" });
				const url = URL.createObjectURL(blob);

				const a = document.createElement("a");
				a.href = url;
				a.download = `ccfolia-replay-${state.meta.roomId || "project"}-${Date.now()}.json`;
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				URL.revokeObjectURL(url);

				console.log("项目已导出");
			}

			/**
			 * Export edited messages as formatted log text
			 * Format: [角色名]:消息内容
			 */
			function exportLogText() {
				if (state.editedMessages.length === 0) {
					showError("没有可导出的数据");
					return;
				}

				const lines = state.editedMessages.map((msg) => {
					const name = msg.name || "旁白";
					const text = msg.text || "";
					return `[${name}]:${text}`;
				});

				const content = lines.join("\n");
				const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
				const url = URL.createObjectURL(blob);

				const a = document.createElement("a");
				a.href = url;
				a.download = `ccfolia-log-${state.meta.roomId || "export"}-${Date.now()}.txt`;
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				URL.revokeObjectURL(url);

				console.log("Log已导出");
			}

			/**
			 * Import project from JSON file
			 */
			function importProjectJSON() {
				// 防呆检查
				if (!confirmOverwriteData("导入项目")) return;

				const input = document.createElement("input");
				input.type = "file";
				input.accept = ".json";

				input.onchange = async (e) => {
					const file = e.target.files[0];
					if (!file) return;

					try {
						const text = await file.text();
						const data = JSON.parse(text);
						deserializeState(data);
						refreshUI();
						console.log("项目已导入");
					} catch (error) {
						console.error("导入失败:", error);
						showError("导入失败: " + (error.message || "文件格式错误"));
					}
				};

				input.click();
			}

			// ============================================================
			// Channel Checkbox Functions
			// ============================================================

			/**
			 * Extract unique channel names from messages
			 * @param {Message[]} messages - Array of messages
			 * @returns {string[]} Array of unique channel names
			 */
			function extractChannels(messages) {
				const channels = new Set();
				messages.forEach((msg) => {
					if (msg.channelName) {
						channels.add(msg.channelName);
					}
				});
				return Array.from(channels).sort();
			}

			/**
			 * Render channel checkboxes based on available channels
			 * @param {Message[]} messages - Array of messages to extract channels from
			 */
			function renderChannelCheckboxes(messages) {
				const channels = extractChannels(messages);

				if (channels.length === 0) {
					DOM.channelCheckboxes.innerHTML =
						'<span style="color: var(--text-secondary); font-size: 0.8rem;">没有找到频道</span>';
					return;
				}

				DOM.channelCheckboxes.innerHTML = channels
					.map((channel) => {
						const isExcluded = state.filterRules.channelBlacklist.includes(channel);
						return `
							<label class="flex items-center gap-2" style="margin-bottom: 4px; cursor: pointer;">
								<input type="checkbox" class="channel-filter-checkbox" value="${channel}" ${isExcluded ? "checked" : ""} />
								<span style="font-size: 0.85rem;">${channel}</span>
							</label>
						`;
					})
					.join("");
			}

			/**
			 * Get selected (excluded) channels from checkboxes
			 * @returns {string[]} Array of channel names to exclude
			 */
			function getExcludedChannels() {
				const checkboxes = DOM.channelCheckboxes.querySelectorAll(".channel-filter-checkbox:checked");
				return Array.from(checkboxes).map((cb) => cb.value);
			}

			// ============================================================
			// Filter Functions
			// ============================================================

			/**
			 * Check if a message is empty (empty string or whitespace only)
			 * @param {Message} message - Message to check
			 * @returns {boolean} true if the message text is empty or whitespace only
			 */
			function isEmptyMessage(message) {
				return !message.text || message.text.trim() === "";
			}

			/**
			 * Filter out empty messages
			 * @param {Message[]} messages - Array of messages to filter
			 * @returns {Message[]} Filtered array without empty messages
			 */
			function filterEmptyMessages(messages) {
				return messages.filter((msg) => !isEmptyMessage(msg));
			}

			/**
			 * Check if a message starts with any of the blacklisted prefixes
			 * @param {Message} message - Message to check
			 * @param {string[]} prefixBlacklist - Array of prefixes to filter
			 * @returns {boolean} true if the message starts with a blacklisted prefix
			 */
			function hasBlacklistedPrefix(message, prefixBlacklist) {
				if (!message.text || prefixBlacklist.length === 0) {
					return false;
				}
				return prefixBlacklist.some((prefix) => {
					const trimmedPrefix = prefix.trim();
					return trimmedPrefix && message.text.startsWith(trimmedPrefix);
				});
			}

			/**
			 * Filter out messages that start with blacklisted prefixes
			 * @param {Message[]} messages - Array of messages to filter
			 * @param {string[]} prefixBlacklist - Array of prefixes to filter
			 * @returns {Message[]} Filtered array
			 */
			function filterByPrefix(messages, prefixBlacklist) {
				if (prefixBlacklist.length === 0) {
					return messages;
				}
				return messages.filter((msg) => !hasBlacklistedPrefix(msg, prefixBlacklist));
			}

			/**
			 * Check if a message belongs to a blacklisted channel
			 * @param {Message} message - Message to check
			 * @param {string[]} channelBlacklist - Array of channel names to filter
			 * @returns {boolean} true if the message is in a blacklisted channel
			 */
			function isInBlacklistedChannel(message, channelBlacklist) {
				if (!message.channelName || channelBlacklist.length === 0) {
					return false;
				}
				return channelBlacklist.some((channel) => {
					const trimmedChannel = channel.trim();
					return trimmedChannel && message.channelName === trimmedChannel;
				});
			}

			/**
			 * Filter out messages from blacklisted channels
			 * @param {Message[]} messages - Array of messages to filter
			 * @param {string[]} channelBlacklist - Array of channel names to filter
			 * @returns {Message[]} Filtered array
			 */
			function filterByChannel(messages, channelBlacklist) {
				if (channelBlacklist.length === 0) {
					return messages;
				}
				return messages.filter((msg) => !isInBlacklistedChannel(msg, channelBlacklist));
			}

			/**
			 * Check if a message text matches a marker pattern
			 * Matches patterns like: ——on——, --on--, ==on==, -on-, ——开始——, etc.
			 * @param {string} text - Message text to check
			 * @param {string} keyword - The keyword to match (e.g., "on", "off", "开始", "结束")
			 * @returns {boolean} true if the text matches the marker pattern
			 */
			function isMarkerMessage(text, keyword) {
				if (!text || !keyword) return false;
				const trimmed = text.trim();
				// Match pattern: (symbols)(keyword)(symbols) where symbols are -, —, =, etc.
				// The message should only contain the marker, no other content
				const pattern = new RegExp(`^[-—=－＝]+\\s*${escapeRegExp(keyword)}\\s*[-—=－＝]+$`, "i");
				return pattern.test(trimmed);
			}

			/**
			 * Escape special regex characters in a string
			 * @param {string} str - String to escape
			 * @returns {string} Escaped string
			 */
			function escapeRegExp(str) {
				return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
			}

			/**
			 * Filter messages by ON/OFF markers
			 * Only keeps messages between start and end markers
			 * @param {Message[]} messages - Array of messages to filter
			 * @param {string} startKeyword - Start marker keyword (e.g., "on", "开始")
			 * @param {string} endKeyword - End marker keyword (e.g., "off", "结束")
			 * @returns {Message[]} Filtered array containing only messages between markers
			 */
			function filterByMarkers(messages, startKeyword, endKeyword) {
				const result = [];
				let isRecording = false;

				for (const msg of messages) {
					const text = msg.text || "";

					// Check for start marker
					if (isMarkerMessage(text, startKeyword)) {
						isRecording = true;
						continue; // Don't include the marker itself
					}

					// Check for end marker
					if (isMarkerMessage(text, endKeyword)) {
						isRecording = false;
						continue; // Don't include the marker itself
					}

					// If we're in recording mode, include the message
					if (isRecording) {
						result.push(msg);
					}
				}

				return result;
			}

			/**
			 * Parse a comma-separated string into an array of trimmed strings
			 * Supports both English comma (,) and Chinese comma (，)
			 * @param {string} input - Comma-separated string
			 * @returns {string[]} Array of trimmed non-empty strings
			 */
			function parseCommaSeparated(input) {
				if (!input || typeof input !== "string") {
					return [];
				}
				return input
					.split(/[,，]/)
					.map((s) => s.trim())
					.filter((s) => s.length > 0);
			}

			/**
			 * Apply all filter rules to messages
			 * @param {Message[]} messages - Array of messages to filter
			 * @param {FilterRules} rules - Filter rules to apply
			 * @returns {{messages: Message[], originalCount: number, filteredCount: number, removedCount: number}}
			 */
			function applyFilters(messages, rules) {
				const originalCount = messages.length;
				let filtered = [...messages];

				// Apply marker filter first (ON/OFF)
				if (rules.useOnOffMarkers && rules.markerStart && rules.markerEnd) {
					filtered = filterByMarkers(filtered, rules.markerStart, rules.markerEnd);
				}

				// Apply empty message filter
				if (rules.removeEmpty) {
					filtered = filterEmptyMessages(filtered);
				}

				// Apply prefix filter
				if (rules.prefixBlacklist && rules.prefixBlacklist.length > 0) {
					filtered = filterByPrefix(filtered, rules.prefixBlacklist);
				}

				// Apply channel filter
				if (rules.channelBlacklist && rules.channelBlacklist.length > 0) {
					filtered = filterByChannel(filtered, rules.channelBlacklist);
				}

				return {
					messages: filtered,
					originalCount,
					filteredCount: filtered.length,
					removedCount: originalCount - filtered.length,
				};
			}

			/**
			 * Update filter statistics display
			 * @param {number} originalCount - Original message count
			 * @param {number} filteredCount - Filtered message count
			 * @param {number} removedCount - Removed message count
			 */
			function updateFilterStats(originalCount, filteredCount, removedCount) {
				DOM.filterStats.textContent = `过滤结果: ${filteredCount} / ${originalCount} 条消息 (移除 ${removedCount} 条)`;
			}

			/**
			 * Handle apply filter button click
			 */
			function handleApplyFilter() {
				// Read filter rules from UI
				state.filterRules.removeEmpty = DOM.filterEmpty.checked;
				state.filterRules.useOnOffMarkers = DOM.filterOnOff.checked;
				state.filterRules.markerStart = DOM.markerStart.value.trim() || "on";
				state.filterRules.markerEnd = DOM.markerEnd.value.trim() || "off";
				// prefixBlacklist is already managed by the tag system
				state.filterRules.channelBlacklist = getExcludedChannels();

				// Save filter options to localStorage
				saveFilterOptions();

				// Build a map of previous edits by message ID before filtering
				const previousEditsMap = new Map();
				state.editedMessages.forEach((msg) => {
					// Only store if the message has any edits
					if (
						msg.isEdited ||
						msg.bgmUrl !== undefined ||
						msg.backgroundUrl ||
						(msg.stageEnter && msg.stageEnter.length > 0) ||
						(msg.stageExit && msg.stageExit.length > 0)
					) {
						previousEditsMap.set(msg.id, {
							isEdited: msg.isEdited,
							text: msg.text,
							name: msg.name,
							iconUrl: msg.iconUrl,
							bgmUrl: msg.bgmUrl,
							backgroundUrl: msg.backgroundUrl,
							stageEnter: msg.stageEnter,
							stageExit: msg.stageExit,
						});
					}
				});

				// First exclude deleted messages from original messages
				const messagesExcludingDeleted = state.originalMessages.filter((msg) => !state.deletedIds.has(msg.id));

				// Get inserted messages (messages that exist in editedMessages but not in originalMessages)
				const originalIds = new Set(state.originalMessages.map((msg) => msg.id));
				const insertedMessages = state.editedMessages.filter((msg) => !originalIds.has(msg.id));

				// Apply filters to messages excluding deleted ones
				const result = applyFilters(messagesExcludingDeleted, state.filterRules);

				// Add inserted messages back to the filtered result
				// Insert them at their original positions relative to the filtered messages
				const finalMessages = [...result.messages];
				insertedMessages.forEach((insertedMsg) => {
					// Find the position where this message should be inserted
					// by looking at its position in the current editedMessages
					const insertedIndex = state.editedMessages.findIndex((msg) => msg.id === insertedMsg.id);

					// Find the corresponding position in the filtered messages
					let targetIndex = 0;
					for (let i = 0; i < insertedIndex && i < state.editedMessages.length; i++) {
						const msgAtI = state.editedMessages[i];
						if (!state.deletedIds.has(msgAtI.id) && originalIds.has(msgAtI.id)) {
							// This is an original message that wasn't deleted
							// Check if it passed the filter
							const foundInFiltered = finalMessages.findIndex((fm) => fm.id === msgAtI.id);
							if (foundInFiltered >= 0) {
								targetIndex = foundInFiltered + 1;
							}
						} else if (!originalIds.has(msgAtI.id)) {
							// This is another inserted message that comes before
							const foundInFinal = finalMessages.findIndex((fm) => fm.id === msgAtI.id);
							if (foundInFinal >= 0) {
								targetIndex = foundInFinal + 1;
							}
						}
					}

					// Insert the message at the calculated position
					finalMessages.splice(targetIndex, 0, insertedMsg);
				});

				// Update the result to include inserted messages
				result.messages = finalMessages;
				result.filteredCount = finalMessages.length;

				// Restore previous edits to filtered messages
				result.messages.forEach((msg) => {
					const prevEdit = previousEditsMap.get(msg.id);
					if (prevEdit) {
						if (prevEdit.isEdited) {
							msg.isEdited = true;
							msg.text = prevEdit.text;
							msg.name = prevEdit.name;
							msg.iconUrl = prevEdit.iconUrl;
						}
						if (prevEdit.bgmUrl !== undefined) {
							msg.bgmUrl = prevEdit.bgmUrl;
						}
						if (prevEdit.backgroundUrl) {
							msg.backgroundUrl = prevEdit.backgroundUrl;
						}
						if (prevEdit.stageEnter && prevEdit.stageEnter.length > 0) {
							msg.stageEnter = prevEdit.stageEnter;
						}
						if (prevEdit.stageExit && prevEdit.stageExit.length > 0) {
							msg.stageExit = prevEdit.stageExit;
						}
					}
				});

				// Update state
				state.editedMessages = result.messages;
				state.meta.lastModified = Date.now();

				// Reset player position
				currentMessageIndex = 0;
				currentPage = 1;

				// Update UI
				renderMessageListFull();
				if (result.messages.length > 0) {
					displayMessage(0);
				} else {
					DOM.dialogueName.textContent = "";
					DOM.dialogueText.textContent = "没有符合条件的消息";
					DOM.portraitImg.classList.add("hidden");
				}
				updateProgress();
				updateFilterStats(result.originalCount, result.filteredCount, result.removedCount);

				console.log(`过滤完成: ${result.filteredCount}/${result.originalCount} 条消息`);
			}

			DOM.btnApplyFilter.addEventListener("click", handleApplyFilter);

			// Toggle ON/OFF settings visibility when checkbox changes
			DOM.filterOnOff.addEventListener("change", () => {
				DOM.onoffSettings.style.display = DOM.filterOnOff.checked ? "block" : "none";
			});

			// ============================================================
			// House Rules (村规) Functions
			// ============================================================

			/**
			 * Check if dice result is a CC (skill check) type
			 * CC format: "1D100<=60" or "(1D100<=60)" with comparison operator
			 * @param {string} result - Dice result text
			 * @returns {boolean}
			 */
			function isCCDiceRoll(result) {
				if (!result) return false;
				// CC检定特征：包含 1D100 和比较运算符 <= 或 <
				return /1D100\s*<[=]?\s*\d+/i.test(result);
			}

			/**
			 * Extract dice roll value from CC dice result text
			 * @param {string} result - Dice result text like "1D100<=60 → 23 成功"
			 * @returns {number|null} - The rolled value or null if not found
			 */
			function extractDiceValue(result) {
				if (!result) return null;
				// CC检定格式: "1D100<=60 → 23 成功" 或 "(1D100<=60) 獎勵・懲罰骰[0] ＞ 24 ＞ 24 ＞ 困難成功"

				// 尝试匹配 "→ 数字" 或 "＞ 数字" 格式，取第一个出现的数字结果
				const arrowMatch = result.match(/[→＞]\s*(\d+)/);
				if (arrowMatch) {
					return parseInt(arrowMatch[1], 10);
				}

				return null;
			}

			/**
			 * Replace the result suffix in dice result text
			 * @param {string} result - Original dice result text
			 * @param {string} newSuffix - New suffix to use (e.g., "極限成功", "大失敗")
			 * @returns {string} Modified result text
			 */
			function replaceDiceResultSuffix(result, newSuffix) {
				if (!result) return result;
				// 匹配末尾的判定词：成功、失敗、失败、極限成功、大成功、大失敗、大失败、困難成功、困难成功 等
				// 日文/繁体：成功、失敗、極限成功、大失敗、困難成功
				// 简体：成功、失败、大成功、大失败、困难成功
				const suffixPattern = /(極限成功|大成功|困難成功|困难成功|大失敗|大失败|成功|失敗|失败)\s*$/;
				return result.replace(suffixPattern, newSuffix);
			}

			/**
			 * Apply house rules to recalculate critical/fumble status
			 * @param {Message} msg - Message with diceInfo
			 * @param {Object} rules - House rules settings
			 * @returns {boolean} - Whether the message was modified
			 */
			function applyHouseRulesToMessage(msg, rules) {
				if (!msg.diceInfo || !msg.diceInfo.result) return false;

				// 只处理CC检定类型的骰点
				if (!isCCDiceRoll(msg.diceInfo.result)) return false;

				const diceValue = extractDiceValue(msg.diceInfo.result);
				if (diceValue === null) return false;

				const originalResult = msg.diceInfo.result;

				// 应用村规判定
				const isCritical = diceValue >= rules.criticalMin && diceValue <= rules.criticalMax;
				const isFumble = diceValue >= rules.fumbleMin && diceValue <= rules.fumbleMax;

				// 更新状态
				msg.diceInfo.isCritical = isCritical;
				msg.diceInfo.isFumble = isFumble;

				// 根据村规修改结果文本的判定词
				if (isCritical) {
					// 大成功 - 把任何成功类的判定改为"大成功"
					msg.diceInfo.result = replaceDiceResultSuffix(msg.diceInfo.result, "大成功");
					msg.diceInfo.isSuccess = true;
					msg.diceInfo.isFailure = false;
				} else if (isFumble) {
					// 大失败 - 把任何失败类的判定改为"大失败"
					msg.diceInfo.result = replaceDiceResultSuffix(msg.diceInfo.result, "大失败");
					msg.diceInfo.isFailure = true;
					msg.diceInfo.isSuccess = false;
				}

				// 只要文本有变化就算修改
				return originalResult !== msg.diceInfo.result;
			}

			/**
			 * Apply house rules to all messages
			 */
			function applyHouseRules() {
				const rules = state.houseRules;

				// 验证输入
				if (rules.criticalMin > rules.criticalMax) {
					alert("大成功范围设置错误：最小值不能大于最大值");
					return;
				}
				if (rules.fumbleMin > rules.fumbleMax) {
					alert("大失败范围设置错误：最小值不能大于最大值");
					return;
				}

				let modifiedCount = 0;
				let ccDiceCount = 0;

				state.editedMessages.forEach((msg) => {
					if (msg.diceInfo && msg.diceInfo.result && isCCDiceRoll(msg.diceInfo.result)) {
						ccDiceCount++;
						if (applyHouseRulesToMessage(msg, rules)) {
							modifiedCount++;
							// 不设置 isEdited，因为村规是批量操作，可以通过重置恢复
						}
					}
				});

				state.meta.lastModified = Date.now();

				// 更新UI
				renderMessageListFull();
				if (currentMessageIndex >= 0 && currentMessageIndex < state.editedMessages.length) {
					displayMessage(currentMessageIndex);
				}

				// 显示统计
				DOM.houseRulesStats.innerHTML = `
					✅ 村规已应用<br>
					CC检定: ${ccDiceCount} 条<br>
					判定变更: ${modifiedCount} 条<br>
					<span style="color: var(--text-secondary);">大成功: ${rules.criticalMin}-${rules.criticalMax}, 大失败: ${rules.fumbleMin}-${rules.fumbleMax}</span>
				`;
			}

			// House rules UI event listeners
			DOM.criticalMin.addEventListener("change", (e) => {
				state.houseRules.criticalMin = parseInt(e.target.value, 10) || 1;
			});

			DOM.criticalMax.addEventListener("change", (e) => {
				state.houseRules.criticalMax = parseInt(e.target.value, 10) || 5;
			});

			DOM.fumbleMin.addEventListener("change", (e) => {
				state.houseRules.fumbleMin = parseInt(e.target.value, 10) || 96;
			});

			DOM.fumbleMax.addEventListener("change", (e) => {
				state.houseRules.fumbleMax = parseInt(e.target.value, 10) || 100;
			});

			DOM.btnApplyHouseRules.addEventListener("click", applyHouseRules);

			/**
			 * Reset house rules - restore original dice info from originalMessages
			 */
			function resetHouseRules() {
				let resetCount = 0;

				state.editedMessages.forEach((msg) => {
					if (!msg.diceInfo) return;

					// 从原始消息中找到对应的消息
					const originalMsg = state.originalMessages.find((m) => m.id === msg.id);
					if (originalMsg && originalMsg.diceInfo) {
						// 检查骰点信息是否有变化
						const diceChanged =
							msg.diceInfo.isCritical !== originalMsg.diceInfo.isCritical ||
							msg.diceInfo.isFumble !== originalMsg.diceInfo.isFumble ||
							msg.diceInfo.isSuccess !== originalMsg.diceInfo.isSuccess ||
							msg.diceInfo.isFailure !== originalMsg.diceInfo.isFailure ||
							msg.diceInfo.result !== originalMsg.diceInfo.result;

						if (diceChanged) {
							// 恢复原始的骰点判定状态和结果文本
							msg.diceInfo.isCritical = originalMsg.diceInfo.isCritical;
							msg.diceInfo.isFumble = originalMsg.diceInfo.isFumble;
							msg.diceInfo.isSuccess = originalMsg.diceInfo.isSuccess;
							msg.diceInfo.isFailure = originalMsg.diceInfo.isFailure;
							msg.diceInfo.result = originalMsg.diceInfo.result;
							resetCount++;

							// 检查其他字段是否也和原始一致，如果是则清除"已编辑"标签
							const otherFieldsSame =
								msg.name === originalMsg.name && msg.text === originalMsg.text && msg.iconUrl === originalMsg.iconUrl;
							if (otherFieldsSame) {
								msg.isEdited = false;
							}
						}
					}
				});

				state.meta.lastModified = Date.now();

				// 更新UI
				renderMessageListFull();
				if (currentMessageIndex >= 0 && currentMessageIndex < state.editedMessages.length) {
					displayMessage(currentMessageIndex);
				}

				DOM.houseRulesStats.innerHTML = `🔄 已重置 ${resetCount} 条消息的骰点判定`;
			}

			DOM.btnResetHouseRules.addEventListener("click", resetHouseRules);

			// ============================================================
			// Portrait Mode Event Listeners
			// ============================================================

			DOM.btnResetPositions.addEventListener("click", () => {
				if (confirm("确定要重置所有差分位置吗？")) {
					resetPortraitPositions();
				}
			});

			// Scale mode change
			DOM.scaleMode.addEventListener("change", (e) => {
				const mode = e.target.value;
				state.portraitConfig.scaleMode = mode;

				if (mode === "canvas") {
					DOM.canvasSettings.style.display = "block";
					DOM.portraitArea.classList.add("canvas-mode");
					// Reset canvas view when switching to canvas mode
					canvasZoom = 1.0;
					canvasOffset = { x: 0, y: 0 };
					// Use requestAnimationFrame to ensure DOM is ready
					requestAnimationFrame(() => {
						updateCanvasScale();
					});
				} else {
					DOM.canvasSettings.style.display = "none";
					DOM.portraitArea.classList.remove("canvas-mode");
					removeCanvasContainer();
				}

				// Update all portrait positions
				updateAllPortraitPositions();
				state.meta.lastModified = Date.now();
			});

			// Canvas size inputs
			DOM.canvasWidth.addEventListener("change", (e) => {
				state.portraitConfig.canvasWidth = parseInt(e.target.value, 10) || 1920;
				if (state.portraitConfig.scaleMode === "canvas") {
					updateCanvasScale();
					updateAllPortraitPositions();
				}
				state.meta.lastModified = Date.now();
			});

			DOM.canvasHeight.addEventListener("change", (e) => {
				state.portraitConfig.canvasHeight = parseInt(e.target.value, 10) || 1080;
				if (state.portraitConfig.scaleMode === "canvas") {
					updateCanvasScale();
					updateAllPortraitPositions();
				}
				state.meta.lastModified = Date.now();
			});

			// Canvas preset select
			DOM.canvasPreset.addEventListener("change", (e) => {
				const preset = e.target.value;
				if (preset) {
					const [width, height] = preset.split("x").map(Number);
					DOM.canvasWidth.value = width;
					DOM.canvasHeight.value = height;
					state.portraitConfig.canvasWidth = width;
					state.portraitConfig.canvasHeight = height;
					if (state.portraitConfig.scaleMode === "canvas") {
						updateCanvasScale();
						updateAllPortraitPositions();
					}
					state.meta.lastModified = Date.now();
				}
			});

			// Dialogue style event listeners
			function updateDialogueStyle() {
				const canvasInner = DOM.portraitArea.querySelector(".portrait-canvas-inner");
				if (canvasInner) {
					applyCanvasDialogueStyles(canvasInner);
				}
				state.meta.lastModified = Date.now();
			}

			DOM.dialogueFontSize?.addEventListener("change", (e) => {
				state.portraitConfig.dialogueStyle.fontSize = parseInt(e.target.value, 10) || 24;
				updateDialogueStyle();
			});

			DOM.dialogueNameSize?.addEventListener("change", (e) => {
				state.portraitConfig.dialogueStyle.nameSize = parseInt(e.target.value, 10) || 20;
				updateDialogueStyle();
			});

			DOM.dialogueBgOpacity?.addEventListener("input", (e) => {
				const value = parseInt(e.target.value, 10) || 70;
				state.portraitConfig.dialogueStyle.bgOpacity = value;
				if (DOM.dialogueBgOpacityValue) {
					DOM.dialogueBgOpacityValue.textContent = `${value}%`;
				}
				updateDialogueStyle();
			});

			DOM.dialogueBgImage?.addEventListener("change", (e) => {
				state.portraitConfig.dialogueStyle.bgImage = e.target.value.trim();
				updateDialogueStyle();
			});

			// Global color sync (color picker <-> text input)
			DOM.dialogueNameColor?.addEventListener("input", (e) => {
				state.portraitConfig.dialogueStyle.nameColor = e.target.value;
				if (DOM.dialogueNameColorText) DOM.dialogueNameColorText.value = e.target.value;
				updateDialogueTextStyle();
				renderCharacterStyleList();
			});

			DOM.dialogueNameColorText?.addEventListener("input", (e) => {
				const value = e.target.value;
				if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
					state.portraitConfig.dialogueStyle.nameColor = value;
					if (DOM.dialogueNameColor) DOM.dialogueNameColor.value = value;
					updateDialogueTextStyle();
					renderCharacterStyleList();
				}
			});

			DOM.dialogueTextColor?.addEventListener("input", (e) => {
				state.portraitConfig.dialogueStyle.textColor = e.target.value;
				if (DOM.dialogueTextColorText) DOM.dialogueTextColorText.value = e.target.value;
				updateDialogueTextStyle();
				renderCharacterStyleList();
			});

			DOM.dialogueTextColorText?.addEventListener("input", (e) => {
				const value = e.target.value;
				if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
					state.portraitConfig.dialogueStyle.textColor = value;
					if (DOM.dialogueTextColor) DOM.dialogueTextColor.value = value;
					updateDialogueTextStyle();
					renderCharacterStyleList();
				}
			});

			DOM.dialogueFontFamily?.addEventListener("change", (e) => {
				state.portraitConfig.dialogueStyle.fontFamily = e.target.value;
				updateDialogueTextStyle();
			});

			DOM.dialogueHeight?.addEventListener("change", (e) => {
				state.portraitConfig.dialogueStyle.height = parseInt(e.target.value, 10) || 150;
				updateDialogueStyle();
			});

			DOM.dialoguePaddingX?.addEventListener("change", (e) => {
				state.portraitConfig.dialogueStyle.paddingX = parseInt(e.target.value, 10) || 20;
				updateDialogueStyle();
			});

			DOM.dialoguePaddingY?.addEventListener("change", (e) => {
				state.portraitConfig.dialogueStyle.paddingY = parseInt(e.target.value, 10) || 16;
				updateDialogueStyle();
			});

			// Reset dialogue position button
			DOM.btnResetDialoguePos?.addEventListener("click", () => {
				state.portraitConfig.dialogueStyle.x = null;
				state.portraitConfig.dialogueStyle.y = null;
				state.portraitConfig.dialogueStyle.width = 100;
				updateDialogueStyle();
				state.meta.lastModified = Date.now();
			});

			// Window resize handler with debounce
			let resizeTimeout = null;
			window.addEventListener("resize", () => {
				// 清除之前的定时器
				if (resizeTimeout) {
					clearTimeout(resizeTimeout);
				}
				// 延迟执行，等待 resize 完成
				resizeTimeout = setTimeout(() => {
					updateAllPortraitPositions();
				}, 150);
			});

			// Mouse wheel zoom for canvas mode
			DOM.portraitArea.addEventListener(
				"wheel",
				(e) => {
					if (state.portraitConfig.scaleMode !== "canvas") return;

					e.preventDefault();
					const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
					updateCanvasScale(zoomDelta);
				},
				{ passive: false }
			);

			// Canvas drag for panning
			DOM.portraitArea.addEventListener("mousedown", (e) => {
				if (state.portraitConfig.scaleMode !== "canvas") return;
				handleCanvasDragStart(e);
			});

			document.addEventListener("mousemove", (e) => {
				if (canvasDragState) {
					handleCanvasDrag(e);
				}
			});

			document.addEventListener("mouseup", () => {
				if (canvasDragState) {
					handleCanvasDragEnd();
				}
			});

			// Double-click to reset canvas view
			DOM.portraitArea.addEventListener("dblclick", (e) => {
				if (state.portraitConfig.scaleMode !== "canvas") return;
				// Only reset if clicking on background
				if (e.target === DOM.portraitArea || e.target.classList.contains("portrait-canvas-inner")) {
					resetCanvasView();
				}
			});

			// Player control buttons
			DOM.btnPrev.addEventListener("click", () => goToPrevious());
			DOM.btnNext.addEventListener("click", () => goToNext());
			DOM.btnAutoPlay.addEventListener("click", toggleAutoPlay);

			// Dialogue area click handler
			DOM.dialogueArea.addEventListener("click", handleDialogueClick);

			// Dialogue area right-click context menu (for dialogue box)
			DOM.dialogueArea.addEventListener("contextmenu", handleDialogueContextMenu);

			// Canvas area right-click context menu (for portrait area, stage, background, bgm)
			DOM.portraitArea.addEventListener("contextmenu", (e) => {
				e.preventDefault();

				const canvasDialogue = e.target.closest(".canvas-dialogue-box");
				const portraitWrapper = e.target.closest(".portrait-wrapper");
				const canvasInner = e.target.closest(".portrait-canvas-inner");

				if (canvasDialogue) {
					// Right-click on dialogue box - show dialogue menu
					handleDialogueContextMenu(e);
				} else if (portraitWrapper) {
					// Right-click on portrait - open quick portrait edit if it's current speaker
					const characterName = portraitWrapper.dataset.name;
					const currentMsg = state.editedMessages[currentMessageIndex];
					if (currentMsg && currentMsg.name === characterName) {
						openQuickPortraitEdit(currentMessageIndex, "replay");
					}
				} else if (canvasInner || e.target === DOM.portraitArea) {
					// Right-click on canvas area or portrait area background - show canvas menu
					handleCanvasContextMenu(e);
				}
			});

			// Hide context menus when clicking elsewhere
			document.addEventListener("click", hideAllContextMenus);

			// Context menu item click handlers
			DOM.dialogueContextMenu.addEventListener("click", handleDialogueMenuAction);
			DOM.canvasContextMenu.addEventListener("click", handleCanvasMenuAction);

			/**
			 * Show dialogue context menu (for dialogue box)
			 * @param {MouseEvent} e - Right-click event
			 */
			function handleDialogueContextMenu(e) {
				e.preventDefault();
				e.stopPropagation();

				// Only show if there's a current message
				if (state.editedMessages.length === 0 || currentMessageIndex < 0) return;

				hideAllContextMenus();
				showContextMenu(DOM.dialogueContextMenu, e.clientX, e.clientY);
			}

			/**
			 * Show canvas context menu (for portrait area)
			 * @param {MouseEvent} e - Right-click event
			 */
			function handleCanvasContextMenu(e) {
				// Only show if there's a current message
				if (state.editedMessages.length === 0 || currentMessageIndex < 0) return;

				hideAllContextMenus();
				showContextMenu(DOM.canvasContextMenu, e.clientX, e.clientY);
			}

			/**
			 * Show a context menu at position
			 * @param {HTMLElement} menu - Menu element
			 * @param {number} x - X position
			 * @param {number} y - Y position
			 */
			function showContextMenu(menu, x, y) {
				menu.classList.add("visible");
				const menuRect = menu.getBoundingClientRect();

				if (x + menuRect.width > window.innerWidth) {
					x = window.innerWidth - menuRect.width - 10;
				}
				if (y + menuRect.height > window.innerHeight) {
					y = window.innerHeight - menuRect.height - 10;
				}

				menu.style.left = `${x}px`;
				menu.style.top = `${y}px`;
			}

			/**
			 * Hide all context menus
			 */
			function hideAllContextMenus() {
				DOM.dialogueContextMenu.classList.remove("visible");
				DOM.canvasContextMenu.classList.remove("visible");
				DOM.portraitContextMenu.classList.remove("visible");
				DOM.messageContextMenu.classList.remove("visible");
			}

			/**
			 * Handle dialogue menu action (edit, dialogue-bg)
			 * @param {MouseEvent} e - Click event
			 */
			function handleDialogueMenuAction(e) {
				const item = e.target.closest(".context-menu-item");
				if (!item) return;

				const action = item.dataset.action;
				const msg = state.editedMessages[currentMessageIndex];
				if (!msg) return;

				hideAllContextMenus();

				switch (action) {
					case "edit":
						openEditModal(msg, currentMessageIndex);
						break;
					case "dialogue-bg":
						// Open dialogue background setting in drawer
						// Scroll to dialogue style section and focus on bg image input
						if (DOM.dialogueBgImage) {
							DOM.dialogueBgImage.focus();
							DOM.dialogueBgImage.scrollIntoView({ behavior: "smooth", block: "center" });
						}
						break;
				}
			}

			/**
			 * Handle canvas menu action (stage, background, bgm)
			 * @param {MouseEvent} e - Click event
			 */
			function handleCanvasMenuAction(e) {
				const item = e.target.closest(".context-menu-item");
				if (!item) return;

				const action = item.dataset.action;
				const msg = state.editedMessages[currentMessageIndex];
				if (!msg) return;

				hideAllContextMenus();

				switch (action) {
					case "stage":
						openStageModal(msg, currentMessageIndex);
						break;
					case "background":
						openBackgroundModal(msg, currentMessageIndex);
						break;
					case "bgm":
						openBgmModal(msg, currentMessageIndex);
						break;
				}
			}

			/**
			 * Handle portrait menu action (edit-portrait, edit-tts)
			 * @param {MouseEvent} e - Click event
			 */
			function handlePortraitMenuAction(e) {
				const item = e.target.closest(".context-menu-item");
				if (!item) return;

				const action = item.dataset.action;
				const msg = state.editedMessages[currentMessageIndex];
				if (!msg || !msg.name) return;

				hideAllContextMenus();

				switch (action) {
					case "edit-portrait":
						if (msg.iconUrl) {
							openQuickPortraitEdit(currentMessageIndex, "replay");
						}
						break;
					case "edit-tts":
						openQuickTtsModal(msg.name);
						break;
				}
			}

			// Quick TTS Modal state
			let quickTtsCharacterName = null;

			/**
			 * Open quick TTS settings modal
			 * @param {string} characterName - Character name
			 */
			function openQuickTtsModal(characterName) {
				quickTtsCharacterName = characterName;
				const char = state.characters[characterName];
				if (!char) return;

				// Initialize voice if not exists
				if (!char.voice) {
					char.voice = { enabled: false, voiceName: "", rate: 1, pitch: 1, volume: 1 };
				}

				DOM.quickTtsTitle.textContent = `TTS设置 - ${characterName}`;

				// Populate voice options
				const voiceGroups = { zh: [], ja: [], en: [], other: [] };
				TTSManager.voices.forEach((v) => {
					if (v.lang.startsWith("zh")) voiceGroups.zh.push(v);
					else if (v.lang.startsWith("ja")) voiceGroups.ja.push(v);
					else if (v.lang.startsWith("en")) voiceGroups.en.push(v);
					else voiceGroups.other.push(v);
				});

				let options = '<option value="">不使用语音</option>';
				if (voiceGroups.zh.length > 0) {
					options += '<optgroup label="中文">';
					voiceGroups.zh.forEach((v) => {
						const selected = char.voice.voiceName === v.name ? "selected" : "";
						options += `<option value="${v.name}" ${selected}>${v.name}</option>`;
					});
					options += "</optgroup>";
				}
				if (voiceGroups.ja.length > 0) {
					options += '<optgroup label="日语">';
					voiceGroups.ja.forEach((v) => {
						const selected = char.voice.voiceName === v.name ? "selected" : "";
						options += `<option value="${v.name}" ${selected}>${v.name}</option>`;
					});
					options += "</optgroup>";
				}
				if (voiceGroups.en.length > 0) {
					options += '<optgroup label="英语">';
					voiceGroups.en.forEach((v) => {
						const selected = char.voice.voiceName === v.name ? "selected" : "";
						options += `<option value="${v.name}" ${selected}>${v.name}</option>`;
					});
					options += "</optgroup>";
				}

				DOM.quickTtsVoice.innerHTML = options;
				DOM.quickTtsRate.value = char.voice.rate || 1;
				DOM.quickTtsRateValue.textContent = char.voice.rate || 1;
				DOM.quickTtsPitch.value = char.voice.pitch || 1;
				DOM.quickTtsPitchValue.textContent = char.voice.pitch || 1;
				DOM.quickTtsVolume.value = char.voice.volume || 1;
				DOM.quickTtsVolumeValue.textContent = char.voice.volume || 1;

				DOM.modalQuickTts.classList.add("visible");
			}

			/**
			 * Close quick TTS modal
			 */
			function closeQuickTtsModal() {
				DOM.modalQuickTts.classList.remove("visible");
				quickTtsCharacterName = null;
			}

			/**
			 * Save quick TTS settings
			 */
			function saveQuickTtsSettings() {
				if (!quickTtsCharacterName) return;
				const char = state.characters[quickTtsCharacterName];
				if (!char) return;

				char.voice = {
					enabled: !!DOM.quickTtsVoice.value,
					voiceName: DOM.quickTtsVoice.value,
					rate: parseFloat(DOM.quickTtsRate.value),
					pitch: parseFloat(DOM.quickTtsPitch.value),
					volume: parseFloat(DOM.quickTtsVolume.value),
				};

				state.meta.lastModified = Date.now();
				closeQuickTtsModal();
			}

			/**
			 * Test quick TTS voice
			 */
			function testQuickTtsVoice() {
				const voiceName = DOM.quickTtsVoice.value;
				if (!voiceName) return;

				const testText = quickTtsCharacterName ? `你好，我是${quickTtsCharacterName}` : "这是一段测试语音";
				const config = {
					voiceName: voiceName,
					rate: parseFloat(DOM.quickTtsRate.value),
					pitch: parseFloat(DOM.quickTtsPitch.value),
					volume: parseFloat(DOM.quickTtsVolume.value),
				};

				TTSManager.speak(testText, config);
			}

			/**
			 * Reset quick TTS settings
			 */
			function resetQuickTtsSettings() {
				DOM.quickTtsVoice.value = "";
				DOM.quickTtsRate.value = 1;
				DOM.quickTtsRateValue.textContent = "1";
				DOM.quickTtsPitch.value = 1;
				DOM.quickTtsPitchValue.textContent = "1";
				DOM.quickTtsVolume.value = 1;
				DOM.quickTtsVolumeValue.textContent = "1";
			}

			// Quick TTS modal event listeners
			DOM.modalQuickTtsClose.addEventListener("click", closeQuickTtsModal);
			DOM.modalQuickTtsCancel.addEventListener("click", closeQuickTtsModal);
			DOM.modalQuickTtsSave.addEventListener("click", saveQuickTtsSettings);
			DOM.quickTtsTest.addEventListener("click", testQuickTtsVoice);
			DOM.quickTtsReset.addEventListener("click", resetQuickTtsSettings);
			setupModalOverlayClose(DOM.modalQuickTts, closeQuickTtsModal);

			// Quick TTS range input listeners
			DOM.quickTtsRate.addEventListener("input", (e) => {
				DOM.quickTtsRateValue.textContent = e.target.value;
			});
			DOM.quickTtsPitch.addEventListener("input", (e) => {
				DOM.quickTtsPitchValue.textContent = e.target.value;
			});
			DOM.quickTtsVolume.addEventListener("input", (e) => {
				DOM.quickTtsVolumeValue.textContent = e.target.value;
			});

			// Portrait context menu event listener
			DOM.portraitContextMenu.addEventListener("click", handlePortraitMenuAction);

			// Progress bar click handler
			DOM.progressBar.addEventListener("click", handleProgressBarClick);

			// Keyboard shortcuts
			document.addEventListener("keydown", (e) => {
				// Only handle shortcuts when not in input fields
				if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") return;

				// Only handle in replay view
				if (currentView !== "replay") return;

				switch (e.key) {
					case "ArrowLeft":
						e.preventDefault();
						goToPrevious();
						break;
					case "ArrowRight":
					case " ":
					case "Enter":
						e.preventDefault();
						handleDialogueClick();
						break;
					case "h":
					case "H":
						e.preventDefault();
						DOM.historyPanel.classList.toggle("visible");
						if (DOM.historyPanel.classList.contains("visible")) {
							renderHistoryPanel();
						}
						break;
					case "Escape":
						if (DOM.historyPanel.classList.contains("visible")) {
							DOM.historyPanel.classList.remove("visible");
						}
						break;
				}
			});

			DOM.btnImport.addEventListener("click", () => {
				importProjectJSON();
			});

			DOM.btnSave.addEventListener("click", () => {
				exportProjectJSON();
			});

			DOM.btnExportLog.addEventListener("click", () => {
				exportLogText();
			});

			// ============================================================
			// View Switcher Event Listeners
			// ============================================================

			DOM.btnViewReplay.addEventListener("click", () => switchView("replay"));
			DOM.btnViewList.addEventListener("click", () => switchView("list"));
			DOM.btnViewCharacter.addEventListener("click", () => switchView("character"));

			// ============================================================
			// Pagination Event Listeners
			// ============================================================

			DOM.pageSizeSelect.addEventListener("change", (e) => {
				pageSize = parseInt(e.target.value, 10);
				currentPage = 1;
				renderMessageListFull();
			});

			DOM.btnPageFirst.addEventListener("click", () => {
				currentPage = 1;
				renderMessageListFull();
			});

			DOM.btnPagePrev.addEventListener("click", () => {
				if (currentPage > 1) {
					currentPage--;
					renderMessageListFull();
				}
			});

			DOM.btnPageNext.addEventListener("click", () => {
				const totalPages = Math.ceil(state.editedMessages.length / pageSize) || 1;
				if (currentPage < totalPages) {
					currentPage++;
					renderMessageListFull();
				}
			});

			DOM.btnPageLast.addEventListener("click", () => {
				const totalPages = Math.ceil(state.editedMessages.length / pageSize) || 1;
				currentPage = totalPages;
				renderMessageListFull();
			});

			// Page jump input
			DOM.paginationInput.addEventListener("keydown", (e) => {
				if (e.key === "Enter") {
					const totalPages = Math.ceil(state.editedMessages.length / pageSize) || 1;
					let page = parseInt(DOM.paginationInput.value, 10);
					if (isNaN(page) || page < 1) page = 1;
					if (page > totalPages) page = totalPages;
					currentPage = page;
					renderMessageListFull();
				}
			});

			DOM.paginationInput.addEventListener("blur", () => {
				const totalPages = Math.ceil(state.editedMessages.length / pageSize) || 1;
				let page = parseInt(DOM.paginationInput.value, 10);
				if (isNaN(page) || page < 1) page = 1;
				if (page > totalPages) page = totalPages;
				if (page !== currentPage) {
					currentPage = page;
					renderMessageListFull();
				} else {
					DOM.paginationInput.value = currentPage;
				}
			});

			// ============================================================
			// Message Clipboard (Copy/Cut/Paste)
			// ============================================================

			const MessageClipboard = {
				messages: [], // 复制/剪切的消息数组
				isCut: false, // 是否是剪切操作
				sourceIds: [], // 原消息ID列表（用于剪切）

				copy(msg, index) {
					const copied = JSON.parse(JSON.stringify(msg));
					copied.id = crypto.randomUUID();
					this.messages = [copied];
					this.isCut = false;
					this.sourceIds = [];
					DOM.messagePasteItem.style.display = "flex";
				},

				cut(msg, index) {
					this.messages = [JSON.parse(JSON.stringify(msg))];
					this.isCut = true;
					this.sourceIds = [msg.id];
					DOM.messagePasteItem.style.display = "flex";
				},

				// 批量复制
				copyBatch(selectedIds) {
					// 按原顺序获取选中的消息
					this.messages = state.editedMessages
						.filter((m) => selectedIds.has(m.id))
						.map((m) => {
							const copied = JSON.parse(JSON.stringify(m));
							copied.id = crypto.randomUUID();
							return copied;
						});
					this.isCut = false;
					this.sourceIds = [];
					DOM.messagePasteItem.style.display = "flex";
				},

				// 批量剪切
				cutBatch(selectedIds) {
					// 按原顺序获取选中的消息
					this.messages = state.editedMessages
						.filter((m) => selectedIds.has(m.id))
						.map((m) => JSON.parse(JSON.stringify(m)));
					this.isCut = true;
					this.sourceIds = Array.from(selectedIds);
					DOM.messagePasteItem.style.display = "flex";
				},

				paste(targetIndex) {
					if (this.messages.length === 0) return;

					// 如果是剪切，先删除原消息
					if (this.isCut && this.sourceIds.length > 0) {
						const idsToRemove = new Set(this.sourceIds);
						// 计算有多少被删除的消息在目标位置之前
						let removedBefore = 0;
						state.editedMessages.forEach((m, i) => {
							if (idsToRemove.has(m.id) && i <= targetIndex) {
								removedBefore++;
							}
						});
						// 删除原消息
						state.editedMessages = state.editedMessages.filter((m) => !idsToRemove.has(m.id));
						// 调整目标索引
						targetIndex -= removedBefore;
						this.isCut = false;
						this.sourceIds = [];
					}

					// 为复制的消息生成新ID
					const toInsert = this.messages.map((m) => {
						const newMsg = JSON.parse(JSON.stringify(m));
						newMsg.id = crypto.randomUUID();
						return newMsg;
					});

					// 插入到目标位置之后
					state.editedMessages.splice(targetIndex + 1, 0, ...toInsert);

					state.meta.lastModified = Date.now();
					renderMessageListFull();
				},

				hasContent() {
					return this.messages.length > 0;
				},

				clear() {
					this.messages = [];
					this.isCut = false;
					this.sourceIds = [];
					DOM.messagePasteItem.style.display = "none";
				},
			};

			// 右键菜单相关
			let messageContextTarget = { msg: null, index: -1 };

			function showMessageContextMenu(e, msg, index) {
				e.preventDefault();
				hideAllContextMenus();

				messageContextTarget = { msg, index };

				// 显示/隐藏粘贴选项
				DOM.messagePasteItem.style.display = MessageClipboard.hasContent() ? "flex" : "none";

				// 显示/隐藏重置选项（只对已编辑的消息显示）
				const resetItem = document.getElementById("message-reset-item");
				if (resetItem) {
					resetItem.style.display = msg.isEdited ? "flex" : "none";
				}

				// 定位菜单
				const menu = DOM.messageContextMenu;
				menu.style.left = `${e.clientX}px`;
				menu.style.top = `${e.clientY}px`;
				menu.classList.add("visible");

				// 确保菜单不超出视口
				const rect = menu.getBoundingClientRect();
				if (rect.right > window.innerWidth) {
					menu.style.left = `${window.innerWidth - rect.width - 10}px`;
				}
				if (rect.bottom > window.innerHeight) {
					menu.style.top = `${window.innerHeight - rect.height - 10}px`;
				}
			}

			function handleMessageContextAction(e) {
				const item = e.target.closest(".context-menu-item");
				if (!item) return;

				const action = item.dataset.action;
				const { msg, index } = messageContextTarget;

				hideAllContextMenus();

				if (!msg && action !== "paste") return;

				switch (action) {
					case "copy":
						MessageClipboard.copy(msg, index);
						break;
					case "cut":
						MessageClipboard.cut(msg, index);
						break;
					case "paste":
						MessageClipboard.paste(index);
						break;
					case "edit":
						openEditModal(msg, index);
						break;
					case "insert":
						openInsertModal(index + 1);
						break;
					case "insert-dice":
						openInsertDiceModal(index + 1);
						break;
					case "reset":
						resetSingleMessage(index);
						break;
					case "delete":
						if (confirm("确定要删除这条消息吗？")) {
							state.editedMessages = state.editedMessages.filter((m) => m.id !== msg.id);
							state.deletedIds.add(msg.id);
							renderMessageListFull();
							renderBackgroundSwitchList();
							updateProgress();
						}
						break;
				}
			}

			// 绑定右键菜单事件
			DOM.messageContextMenu.addEventListener("click", handleMessageContextAction);

			// ============================================================
			// Edit Mode Toggle
			// ============================================================

			let isEditMode = false; // 默认阅读模式

			function updateEditMode() {
				if (isEditMode) {
					DOM.messageListFull.classList.add("edit-mode");
					DOM.btnEditMode.textContent = "✏️";
					DOM.btnEditMode.title = "当前：编辑模式（点击切换到阅读模式）";
					DOM.btnEditMode.classList.add("active");
				} else {
					DOM.messageListFull.classList.remove("edit-mode");
					DOM.btnEditMode.textContent = "📖";
					DOM.btnEditMode.title = "当前：阅读模式（点击切换到编辑模式）";
					DOM.btnEditMode.classList.remove("active");
				}
			}

			DOM.btnEditMode.addEventListener("click", () => {
				isEditMode = !isEditMode;
				updateEditMode();
			});

			// 初始化编辑模式
			updateEditMode();

			// ============================================================
			// Message Search Functions
			// ============================================================

			const MessageSearch = {
				isOpen: false,
				results: [],
				currentIndex: -1,

				open() {
					this.isOpen = true;
					DOM.messageSearchToolbar.classList.add("visible");
					DOM.btnMessageSearch.classList.add("active");
					this.updateCharacterOptions();
					DOM.messageSearchInput.focus();
				},

				close() {
					this.isOpen = false;
					DOM.messageSearchToolbar.classList.remove("visible");
					DOM.btnMessageSearch.classList.remove("active");
					DOM.messageSearchInput.value = "";
					DOM.messageSearchCharacter.value = "";
					this.results = [];
					this.currentIndex = -1;
					this.updateCount();
					this.clearHighlight();
				},

				updateCharacterOptions() {
					const characters = extractCharacters(state.editedMessages);
					const options = ['<option value="">全部角色</option>'];
					// 添加骰子筛选选项
					options.push('<option value="__dice__">骰点消息</option>');
					characters.forEach((_, name) => {
						options.push(`<option value="${name}">${name}</option>`);
					});
					DOM.messageSearchCharacter.innerHTML = options.join("");
				},

				search() {
					const character = DOM.messageSearchCharacter.value;
					const keyword = DOM.messageSearchInput.value.trim().toLowerCase();

					if (!character && !keyword) {
						this.results = [];
						this.currentIndex = -1;
						this.updateCount();
						return;
					}

					this.results = [];
					state.editedMessages.forEach((msg, index) => {
						let match = true;
						// 特殊处理骰子筛选
						if (character === "__dice__") {
							if (!msg.diceInfo || !msg.diceInfo.result) match = false;
						} else if (character && msg.name !== character) {
							match = false;
						}
						// 搜索关键词时也包含骰点结果
						if (keyword) {
							const textContent = (msg.text || "").toLowerCase();
							const diceContent = (msg.diceInfo?.result || "").toLowerCase();
							if (!textContent.includes(keyword) && !diceContent.includes(keyword)) {
								match = false;
							}
						}
						if (match) this.results.push(index);
					});

					this.currentIndex = this.results.length > 0 ? 0 : -1;
					this.updateCount();

					if (this.currentIndex >= 0) {
						this.jumpToCurrent();
					}
				},

				next() {
					if (this.results.length === 0) return;
					this.currentIndex = (this.currentIndex + 1) % this.results.length;
					this.updateCount();
					this.jumpToCurrent();
				},

				prev() {
					if (this.results.length === 0) return;
					this.currentIndex = (this.currentIndex - 1 + this.results.length) % this.results.length;
					this.updateCount();
					this.jumpToCurrent();
				},

				jumpToCurrent() {
					if (this.currentIndex < 0 || this.results.length === 0) return;

					const msgIndex = this.results[this.currentIndex];
					const targetPage = Math.floor(msgIndex / pageSize) + 1;

					if (currentPage !== targetPage) {
						currentPage = targetPage;
						renderMessageListFull();
					}

					// Highlight and scroll to the message
					this.highlightMessage(msgIndex);
				},

				highlightMessage(msgIndex) {
					this.clearHighlight();
					const items = DOM.messageListFull.querySelectorAll(".message-item");
					const startIndex = (currentPage - 1) * pageSize;

					items.forEach((item, i) => {
						if (startIndex + i === msgIndex) {
							item.classList.add("search-highlight");
							item.scrollIntoView({ behavior: "smooth", block: "center" });
						}
					});
				},

				clearHighlight() {
					DOM.messageListFull.querySelectorAll(".search-highlight").forEach((el) => {
						el.classList.remove("search-highlight");
					});
				},

				updateCount() {
					const total = this.results.length;
					const current = total > 0 ? this.currentIndex + 1 : 0;
					DOM.messageSearchCount.textContent = `${current}/${total}`;
				},
			};

			// Search event listeners
			DOM.btnMessageSearch.addEventListener("click", () => {
				if (MessageSearch.isOpen) {
					MessageSearch.close();
				} else {
					MessageSearch.open();
				}
			});

			DOM.btnSearchClose.addEventListener("click", () => MessageSearch.close());
			DOM.btnSearchPrev.addEventListener("click", () => MessageSearch.prev());
			DOM.btnSearchNext.addEventListener("click", () => MessageSearch.next());

			DOM.messageSearchInput.addEventListener("input", () => MessageSearch.search());
			DOM.messageSearchCharacter.addEventListener("change", () => MessageSearch.search());

			DOM.messageSearchInput.addEventListener("keydown", (e) => {
				if (e.key === "Enter") {
					e.preventDefault();
					if (e.shiftKey) {
						MessageSearch.prev();
					} else {
						MessageSearch.next();
					}
				} else if (e.key === "Escape") {
					MessageSearch.close();
				}
			});

			// Message batch selection event listeners
			DOM.btnMessageBatchMode.addEventListener("click", () => {
				if (MessageBatchSelectionState.enabled) {
					MessageBatchSelectionState.exitBatchMode();
				} else {
					MessageBatchSelectionState.enterBatchMode();
				}
			});

			DOM.btnMessageSelectAll.addEventListener("click", () => {
				MessageBatchSelectionState.selectAll();
			});

			DOM.btnMessageDeselectAll.addEventListener("click", () => {
				MessageBatchSelectionState.deselectAll();
			});

			DOM.btnMessageBatchCopy.addEventListener("click", () => {
				if (MessageBatchSelectionState.getSelectedCount() === 0) {
					alert("请先选择要复制的消息");
					return;
				}
				MessageClipboard.copyBatch(MessageBatchSelectionState.selectedMessages);
				const count = MessageBatchSelectionState.getSelectedCount();
				MessageBatchSelectionState.exitBatchMode();
				alert(`已复制 ${count} 条消息，右键点击目标位置选择"粘贴到此处"`);
			});

			DOM.btnMessageBatchCut.addEventListener("click", () => {
				if (MessageBatchSelectionState.getSelectedCount() === 0) {
					alert("请先选择要剪切的消息");
					return;
				}
				MessageClipboard.cutBatch(MessageBatchSelectionState.selectedMessages);
				const count = MessageBatchSelectionState.getSelectedCount();
				MessageBatchSelectionState.exitBatchMode();
				alert(`已剪切 ${count} 条消息，右键点击目标位置选择"粘贴到此处"`);
			});

			DOM.btnMessageBatchDelete.addEventListener("click", () => {
				if (MessageBatchSelectionState.getSelectedCount() === 0) {
					alert("请先选择要删除的消息");
					return;
				}
				openMessageBatchDeleteModal();
			});

			DOM.btnMessageBatchClose.addEventListener("click", () => {
				MessageBatchSelectionState.exitBatchMode();
			});

			// Message batch delete modal event listeners
			DOM.modalMessageBatchDeleteClose.addEventListener("click", closeMessageBatchDeleteModal);
			DOM.modalMessageBatchDeleteCancel.addEventListener("click", closeMessageBatchDeleteModal);
			DOM.modalMessageBatchDeleteConfirm.addEventListener("click", confirmMessageBatchDelete);
			setupModalOverlayClose(DOM.modalMessageBatchDelete, closeMessageBatchDeleteModal);

			// ============================================================
			// Initialize
			// ============================================================

			// Initialize editor panel state (apply collapsed state on load)
			updateEditorPanelState();

			// Initialize character view
			initCharacterView();

			// Initialize batch selection
			initBatchSelection();

			// Initialize TTS Manager
			TTSManager.init().then(() => {
				console.log("TTS Manager initialized with", TTSManager.getVoices().length, "voices");
			});

			// Initialize BGM Manager
			BGMManager.init();

			// Sync BGM UI with state
			DOM.bgmVolumeSlider.value = state.bgmSettings.volume * 100;
			DOM.bgmVolumeValue.textContent = `${Math.round(state.bgmSettings.volume * 100)}%`;
			DOM.bgmMuteBtn.textContent = state.bgmSettings.muted ? "🔇" : "🔊";
			DOM.bgmLoopCheckbox.checked = state.bgmSettings.loop;

			// Render BGM library list
			renderBgmLibraryList();

			// Initialize canvas mode if it's the default
			if (state.portraitConfig.scaleMode === "canvas") {
				DOM.portraitArea.classList.add("canvas-mode");
				// Use requestAnimationFrame to ensure DOM is ready
				requestAnimationFrame(() => {
					updateCanvasScale();
				});
			}

			// Check for autosave data on load
			checkAutosave();

			// Start autosave timer
			startAutosave();

			// Handle page unload - save before leaving
			window.addEventListener("beforeunload", () => {
				// 有消息或有 BGM 库时都保存
				if (state.editedMessages.length > 0 || state.bgmLibrary.length > 0) {
					saveToLocalStorage();
				}
			});

			console.log("CCFOLIA Replay Editor initialized");
		</script>
	</body>
</html>
